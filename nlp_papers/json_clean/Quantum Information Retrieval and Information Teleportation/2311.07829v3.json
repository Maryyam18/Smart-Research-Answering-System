{
  "paperid": "2311.07829v3",
  "title": "Quantum X-Secure T -Private Information Retrieval From MDS Coded Storage With Unresponsive and Byzantine Servers",
  "authors": [
    "Lu",
    "Jafar",
    "Shamir",
    "Cleve",
    "Gottesman",
    "Lo",
    "Senthoor",
    "Sarvepalli",
    "Hayashi",
    "Song",
    "Chor",
    "Kushilevitz",
    "Goldreich",
    "Sudan",
    "Sun",
    "Jafar",
    "Freij-Hollanti",
    "Gnilke",
    "Hollanti",
    "Karpuk",
    "Tajeddine",
    "Gnilke",
    "Karpuk",
    "Freij-Hollanti",
    "Hollanti",
    "Song",
    "Hayashi",
    "Allaix",
    "Song",
    "Holzbaur",
    "Pllaha",
    "Hayashi",
    "Hollanti",
    "Aytekin",
    "Nomeir",
    "Vithana",
    "Ulukus",
    "Yu",
    "Li",
    "Raviv",
    "Kalan",
    "Soltanolkotabi",
    "Avestimehr",
    "Song",
    "Hayashi",
    "Yao",
    "Jafar",
    "Cramer",
    "Damgård",
    "Nielsen",
    "Kawachi",
    "Nishimura",
    "Christensen",
    "Popovski",
    "Lu",
    "Yao",
    "Jafar",
    "Aytekin",
    "Nomeir",
    "Ulukus",
    "Macwilliams",
    "Sloane",
    "Jia",
    "Jafar",
    "Calderbank",
    "Shor",
    "Steane",
    "Jia",
    "Sun",
    "Jafar",
    "Ulukus",
    "Avestimehr",
    "Gastpar",
    "Jafar",
    "Tandon",
    "Tian",
    "Allaix",
    "Lu",
    "Yao",
    "Pllaha",
    "Hollanti",
    "Jafar",
    "Lu",
    "Jafar",
    "Raviv",
    "Karpuk",
    "Chang",
    "Tandon",
    "Jia",
    "Jafar",
    "Brun",
    "Yang",
    "Shin",
    "Lee",
    "Nomeir",
    "Aytekin",
    "Ulukus",
    "Lu",
    "Jafar",
    "Ketkar",
    "Klappenecker",
    "Kumar",
    "Sarvepalli",
    "Golowich",
    "Guruswami",
    "Nielsen",
    "Chuang",
    "Yamamoto",
    "Wilde"
  ],
  "year": 2025,
  "abstract": "A communication-efficient protocol is introduced over a many-to-one quantum network for Q-E-B-MDS-X-TPIR, i.e., quantum private information retrieval with MDS-X-secure storage and T -private queries. The protocol is resilient to any set of up to E unresponsive servers (erased servers or stragglers) and any set of up to B Byzantine servers. The underlying coding scheme incorporates an enhanced version of a Cross Subspace Alignment (CSA) code, namely a Modified CSA (MCSA) code, into the framework of CSS codes. The error-correcting capabilities of CSS codes are leveraged to encode the dimensions that carry desired computation results from the MCSA code into the error space of the CSS code, while the undesired interference terms are aligned into the stabilized code space. The challenge is to do this efficiently while also correcting quantum erasures and Byzantine errors. The protocol achieves superdense coding gain over comparable classical baselines for Q-E-B-MDS-X-TPIR, recovers as special cases the state of art results for various other quantum PIR settings previously studied in the literature, and paves the way for applications in quantum coded distributed computation, where CSA code structures are important for communication efficiency, while security and resilience to stragglers and Byzantine servers are critical.",
  "sections": [
    {
      "heading": "I. INTRODUCTION",
      "text": "Recent interest in entanglement assisted computation over quantum many to one (also referred to as quantum multiple access (QMAC)) networks adds fundamentally novel dimensions to the rapidly expanding theory of distributed communication and computation, beyond its classical cornerstones such as secret-sharing [1]- [4], private information retrieval (PIR) [5]- [11], coded distributed computation and computation networks [12]- [14], and secure multiparty computation [15]- [19]. Ideas from these diverse perspectives are encapsulated in a variety of specialized coding structures -Reed-Solomon (RS) codes [20], Cross Subspace Alignment (CSA) codes [21], Lagrange Coded Computing [12], and CSS codes [22], [23], to name a few. Assimilating the specialized coding structures is essential for a unified theory that can facilitate a broader array of applications. This work represents such an endeavor, with the goal of developing a communication-efficient coding scheme (i.e., an efficient protocol) for Q-E-B-MDS-X-TPIR [21], i.e., quantum X-secure 1 T -private information retrieval from MDS coded storage that is resilient to up to E unresponsive servers (equivalently referred to as erased servers) and up to B Byzantine servers. 2   In the Q-E-B-MDS-X-TPIR [21] setting as shown in Fig. 1 there are N servers equipped beforehand (independent of the classical data) with optimally entangled quantum systems. Upon the commencement of the protocol, there are K classical messages W 1 , • • • , W K (files, datasets) that are distributed among the servers in an MDS coded and X-secure fashion. MDS coding implies that the messages together with some classical randomness Z (needed for security) are coded such that the storage size at each server is only a fraction 1/K c of the original size of the K messages. X-security means that even if any set of up to X servers collude they can learn nothing about the messages. A user (with its own private randomness Z ′ ) wishes to 1 X-security is a secret-sharing constraint. The messages are the secret and the storage at each server is its share of the secret, such that any set of up to X shares reveal nothing about the secret. There is another form of security, server secrecy [4], [9], [10], which requires that the user must not learn anything about any other message besides its desired message (also refered to as DB-privacy or symmetric privacy). Note that X-security is not related to server secrecy, and that we consider only the former (X-security) in this work. 2 When assembled with 'PIR', the abbreviation 'Q' stands for 'Quantum' (without 'Q', the setting is classical by default), 'E' stands for upto E erased servers ( unresponsive servers), 'B' stands for upto B Byzantine servers, 'MDS' stands for MDS coded storage, 'X' stands for X-secure storage (so that up to X colluding servers can learn nothing about the realizations of the stored messages) and 'T' stands for T -privacy constraint (so that up to T colluding servers can learn nothing about which message is desired). efficiently retrieve the θ th message (θ ∈ [K]) by querying the N servers in a T -private fashion. T -privacy means that even if any set of up to T servers collude they can learn nothing about which message is desired by the user. The efficiency of the protocol is measured by the rate, defined as the number of desired message bits retrieved per qubit (a d-dimensional quantum system (sometimes called a qudit) corresponds to log 2 (d) qubits) of total download from the servers. Each server generates its response based on the user's queries and the storage available to that server, and encodes it into its own quantum system through local quantum operations. The quantum systems are then sent as answers from the servers to the user. The protocol must tolerate up to E unresponsive servers, i.e., any set of up to E servers may be unresponsive, equivalently their answers are erased over the QMAC. The protocol must also tolerate any set of up to B Byzantine servers whose answers are subject to arbitrary errors. Note that while the user's queries are sent without knowledge of which servers may turn out to be unresponsive, once the user receives the quantum systems in response, it knows which servers' answers were erased (known-position error), i.e, which servers did not respond. The identities of the Byzantine servers are not directly revealed to the user from the answers. This corresponds to unknownposition errors in the context of error correcting codes. Resilience to unresponsive and Byzantine servers means that we require that regardless of which E servers are erased, and which B servers are Byzantine, the protocol must allow the user to recover its desired message by measuring the received quantum systems. Our solution centers around CSS codes and the classical CSA coding scheme originally introduced for X-TPIR, i.e., PIR with X-secure storage and T -private queries [24], and subsequently applied to a number of classical variants of PIR, coded computing and private read-write designs for federated submodel learning [25]. The classical CSA scheme was generalized to a quantum CSA scheme for Q-MDS-X-TPIR over the quantum many-to-one network in [26], [27], and its resilience to eavesdroppers was explored in [11]."
    },
    {
      "heading": "A. Challenges and Contributions",
      "text": "While we focus on Q-E-B-MDS-X-TPIR to motivate the protocol developed in this work, we expect the protocol to be much more broadly relevant. This is because the underlying challenge is how to efficiently transmit CSA coded classical symbols when there are quantum resources shared among servers, some of which can be unresponsive (stragglers) and/or Byzantine. CSA code structures are not limited to PIR. For example, CSA codes feature prominently in the broad Each server locally encodes its response into its quantum system and sends it back to the user. In the figure, unresponsive (blue) server's quantum system is not received, and the Byzantine (red) server applies an arbitrary quantum channel to its quantum system. area of coded distributed computation (CDC) [12], [28]- [30]. Thus, the protocol from this work could potentially be a useful stepping stone towards future studies of quantum CDC (QCDC). 3   Byzantine servers are more challenging in the quantum setting, because the same quantum entanglement that allows gains in communication efficiency under ideal conditions, also makes entangled protocols more susceptible to stragglers and Byzantine adversaries, as their actions impact not only their own quantum systems, but also the overall state of all entangled quantum systems. The challenges are listed as follows. 1) Compared with [26], [27] that studied Q-MDS-X-TPIR, the main challenge is to achieve resilience to unresponsive and Byzantine servers. In classical settings, this is done by having the answers form an error correcting code (ECC) of the desired message symbols (and interfering 3 The MDS storage can be viewed as coded matrix A, and the T private queries as coded matrix B. The computation of AB is distributed among servers. The MDS constraint limits upload cost, X-security/T -privacy protect against curious servers, and resilience to unresponsive/Byzantine servers guarantees robustness of the distributed computation. symbols introduced due to various constraints such as X-security, T -privacy and MDS storage) so that erasures or errors can be corrected first, after which the desired message symbols can be recovered. This idea is not directly applicable to quantum PIR schemes. Even though QPIR schemes are typically based on the stabilizer formalism [9], [10], [26], the error-correcting capabilities of stabilizer codes are not utilized to correct errors. Specifically, instead of the code space of a stabilizer code, in QPIR the information is encoded into the error space [31], and is extracted by the user by measuring the qudits (quantum digits, a specific representation of quantum systems that will be explained in Section II-A) with stabilizers to reveal the syndromes. Thus, the received N answer qudits in QPIR are not in the stabilizer code space, even in the absence of erasures or errors. 2) Compared with [4] that explored Q-TPIR with general access structure that involves resilience to E unresponsive servers as a special case, the main challenge is to come up with an efficient scheme that satisfies X-security and MDS storage constraints. Unlike the random coding based scheme that appears in [4], the CSA code structure is important to accommodate X-security and MDS storage. Note that even in the classical setting, CSA codes allow higher communication rates in PIR with these two constraints (e.g., the CSA code based scheme [21], [24] can achieve higher rates than those achieved without CSA codes in [28], [32]). 3) Utilizing CSA codes further prevents us from placing the answering qudits in the code space of a stabilizer code (without considering the erasure or Byzantine errors). Specifically, the CSA code is the direct sum of a Reed-Solomon code of interfering/undesired symbols and a Cauchy RS code of desired symbols. It is non-trivial to construct a CSS code upon two CSA codes CSA X , CSA Z , such that CSA ⊥ X ⊂ CSA Z . This is because the dual code of a CSA code should be dual to both the RS part and the Cauchy RS part, whose structures are not trivially compatible. Thus, our main contribution is a protocol that utilizes the error-correcting capabilities of CSS codes, i.e., the information carrying ability of their syndromes as the underlying framework. Within this framework, the protocol exploits the RS sub-code of CSA codes to efficiently retrieve the desired computation results (desired message symbols in the PIR problem) that are encoded by classical codes, 4 while also tolerating quantum erasures and Byzantine errors. Intuitively, in the underlying classical CSA code based protocol, the answers from the servers are viewed 4 We refer to the desired message symbols as the computation results to emphasize that they are the outcome of the computation task, e.g., PIR. as the RS sub-code of interfering symbols, with Cauchy RS code of desired message symbols added as \"error.\" The syndrome of the RS sub-code uniquely identifies the \"error\" in the Cauchy RS code space together with the actual errors introduced by unresponsive or Byzantine servers. From the quantum perspective, the shared qudits are initially in the code space of the CSS code constructed from the RS sub-codes of two instances of CSA codes. Servers apply Pauli operators to their qudits to encode the answers generated according to the two instances of the CSA code based classical scheme. The Pauli operators' components that correspond to RS sub-codes of interfering symbols are not detectable since they commute with stabilizers, while the component corresponding to desired message symbols, together with the errors introduced by unresponsive and Byzantine servers, are identified through syndrome measurement. In a nutshell, dimensions that carry desired computation results from the CSA code are encoded into the error space of the CSS code, while the undesired interference terms are aligned into the stabilized code space. A technicality worth noting is that a key enhancement is made to the CSA code, transforming it into a Modified CSA (MCSA) code -whereby the RS sub-code is turned into a GRS subcode whose dual code is still a GRS code, so that a CSS code can be easily constructed on GRS X , GRS Z that are sub-codes of two MCSA codes, where GRS ⊥ X ⊂ GRS Z . This 'MCSA-CSS' construction can be found in Protocol 3 in this work. While there is entanglement shared beforehand among the distributed servers (transmitters), it is important to note that the servers do not share any entanglement in advance with the user (the receiver). Intuitively, the shared entanglement among transmitters leads to a superdense coding gain in quantum PIR schemes allowing them to achieve in some cases twice the rate of their classical counterparts [9], [10], [26]. The quantum scheme proposed in this paper also achieves the factor of 2 superdense coding gain compared with the classical scheme proposed in [21]. It is also noteworthy that the quantum PIR setting addressed in this paper recovers as special cases various other settings considered in the literature, such as Q-B-X-TPIR in [33], Q-E-TPIR in [4], Q-MDS-X-TPIR in [26], Q-MDS-TPIR in [10], and Q-TPIR in [9]. Indeed, the protocol presented in this work achieves the state-of-the-art rates across all of the aforementioned special case scenarios."
    },
    {
      "heading": "B. Comparison to related works",
      "text": "The most closely related work is the conference version of this paper in [34], [35] where Q-E-X-TPIR problem is studied based on the N -sum box abstraction of [26]. The conference version allows neither MDS storage nor resilience to Byzantine servers. The conference version was then developed into a preliminary ArXiv version [36] of this paper where the approach taken for resilience to Byzantine servers that apply arbitrary Pauli errors is to guess the identities of Byzantine servers, treat them as erasures and decode, and check if there exists a set of decoding results that agree. However, the resilience to arbitrary Byzantine errors (rather than just Pauli errors) is not explicit under the N -sum box abstraction. The present version further develops our approach, making the Byzantine resilience explicit. Instead of the N -sum box abstraction, here we directly utilize the fact that the syndrome measurement of a CSS code can reduce arbitrary errors (that affect fewer qudits than its minimum distance) to Pauli errors (Lemma 1). Let us also note the parallel and independent work in [33] that studies Q-B-X-TPIR through the lens of the N -sum box abstraction, as further evidence of interest in this problem."
    },
    {
      "heading": "C. Organization",
      "text": "Section II introduces the notation together with some basic concepts of quantum systems, classical error correcting codes and quantum information. Section III formalizes the Q-E-B-MDS-X-TPIR problem. Section IV presents our main result as Theorem 1. Section V revisits the CSA code based classical E-B-MDS-X-TPIR scheme which is crucial to our construction. A modified CSA code (MCSA code) is presented in Section VI. The quantum protocol, namely MCSA-CSS, that builds upon the MCSA code and a CSS code, is presented in Section VII. Section VIII concludes the paper. A or B will be replaced by ':' if they contain all the rows or columns, respectively. If A is a vector, we simply write A(S) to denote the sub-vector of A whose indices are in S. For two column vectors"
    },
    {
      "heading": "A. Miscellaneous",
      "text": "e., a longer column vector with c 1 stacked above c 2 . colspan(A) denotes the vector subspace spanned by the columns of A. If A is a projection matrix, then Im(A) = colspan(A). ker(A) is the kernel space of A. A † is the conjugate transpose of A. For a length n vector I N is the N × N identity matrix. For any random variable that is written in upper case (say, Z), we use the corresponding lower case (z) to denote its realization. The state of a quantum system A defined on Hilbert space H A is represented by a density operator ρ A ∈ D A where D A is a set of all positive semi-definite operators with trace 1 acting on H A . A pure state can also be represented by a unit vector in H A . For a classical-quantum system XA, ρ A|X=x , or simply ρ A|x , denotes the density operator of A conditioned on the realization X = x. The label of the quantum system in the subscript may be omitted for compact notation if it is clear from the context. F q is a finite field with order q where q = p r is a prime power. The field trace tr Fq/Fp (•) : F q → F p is an F p -linear map from F q to F p , and ω ≜ e 2π √ -1/p . If a quantum system A has dimension |A| = q, with {|a⟩} a∈Fq being its computational basis, we call it a q-dimensional qudit."
    },
    {
      "heading": "B. Classical Error Correcting Codes",
      "text": "over F q is the column space of the generator matrix defined in (1) where over F q is the column space of the generator matrix defined in (2) where C. Quantum Information Definition 4. Quantum Channel: A quantum channel with input quantum system A and output quantum system B is a completely positive trace preserving mapping (CPTP) M :"
    },
    {
      "heading": "It can be represented by Kraus Operators",
      "text": "Definition 5. Pauli Operators for Qudits [37]: For any a, b ∈ F q , define the single qudit Pauli Operators X b , Z b ∈ C q×q so that For n ∈ N and any , let the n-qudit Pauli Operators be defined as Note that Definition 6. CSS Code [22], [23], [38]: A C = CSS(C X , C Z ) code encodes the state space of k q-dimensional qudits into a code space of n q-dimensional qudits where Definition 7. Stabilizer Measurement: For the CSS code in Definition 6, for any a ∈ C ⊤ X , b ∈ C ⊤ Z , according to [9, Appendix C, Fact 2)], the stabilizer X a Z b can be decomposed as are orthogonal projections such that Then the stabilizer measurement X a Z b is defined as the Projection-Valued Measurement (PVM, , the n-qudit pure state X x Z z |ψ⟩ is an eigenvector for all the stabilizers, and its syndrome measurement outcome is as follows, with H C X , H C Z being parity-check matrices for C X , C Z respectively. The following lemma will be useful. . Then for any quantum channel M S : D A S → D A S that is applied to qudits A S , the syndrome measurement reduces the quantum channel to some Pauli operators only affecting qudits A S , i.e., with the outcome being where supp(ϵ Though the lemma is conceptually somewhat standard, we provide a proof in Appendix A for the sake of completeness."
    },
    {
      "heading": "III. PROBLEM STATEMENT",
      "text": "Let us start with the classical setting defined in [21]. There are K messages W 1 , • • • , W K that are i.i.d. uniform over [M]. They are securely encoded with randomness Z ∈ Z to form the storage at N servers. For θ ∈ [K], the user wishes to privately retrieve the message W θ by querying the N servers. Local randomness Z ′ ∈ Z ′ is available to the user to generate private queries. For any n ∈ [N ], the random variables regarding the storage, query and answer (in the classical setting) at server n, denoted as S n , Q [θ] n and A n with realizations being s n , q n , a n , are deterministic functions of the following 3 independent random variables, whose realizations will be denoted as w [K] , z, z ′ respectively. [Messages] : The classical problem is similar to the quantum problem in Fig. 1, but there are no entangled quantum systems shared among servers and the answers from servers are classical symbols. Byzantine servers will return arbitrary classical symbols. Next we specify the storage, queries, servers' answers, and the user's decoding for both classical and quantum settings."
    },
    {
      "heading": "A. Classical Setting",
      "text": "MDS and X-Secure Storage: The storage at server n, n ∈ [N ] is denoted as [X -Security] i.e., any X + K c servers must be able to recover all the K-messages, the storage size at each server is 1/K c of the total size of the K messages, and any X or fewer servers can learn nothing about the messages. The encoding is done by, e.g., sources of the messages. Remark 1. The storage forms a ramp secret sharing [40] of the K-message database. We call it MDS and secure storage for comparison with Quantum MDS-PIR [10], as when X = 0, the above entropic constraints hold for an [N, K c ] MDS code where K c message symbols are encoded into N codeword symbols such that any K c codeword symbols recover the message and each codeword symbol is 1/K c of the message size (since there are K c message symbols). When K c = 1, there is no MDS storage constraint. Queries: A user wishes to retrieve the θ th , θ ∈ [K], message W θ from the servers by sending the T -private queries N ∈ Q to the N servers such that any T or fewer servers learn nothing about θ. Mathematically, using the encoding function Enc user : where Z ′ ∈ Z ′ is the user's local randomness. Meanwhile, the T -privacy constraint must be satisfied such that That is to say, for any θ ∈ [K], the joint distribution of the storage and queries at T or fewer servers are identical. Answers: There is a set E ⊂ [N ] of unresponsive servers and another set B ⊂ [N ] of Byzantine servers. B, E are not necessarily disjoint. The user does not know E, B a priori, except that ) generates the answer A n ∈ [d] using the encoding function according to its storage and received query, i.e., However, any unresponsive or Byzantine server n ∈ E ∪B generates an arbitrary answer Decoding: Upon receiving the answers A [N ]\\E , the user decodes the desired message using a function that depends on E (since unresponsive servers can be identified by the user), Thus, an E-B-MDS-X-TPIR scheme, is defined as The rate of a classical E-B-MDS-X-TPIR scheme is defined as the number of desired message bits recovered per answer bit that is downloaded from the servers, i.e., A rate R C is said to be achievable if and only if there exists a scheme Ψ C with this rate such that"
    },
    {
      "heading": "B. Quantum Setting",
      "text": "Shared Entanglement: In quantum setting, a composite quantum system Enc [sn,qn]  servn : Unresponsive and Byzantine servers apply an arbitrary CPTP map, to their quantum subsystems. Note that Byzantine servers do not change their quantum systems' dimension, as otherwise the user can tell which servers are Byzantine and treat them as erasures instead. Decoding: Upon receiving the quantum system } that depends on θ and the realization of its local randomness Z ′ = z ′ , with outcome random variable Ŵ as the decoding result. Thus, an E-B-MDS-X-TPIR scheme, is defined as The rate of a Quantum E-B-MDS-X-TPIR scheme is defined as the number of desired message bits recovered per qubit that is downloaded from the servers, i.e., A rate R Q is said to be achievable if there exists a scheme Ψ Q with this rate such that for A (quantum) E-B-MDS-X-TPIR problem is parameterized by (E, B, K c , X, T, N, K) where N, K are number of servers and messages respectively. We define the following constants for any E,B,K c ,X,T ,N ,K that will be used throughout this paper, where in the last line of (28), Remark 3. Since T -privacy is for the index θ, and X-security is for the shares of messages, both of which are classical even in the quantum setting, quantum analysis is not required while proving the privacy and security of the quantum protocol. Quantum considerations (e.g., CSS code formalism in Lemma 1), are essential only in the proof of correctness of the decoding process."
    },
    {
      "heading": "IV. MAIN RESULTS",
      "text": "The main result of this paper is a Q-E-B-MDS-X-TPIR scheme/protocol, namely MCSA-CSS. This protocol interprets the classical CSA code based E-B-MDS-X-TPIR scheme of [21] in such a way that desired message symbols appear as \"errors\" added to a code, combines the classical scheme with a CSS code, and decodes the desired message symbols, erasures and Byzantine errors simultaneously through the syndrome decoding of the CSS code. The scheme achieves a higher rate compared with its classical counterpart. As noted, our Q-E-B-MDS-X-TPIR protocol yields the state-of-art achievable rates under the various special cases corresponding to recently studied quantum PIR settings, e.g., Q-B-X-TPIR [33], Q-E-TPIR [4], Q-MDS-X-TPIR [26], Q-MDS-TPIR [10], and Q-TPIR [9], without server secrecy constraints. We have the following theorem 5 , where setting E = 0 or B = 0 corresponds to the case of no resilience to erasures or Byzantine servers, respectively, while setting K c = 1 or X = 0 corresponds to the case of no MDS or X-secure storage constraints, respectively. Theorem 1. For quantum K c MDS X-secure T -private information retrieval with N servers out of which at most E servers are unresponsive and B servers are Byzantine, the rate is achievable. Proof. The achievability of the third regime is trivial since a q-dimensional qudit can always be used to transmit a classical q-ary symbol and the classical scheme in [21] can be directly applied. The achievability of the first regime version of [33]. First of all, N -E-2B-Kc-X-T +1 N is always achievable by the classical scheme. For the achievability of N -2E-4B N , intuitively, when N/2 > (K c + X + T -1), one can always use the scheme that has more demanding privacy constraints, i.e., the scheme with T -privacy such that K c + X + T -1 = N/2 and T ≥ T . The Q-MDS-X-T PIR falls into the first regime and the rate can be calculated accordingly. Note that such a choice of T needs N to be even so that N/2 is an integer. The odd case will be resolved by Remark 8. Remark 4. In the first regime, we note the rate of the quantum scheme is twice of the classical scheme, which matches the maximal superdense coding gain observed thus far in other quantum settings of PIR [9], [10], [26] (compared with [6], [7] and [21] without unresponsive and Byzantine servers), secret sharing [4] (compared with [1])."
    },
    {
      "heading": "V. CLASSICAL E-B-MDS-X-TPIR: CSA CODE",
      "text": "The classical version of this problem has been studied in [21], and the CSA code based classical scheme there is an essential building block of its quantum version. Let us briefly summarize it here, starting with an example. A. Example 1: . Each message has q denote the row vectors that contain the 4 symbols of the K messages, respectively, i.e., where e k K is the k th column vector of I K . Let the storage randomness Z = {Z 1,1 , Z 2,1 } be uniform over F 1×K q × F 1×K q and user random- l∈ [2],κ∈ [2],t=1 be uniform over F K×1 q 4 ."
    },
    {
      "heading": "Storage:",
      "text": "The storage at server n, n ∈ [6], conditioned on the realization of messages and storage randomness, is S n = s n where Here for ( ẇl,1 , ẇl,2 , z l,1 ), and the storage cost at each server is 1/K c = 1/2 of the K messages (s n (1), s n (2) ∈ F 1×K q while each of K messages contains 4 symbols from F q . At the same time we have a secret sharing of 1 (αn-f 1 ) 2 ẇl,1 + 1 αn-f 1 ẇl,2 with threshold 1, thus the MDS and X = 1 security constraint is satisfied. Queries: The query generation contains K c = 2 iterations. The query sent from the user to server n, n ∈ [6], conditioned on the realization of the user's local randomness, is Q with the superscript indicating the iteration number, and Here, e K,θ is the θ th column of I K , used for choosing the θ th entry of ẇ, and z l,t . It is again not difficult to verify that the queries form secret sharing of e θ K with threshold 1. Thus, the query is 1-private. Answer: The answer generation takes K c = 2 iterations. Conditioned on the realization of messages, storage and user randomness, the answer sent from server n is where in iteration κ ∈ [2], the answer a (κ) n is just a symbol from F q . Specifically, in the first iteration, a (1)  n = s n q (1) n = s n (1)q (1)  n (1) + s n (2)q (1) where the coefficients for rational terms are desired message symbols and the coefficients for α 0 n , α 1 n , α 2 n are interfering symbols whose specific forms are not important. The collection of the answers from the 6 servers can be represented as, Due to the fact that any 5 rows of the matrix in (37) form an invertible sub-matrix according to [21], the answers form a [6,5] MDS code such that one erasure can be corrected and 2 desired message symbols w θ (:, 1) = [ ẇ1,1 e θ K ẇ2,1 e θ K ] ⊤ (together with the interfering symbols) can be decoded. In the second iteration, the answer from each server is still a symbol in F q , where The details of derivation can be found in [21] and are omitted here. Note that the first two terms in (38) are already known from the first iteration of decoding. The 6 answers together can now be written as, After subtracting σ (1) , w θ (:, 2) = [ ẇ1,2 e θ K ẇ2,2 e θ K ] ⊤ can be decoded similarly. The 2×2 desired message symbols are retrieved by downloading 6 × 2 answer symbols from the servers. The rate achieved is 1/3."
    },
    {
      "heading": "B. CSA Code for E-B-MDS-X-TPIR",
      "text": "Recall the constants defined in (28). Each message has L × K c symbols from F q , i.e., for any [Kc] . Let us define the length-K vector that contains the (l, κ) th symbol of all the K messages as Then for any k ∈ [K], message w k can be represented as The sources of randomness included in this scheme, uniform over their respective alphabet, are as follows, ,t∈[T ] be the realizations. The CSA scheme in [21] is summarized in the following protocol. The specific forms of storage, queries and answers generation functions can be found in Appendix B. 4) Corrupted Answers: In each iteration κ ∈ [K c ], the user receives â(κ) (answers from unresponsive servers can be replaced by 0). where supp ϵ (â (κ)σ (κ-1) ). In the 1 st iteration, σ (0) = 0 and the answers from N servers can be regarded as a codeword from C = CSA q,(α,f ) being the generator matrix, added with errors introduced by unresponsive and Byzantine servers as shown in (44). The generator matrix is defined in (43), and the vector * contains V = K c + X + T -1 symbols that are regarded as interference that arises due to MDS, security and privacy constraints. The specific forms of the interference terms are not important. According to the following proposition that states the CSA code is an the |E| ≤ E erasures and |B| ≤ B Byzantine errors can be corrected and the user is able to recover desired message symbols w θ (:, 1) by the decoding scheme of CSA code defined in (43) form an invertible matrix, i.e., CSA q,(α,f ) [21]. In the κ th iteration, κ ∈ [K c ], the received N answers, after subtracting σ (κ-1) which solely depends on the decoding result in the previous iterations, again form a codeword from C = CSA q,(α,f ) N,L,V code, added with errors. Again, according to Proposition 2, the user is able to decode w θ (:, κ) in the κ th iteration. The communication rate of the CSA code based scheme is over F q is the column space of the generator matrix defined in (46) where The specific form of the generator matrix can be found in (48). For this MCSA code, we have the following proposition. form an invertible matrix since Diag(u(R)) is invertible as Let us specify the form of the answers from an MCSA based classical E-B-MDS-X-TPIR scheme next. Note that for all κ ∈ [K c ], the answers at iteration κ are specified in (48). Remark 5. For any κ ∈ [K c ], the answers at iteration κ specified in (48) are equal to the answers in (43) left-multiplied by the matrix Diag(u). Thus, any CSA based scheme can be easily converted to an MCSA based scheme by letting server n multiply its answer generated from CSA based scheme by u n . The generation of storage and queries remains unchanged. Therefore, X-security and T -privacy follow from the CSA code based scheme. Meanwhile, the decodability of the desired message is guaranteed by Proposition 3, just as the decodability of CSA code based scheme is guaranteed by Proposition 2. Remark 6. Compared with the generator matrix of the code defined in [26, Eq. ( 15)] which is a square matrix, note that the generator matrix in this paper is not square to be able to correct errors introduced by unresponsive and Byzantine servers, and it is an enhanced version of the generator matrix of CSA code in [21, Eq. ( 70)]. The MCSA code based scheme is specified in Protocol 2. The definition of { ẇl,κ z, z ′ are the same as those in ( 40) and (42). u = (u 1 , • • • , u N ) ∈ F N q are N non-zero elementsfoot_1 in F q . Again, the storage, queries and answers generation functions are specified in Appendix B. The N answers at iteration κ ∈ [K c ] are as followsfoot_2 = G GRS q,(α,u) 4) Corrupted Answers: In each iteration κ ∈ [K c ], the user receives corrupted answers â(κ) (answers from unresponsive servers can be replaced by 0). where supp ϵ (κ) E∪B = E ∪ B denotes the errors introduced by unresponsive and Byzantine servers. 5) Decoding: For any κ ∈ [K c ], user computes the syndrome and decodes the desired message through E∪B , where is the mapping from the syndrome (after subtracting σ (κ-1) related terms) to the L desired message symbols and the error vector introduced by unresponsive and Byzantine server, when the unresponsive servers are those with indices in the set E. Remark 7. Note that besides the difference while generating the answers in step 3, compared with Protocol 1, the interpretation of the answers and user's way of decoding are all different. We will explain these in the following subsection."
    },
    {
      "heading": "B. MCSA Classical E-B-MDS-X-TPIR-Another Interpretation",
      "text": "Though the MDS property of the MCSA code guarantees the decodability of message symbols when there are unresponsive and Byzantine servers, in order to make it compatible with the Q-E-B-MDS-X-TPIR scheme based on syndrome measurement of a CSS code, we interpret answers from MCSA code based classical E-B-MDS-X-TPIR scheme as the GRS code of the interfering symbols * , with CRS encoded desired message symbols added as \"errors.\" With this interpretation, the decoding of the classical scheme is based on the syndrome decoding of a GRS code. Specifically, the corrupted answer (after subtracting σ which is known) in (50) can be interpreted as GRS q,(α,u) N,V encoded interfering symbols, corrupted by the \"errors\" caused by CRS encoded message symbols, erasures and Byzantine errors. is the parity check matrix of GRS q,(α,u) N,V , and (51) follows from H ⊤ G = 0. Next let us prove Lemma 2 which guarantees the existence of the decoding function Φ GRS E in (52). Essentially, Lemma 2 says that all the correctable \"errors\" (including \"errors\" introduced by desired message symbols) have different syndromes. The \"errors\" introduced by desired messages are similar to erasures in the sense that we know their error basis (columns of G CRS ). Thus, when L + E + 2B (28) = N -V = d -1 where L is the dimension of the message symbols and d = N -V + 1 is the minimum distance of the the GRS code, all the \"errors\", including those caused by the desired message symbols, can be decoded from the syndrome. This implies the existence of the decoding function . Each message has L × K c = 2 symbols from F q , i.e., for any q denote the row vectors that contain the 2 symbols of the K messages, respectively, i.e., where e k K is the k th column vector of I K . We skip the storage and queries. The (corrupted) answers from the servers have the following representation, where server 2 is Byzantine so that an error is added to its answer. Note that The error correcting capability of the [6, 2, 5] GRS code will be utilized to find the two desired message symbols and the server 2 introduced error ϵ, i.e., the syndrome H ⊤ GRS q,(α,u) 6,2 â(1) uniquely determines the w θ = w θ (:, 1) and ϵ (1) {2} ."
    },
    {
      "heading": "VII. MCSA-CSS PROTOCOL FOR Q-E-B-MDS-X-TPIR",
      "text": "In this section, we propose the MCSA-CSS protocol for the Q-E-B-MDS-X-TPIR problem, based on syndrome measurement of a CSS code, that is constructed from GRS sub-codes of two MCSA codes. Exploiting the fact that the dual code of a GRS code is still a GRS code, a CSS code with N physical qudits can be constructed from two GRS codes. The N physical qudits are then delivered to N servers. 8 Two MCSA codes based classical PIR schemes are executed, and servers apply Pauli operators to the CSS code according to the answers from the classical scheme. The components of Pauli operators corresponding to the GRS sub-codes of interfering symbols are not detectable, because they commute with the stabilizers. This is due to the fact that the CSS code is constructed from the same GRS codes. However, the components associated with the Cauchy RS code encoded message symbols (regarded as \"errors\"), along with errors introduced by unresponsive and Byzantine servers, are identified through syndrome measurements. 8 Let us clarify that the CSS code is not used to deliver logical qudits to servers. The N physical qudits are initially in a constant pure state and are shared as quantum resources for improving communication efficiency."
    },
    {
      "heading": "A. MCSA-CSS Protocol",
      "text": "The MCSA-CSS scheme is presented as Protocol 3. During one execution of the quantum scheme, two independent instances of classical schemes will be executed. Thus, each message has 2LK c symbols from F q , and the randomness also has twice the size as that in classical cases. Let w [K] be the realizations of stand for the X, Z parts of message k respectively, so that each part has the same size to a message in the classical case. Similar to (40), define the length-K vector that contains the (l, κ) th symbol of all the K messages' ⋆ part (⋆ ∈ {X, Z}) as Similarly, Z = {Z X , Z Z }, Z ′ = {Z ′X , Z ′Z }. Each Z ⋆ , Z ′⋆ , ⋆ ∈ {X, Z} is specified similarly according to (42) as follows Again, let z, z ′ be their realizations. Let us pick some constants u The protocol is specified as follows. Note that u, v are constants specified by the protocol. are delivered to N servers so that server N gets A (κ) n . We let . 2) Storage, Queries, Answers: Two independent instances (indexed by X and Z) of Protocol 2 will be executed to generate storage, queries and corresponding classical answers. Specifically, execute Protocol 2 with following parameters, so that the storage, queries, and classical answers can be determined by corresponding steps in Protocol 2, which are, again, generated according to the 3 functions specified in Appendix B. E-B-MDS-X-TPIR: For iteration κ ∈ [K c ], the following classical answers are generated according to (49) where n so that the N answer qudits are in the following state 9 . 3) Corrupted Answers: For iteration κ ∈ [K c ], the user replaces the unreceived qudits A (κ) E with |E| qudits that are in completely mixed state and labels them A E . The received qudits 9 For ease of analysis, we assume unresponsive or Byzantine servers firstly behave as reliable servers that apply correct Pauli operators to their qudits and then apply a CPTP map M. There is no loss of generality since any actual CPTP map M ′ applied by the unreliable servers can be viewed as a composition of 1) applying correct Pauli operators, 2) reverting the Pauli operators, 3) applying M ′ where the composition of the last 2 steps is M. are in the following state due to the quantum channels applied by unresponsive and Byzantine servers. 4) Decoding: For each iteration κ ∈ [K c ], the user performs syndrome measurement of . The state becomes The user obtains the syndrome and decodes the desired message symbols through Remark 8. We require V = K c + X + T -1 ≥ N/2, i.e., interfering symbols occupy at least half of the answer dimensions, so that the CSS code can be constructed from the GRS codes. Consider the second regime of Theorem 1, i.e., (N - one can find T 1 > T, T 2 ≥ T, T 1 = T 2 + 1 such that the total interfering dimensions (this idea is also used in the preliminary ArXiv version of this paper [36, Theorem 1] and in the subsequent 2 nd version of [33]) This means that while constructing the two instances of the classical scheme, we have T 1 privacy for the X instance, and T 2 privacy for the Z instance. By such choice of T 1 , T 2 , during each of Before analyzing the protocol, let us provide an intuitive explanation. The CSS code is constructed based on the GRS sub-codes of two instances of MCSA codes designed for the PIR problem. Since the GRS sub-code corresponds to interfering symbols, the Pauli operators associated with these interfering symbols commute with the stabilizers of the CSS code and, therefore, cannot be detected through syndrome measurement. In contrast, the Pauli operators associated with message symbols, along with any erasures or Byzantine errors, shift the N qudits into an error space that can be uniquely identified through syndrome measurement. In this interpretation, the message symbols act as sources of \"errors.\" However, since these"
    },
    {
      "heading": "B. Analysis of MCSA-CSS Protocol",
      "text": "Let us first prove its correctness. 1) Existence of the CSS Code: According to [20, (5.1.6) Theorem], with the choice of v in (59), we have GRS q,(α,u) N,V ⊥ = GRS q,(α,v) N,N -V ⊂ GRS q,(α,v) N,V when V ≥ N/2. Thus the"
    },
    {
      "heading": "CSS GRS",
      "text": "q,(α,u) N,V , GRS q,(α,v) N,V code exists. 2) Corrupted Answers: Without loss of generality we assume all the unresponsive and Byzantine servers first apply the correct Pauli Gates as other (reliable) servers, and then apply an arbitrary quantum channel afterwards, as an arbitrary quantum channel can be regarded as a composition of Pauli Gates with another quantum channel. Recall that we replaced the unreceived qudits with qudits in completely mixed state. This can be viewed as if the unresponsive servers' answer qudits were received but went through a quantum depolarizing channel (Qudit Twirl, [ 41, Exercise 4.7.6]). Thus the state derived in (64) is correct. P a,b i X x+µ Z z+τ |ψ⟩ ⟨ψ| X x+µ ′ Z z+τ ′ † P a,b i † =            P a,b i X x+µ Z z+τ |ψ⟩ 0 1×q n = 0 X x+µ Z z+τ |ψ⟩ ∈ Im(P a,b i ), X x+µ ′ Z z+τ ′ |ψ⟩ / ∈ Im(P a,b i ) 0 q n ×1 ⟨ψ| X x+µ ′ Z z+τ ′ † P a,b i † = 0 X x+µ Z z+τ |ψ⟩ / ∈ Im(P a,b i ), X x+µ ′ Z z+τ ′ |ψ⟩ ∈ Im(P a,b i ) X x+µ Z z+τ |ψ⟩ ⟨ψ| X x+µ ′ Z z+τ ′ † X x+µ Z z+τ |ψ⟩ , X x+µ ′ Z z+τ ′ |ψ⟩ ∈ Im(P a,b i ) (75) Thus, after the syndrome measurement, X x+µ Z z+τ |ψ⟩ ⟨ψ| X x+µ ′ Z z+τ ′ † exists if and only if for every stabilizer, X x+µ Z z+τ |ψ⟩ and X x+µ ′ Z z+τ ′ |ψ⟩ lie in the same eigen space, or equivalently, they correspond to the same syndrome (similar to Proposition 1) where last the step of (76) follows from the fact that wt(µµ ′ ) ≤ min(d X , d Z ) -1 ≤ d Z -1, i.e., µµ ′ / ∈ C Z = ker(H C Z ) if µµ ′ ̸ = 0 (the last step of (77) follows similarly). After syndrome measurement, the n qudits are in the state, Suppose the outcome of syndrome measurement is Then ∀µ, τ ∈ F, the term X x+µ Z z+τ |ψ⟩ ⟨ψ| (X x+µ Z z+τ ) † does not disappear if and only if, C. Proof of Lemma 2 We only need to prove As a consequence, we only need to prove the following (N -V )×(N -V ) matrix is invertible. G CRS q,(α,f ,u) N,L I N (:, S) For invertibility of (88), we first prove the following lemma. Lemma 3. The following N × N matrix is invertible. G GRS q,(α,u) N,V G CRS q,(α,f ,u) N,L I N (:, S) Proof. On one hand, ) = colspan(G GRS q,(α,u) N,V ). A contradiction occurs since colspan([G CRS q,(α,f ,u) N,L I N (:, S)]) ∩colspan(G GRS q,(α,u) N,V ) = colspan(0) ̸ ∋ v ′ according to Lemma 3. Therefore, (88) is invertible."
    }
  ]
}