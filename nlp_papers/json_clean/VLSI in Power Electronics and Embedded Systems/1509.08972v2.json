{
  "paperid": "1509.08972v2",
  "title": "VLSI Implementation of Deep Neural Network Using Integral Stochastic Computing",
  "authors": [
    "Ardakani",
    "Leduc-Primeau",
    "Onizawa",
    "Hanyu",
    "Gross",
    "Park",
    "Bong",
    "Shin",
    "Lee",
    "Choi",
    "Yoo",
    "Dahl",
    "Yu",
    "Deng",
    "Acero",
    "Hinton",
    "Osindero",
    "Teh",
    "Hinton",
    "Salakhutdinov",
    "Arbib",
    "Luo",
    "Tian",
    "Wang",
    "Tang",
    "Zeng",
    "Ouyang",
    "Wang",
    "Kim",
    "Asaad",
    "Linsker",
    "Alaghi",
    "Li",
    "Hayes",
    "Tehrani",
    "Mannor",
    "Gross",
    "Ji",
    "Ran",
    "Ma",
    "Lilja",
    "Liu",
    "Parhi",
    "Yuan",
    "Parhi",
    "Qian",
    "Li",
    "Riedel",
    "Bazargan",
    "Lilja",
    "Li",
    "Lilja",
    "Li",
    "Lilja",
    "Qian",
    "Bazargan",
    "Riedel",
    "Alaghi",
    "Li",
    "Hayes",
    "Rosselló",
    "Canals",
    "Morro",
    "Dickson",
    "Mcleod",
    "Card",
    "Gaines",
    "Ting",
    "Hayes",
    "Knag",
    "Lu",
    "Zhang",
    "Li",
    "Qian",
    "Lilja",
    "Brown",
    "Card",
    "Cai",
    "Wang",
    "Song",
    "Qian",
    "Lecun",
    "Cortes",
    "Li",
    "Najafi",
    "Lilja",
    "Tanaka",
    "Okutomi",
    "Cox",
    "Blanz",
    "Zhao",
    "Shawe-Taylor",
    "Skubiszewski",
    "Kim",
    "Mcafee",
    "Mcmahon",
    "Olukotun",
    "Ly",
    "Chow",
    "Ly",
    "Chow",
    "Li",
    "Lilja",
    "Qian",
    "Bazargan",
    "Riedel",
    "Leduc-Primeau",
    "Kschischang",
    "Gross"
  ],
  "year": 2016,
  "abstract": "The hardware implementation of deep neural networks (DNNs) has recently received tremendous attention: many applications in fact require high-speed operations that suit a hardware implementation. However, numerous elements and complex interconnections are usually required, leading to a large area occupation and copious power consumption. Stochastic computing has shown promising results for low-power area-efficient hardware implementations, even though existing stochastic algorithms require long streams that cause long latencies. In this paper, we propose an integer form of stochastic computation and introduce some elementary circuits. We then propose an efficient implementation of a DNN based on integral stochastic computing. The proposed architecture has been implemented on a Virtex7 FPGA, resulting in 45% and 62% average reductions in area and latency compared to the best reported architecture in literature. We also synthesize the circuits in a 65 nm CMOS technology and we show that the proposed integral stochastic architecture results in up to 21% reduction in energy consumption compared to the binary radix implementation at the same misclassification rate. Due to fault-tolerant nature of stochastic architectures, we also consider a quasi-synchronous implementation which yields 33% reduction in energy consumption w.r.t. the binary radix implementation without any compromise on performance.",
  "sections": [
    {
      "heading": "I. INTRODUCTION",
      "text": "Recently, the implementation of biologically-inspired artificial neural networks such as the Restricted Boltzmann Machine (RBM) has aroused great interest due to their high performance in approximating complicated functions. A variety of applications can benefit from them, in particular machine learning algorithms. They can be split in two phases, which are referred to as learning and inference phases [2]. The learning engine finds a proper configuration to map learning input data into their desired outputs, while the inference engine uses the extracted configuration to compute outputs for new data. Deep neural networks, especially Deep Belief Networks (DBN), have shown state-of-the-art results on various computer vision and recognition tasks [3]- [8]. DBN can be formed by stacking RBMs on top of each other to construct a deep network, as shown in Fig. 1  [4]. RBMs used in DBN are pretrained using Gradient-based Contrastive Divergence (GCD) algorithms, followed by gradient descent and backpropagation algorithms for classification and fine-tuning the results [4], [5]. A preliminary version of this paper was published in [1]. In the past few years, general purpose processors have been mainly used for software realization of both training and inference engines of DBN. However, large power consumption and high resource utilization have pushed researchers to explore ASIC and FPGA implementations of neural networks. Rapid expansion of devices and sensors connected to the internet of things (IoT) allows to perform the training procedure once on cloud servers equipped with Graphics Processing Unit (GPU), and extract weights for inference engine usage through the IoT platforms. The inference engine can then be implemented using ASIC or FPGA platforms. DBNs are constructed of multiple layers of RBMs and a classification layer at the end. The main computation kernel consists of hundreds of vector-matrix multiplications followed by non-linear functions in each layer. Since multiplications are costly to implement in hardware, existing parallel or semiparallel VLSI implementations of such a network suffer from high silicon area and power consumption [9]. The nonlinearity function is also implemented using Look-Up Tables (LUTs), requiring large memories. Moreover, hardware implementation of this network results in large silicon area: this is caused by the connections between layers, that lead to severe routing congestion. Therefore, an efficient VLSI implementation of DBN is still an open problem. Recently, Stochastic Computing (SC) has shown promising results for ultra low-cost and fault-tolerant hardware implementation of various systems [10]- [19]. Using SC, many computational units have simple implementation. For instance, using unipolar SC, the multiplication and addition are implemented using an AND gate and a multiplexer, respectively [20], [21]. However, the multiplexer-based adder introduces a scaling factor that can cause a precision loss [22], resulting in the failure of SC for deep neural networks, which require many additions. An OR gate can provide a good approximation to addition if its input values are small [21]. However, using OR gates to perform addition in DBNs results in a huge misclassification error compared to its fixed-point hardware implementation. Therefore, an efficient stochastic implementation that maintains the performance of DBN is still missing. In this paper, an integral stochastic computation is introduced to solve the precision loss issue of conventional scaled-adder, while also reducing the latency compared to conventional binary stochastic computation. It is also worth mentioning that the proposed technique results in lower latency compared to conventional binary stochastic computation. A novel Finite State Machine (FSM)-based tanh function is then proposed as the nonlinearity function used in DBN. Finally, an efficient stochastic implementation of DBN based on the aforementioned techniques with an acceptable misclassification error is proposed, resulting in 45% smaller area on average compared to the state-of-the-art stochastic architecture. A nanoscale memory-resistor (memristor) device is a nonvolatile digital memory, which consumes substantially less energy compared to CMOS and can be scaled to sizes below 10 nm [23]. A challenging problem with memristor devices is the presence of significant random variations. A promising approach for dealing with the non-determinism of memristors is to design SC systems that are fault-tolerant [23]. In this paper, we show that the proposed architectures can tolerate a fault rate of up to 16% when timing violations are allowed to occur, making them suitable for memristor devices. The manuscript can be divided in two major parts: the proposed algorithms and their hardware implementation results. In the first part, we analyze elementary computational units. Also, some simulation results and examples are provided to shed light on the proposed algorithm in comparison with the existing methods. In the second part, design aspects of a deep neural network based on the proposed method are studied and some implementation results under different conditions are provided. The rest of this paper is organized as follows. Section II provides a review of SC and its computational elements. Section III introduces the proposed integral stochastic computation and operations in this domain. Section IV describes the integral stochastic implementation of DBN. Implementation results of the proposed architecture is provided in Section V. In this section, the performance of the stochastic implementation is studied when the circuit is affected by timing violations. Note that accepting occasional timing violations allows to reduce the supply voltage, which can improve the energy efficiency of the system. In Section VI, we conclude the paper and discuss future research."
    },
    {
      "heading": "AND",
      "text": "A: 1,0,1,0,0,0,0,0 (2/8) B: 1,0,0,1,0,1,0,1 (4/8) Y: 1,0,0,0,0,0,0,0 (1/8) (a) A: 1,0,1,0,0,0,0,0 (-6/8) B: 1,0,0,1,0,1,0,1 (0) Y: 1,1,0,0,1,0,1,0 (0) XNOR"
    },
    {
      "heading": "II. STOCHASTIC COMPUTING AND ITS COMPUTATIONAL ELEMENTS",
      "text": "In stochastic computation, numbers are represented as sequences of random bits. The information content of the sequence does not depend on the particular value of each bit, but rather on their statistics. Let us denote by X ∈ {0, 1} a bit in the random sequence. To represent a real number x ∈ [0, 1], we simply generate the sequence such that: where E[X] denotes the expected value of the random variable X. This is known as the unipolar format. The bipolar format is another commonly used format where x ∈ [-1, 1] is represented by setting: Note that any real number can be represented in one of these two formats by scaling it down to fit within the appropriate interval. In this paper, we use upper case letters to represent elements of a stochastic stream, while lower case letters represent the real value associated with that stream. It is also worth mentioning that a stochastic stream of a real value x is usually generated by a linear feedback shift register (LFSR) and a comparator. This unit is hereafter referred to as binary to stochastic convertor (B2S) [24]."
    },
    {
      "heading": "A. Multiplication In SC",
      "text": "Multiplication of two stochastic streams is performed using AND and XNOR gates in unipolar and bipolar encoding formats, respectively, as illustrated in Fig. 2(a) and 2(b). In unipolar format, the multiplication of two input stochastic streams of A and B is computed as: where \"• • • \" denotes bit-wise AND and if the input sequences are independent, we have: Multiplications in bipolar format can be performed as: A: 1,0,1,0, B: 1,0,0,0,0,0,1,0 (2/8) Y: 1,0,1,0,1,0,1,0 (4/8) S: 1,0,0,1,0,1,0,1 (4/8) 0 1 (a) A: 1,0,1,0,0,0,0,0 (2/8) B: 0,1,0,0,0,1,0,1 (3/8) Y: 1,1,1,0,0,1,0,1 (5/8) OR If the input streams are independent, By simplifying the above equation, we have:"
    },
    {
      "heading": "B. Addition In SC",
      "text": "Additions in SC are usually performed by using either scaled adders or OR gates [20], [21]. The scaled adder uses a multiplexer (MUX) to perform addition. The output of a MUX Y is given by As a result, the expected value of Y would be (E[A]+E[B])/2 when the select signal S is a stochastic stream with probability of 0.5, as illustrated in Fig. 3(a). This 2-input scaled adder ensures that its output is in the legitimate range of each encoding format by scaling it down by factor of 2. Therefore, L-input addition can be performed by using a tree of multiple 2-input MUXs. In general, the result of an L-input scaled adder is scaled down L times, which can decrease the precision of the stream. To achieve the desired accuracy, longer bit-streams must be used, resulting in larger latency. OR gates can also be used as approximate adders as shown in Fig. 3(b). The output Y of an OR gate with inputs A, B can be expressed as OR gates function as adders only if E[AB] is close to 0. Therefore, the inputs should first be scaled down to ensure that the aforementioned conditions are met. This type of adder still requires long bit-streams to overcome a precision loss incurred by the scaling factor. To overcome this precision loss, which could potentially lead to inaccurate results, the Accumulative Parallel Counter (APC) is proposed in [22]. The APC takes N parallel bits as inputs and adds them to a counter in each clock cycle of the system. Therefore, this adder results in lower latency due to its small variance of the sum. It is also worth mentioning that this adder converts the stochastic stream to binary form [22]. Therefore, this adder is restricted to cases where additions are performed to obtain the final result, or requiring an intermediate result in binary format. Stochastic Stream X 1 : 1,0,1,0,1,1,1,1 (0.75) Integer stochastic stream S: 2,1,2,0,"
    },
    {
      "heading": "C. FSM-Based Functions In SC",
      "text": "Hyperbolic tangent and exponentiation functions are computations required by many applications. These functions are implemented in the stochastic domain by using a FSM [25]. Fig. 4(a) and 4(b) show the state transition diagram of the FSM implementing tanh and exponentiation functions. The FSM is constructed such that where n denotes the number of states in the FSM, G the linear gain of the exponentiation function and Y the stochastic output sequence. Let us define as Stanh and Sexp the approximated functions of tanh and exp in stochastic domain. It is worth mentioning that both input and output of the Stanh function are in bipolar format, while the input and output of the Sexp function are in bipolar and unipolar formats respectively."
    },
    {
      "heading": "A. Generation of Integer Stochastic Stream",
      "text": "An integer stochastic stream is a sequence of integer numbers which are represented by either 2's complement or sign and magnitude. The average value of this stream is a real number s ∈ [0, m] for unipolar format and s ∈ [-m, m] for bipolar format, where m ∈ {1, 2, . . . }. In other words, the real value s is the summation of two or more binary stochastic stream probabilities. For instance, 1.5 can be expressed as 0.75 + 0.75. Each of these probabilities can be represented by a conventional binary stochastic stream as shown in Fig. 5(a). Therefore, the integer stochastic representation of 1.5 can be readily achieved as a summation of generated binary stochastic streams as illustrated in Fig. 5(b). In general, the integer stochastic stream S representing the real value s is a sequence with elements S i , i = {1, 2, . . . , N }: where X j i denotes each element of a binary stochastic sequence representing a real value x j . The expected value of the integer stochastic stream is then given by We can also generate integer stochastic streams in the bipolar format. In that case, the elements S i of the stream are given by: and the value represented by the stream is Any real number can be approximated by using an integer stochastic stream without prior scaling, as opposed to a conventional stochastic stream which is restricted only to the [-1, 1] interval. In integral SC, computation on two streams with different effective length is also possible while conventional SC fails to provide this property. For instance, representation of 0.875 and 0.5625 require effective bit-stream lengths of 8 and 16, respectively, using conventional SC. Therefore, effective bit-stream lengths of 16 is used to generate the conventional stochastic bit-stream of these two numbers for operations. However, the second number which requires higher effective length, i.e., 0.5625 in this example, can be generated by using the proposed integral SC with m = 2 as shown in Fig. 6(a). In this case, the bit-stream length of 8 is used for both numbers and operations can be performed by using lower lengths w.r.t. conventional SC. This technique potentially reduces the latency brought by stochastic computations, making integral SC suitable for throughput-intensive applications. It is worth mentioning that the integral SC is different from the conventional parallelized SC [26]. For the sake of clarity, the aforementioned example is illustrated in Fig. 6(b) by using the conventional parallelized SC by factor of two. This is due to the fact that if several copies of a binary SC system are instantiated, the inputs still need to have the same effective length. In summary, a real number s ∈ [0, m] is first divided into the summation of multiple numbers which are in [0, 1] interval. Then, the integer stochastic stream of this number is generated by using column-wise addition (see equations ( 13)-( 14)). The bipolar format of the integer stochastic stream is generated in a similar way. Note that the binary to integer stochastic convertor is hereafter referred to as B2IS and it is composed of m B2S convertors followed by and adder as shown in Fig. 5."
    },
    {
      "heading": "B. Implicit Scaling of Integer Stochastic Stream",
      "text": "The integer stochastic representation of a real number s ∈ [0, 1] can also be generated by using an implicit scaling factor. In this method, the expected value of the individual binary streams is chosen as x j = s, and the value s represented by the integer stream is given by This method avoids the need to divide s by m to obtain x j , and can be easily taken into account in subsequent computations. For instance, a real number 9/16 can be represented using an integer stream length of 8 with m = 2. We can set x j = 9/16 (with an implicit scaling factor of 1/2) and generate two binary sequences of length 8. These sequences are then added together to form the integer sequence S. We obtain"
    },
    {
      "heading": "C. Multiplication In Integral SC",
      "text": "The main advantage of SC compared to its binary radix format is the low complexity implementation of mathematical operations. It is shown that multiplication can be implemented by using AND or XNOR gates depending on the coding format. However, integer stochastic multipliers make use of binary radix multipliers (see Fig. 7(a)). The multiplication of two real numbers s 1 ∈ [0, m] and s 2 ∈ [0, m ] with integer stochastic streams S 1 and S 2 in unipolar format is performed as follows: if S 1 i and S 2 i are independent. The above equation holds true for integer stochastic multiplication in bipolar format as well. The implementation cost of this multiplier strongly depends on m and m . Considering one of these two values to be equal to \"1\", the multiplication can be implemented using bit-wise AND gate or a MUX as depicted in Fig. 7(b). The range of y is [0, m × m ] in the unipolar case, and [-m × m , m × m ] in the bipolar case."
    },
    {
      "heading": "D. Addition In Integral SC",
      "text": "Conventional SC suffers from precision loss incurred by using scaled adder, making SC inappropriate for applications which require many additions. On the other hand, integral SC uses binary radix adders to perform additions in this domain, preserving all information. Using (14), addition in unipolar format is performed as follows: Pseudo code of the proposed algorithm for integer stochastic FSM-based functions unipolar and bipolar formats respectively. This adder provides some advantages similar to APC. First of all, due to the fact that it retains all information provided as inputs, it reduces the variance of the sum. Secondly, it potentially reduces the bit-stream length required for computations compared to conventional SC [22]. Moreover, the output of this adder is still an integer stochastic stream, which can be used by subsequent stochastic computational units, as opposed to APC."
    },
    {
      "heading": "E. FSM-Based Functions In Integral SC",
      "text": "The inputs of stochastic FSM-based tanh and exponentiation functions are restricted to real values in the [-1, 1] interval. Therefore, a desired tanh or exponentiation function can be achieved by scaling down the inputs and adjusting the term n in ( 11) and (12), which potentially increases bit-stream length and results in long latency. The transition between each state of FSM is performed according to the input value in bipolar format, which is either 1 or 0. This state transition can be formulated as shown in Algorithm 1 in conventional SC. According to the Algorithm 1, the input value in bipolar format is first converted to either 1 or -1 as an input of either 1 or 0, respectively. Then, the counter of FSM is added with the new encoded values which are similar to the values in an integral stochastic stream with m = 1. Therefore, the values of the conventional stochastic stream can be viewed as hard values of an integral stochastic stream. The FSM-based functions in integral SC can be achieved by extending the conventional FSM-based functions to support soft values in integral SC, which is explained below. The integer stochastic tanh and exponentiation functions are proposed by generalizing Alg. 1. In integral SC, each element of a stochastic stream is represented using 2's complement or sign-magnitude representations in {-m, . . . , m} for bipolar format. A state counter is increased or decreased according to the integer input value S i ∈ {-m, . . . m} where i ∈ 0 0.5 1 1.5 2 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 s Output Exp(-s) NSexp(512,1,S), m=2 NSexp(1024,2,S), m=4 NSexp(2048,4,S), m=8 (a) 0 0.5 1 1.5 2 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 s Output Exp(-2s) NSexp(1024,2,S), m = 2 NSexp(2048,4,S), m = 4 NSexp(4096,8,S), m = 8 Sexp(512,1,X) (b) Fig. 9. (a) Integer stochastic implementation of exp(-s) and (b) Integer stochastic implementation of exp(-2s) {1, 2, ..., N }. Therefore, the state counter is incremented or decremented by up to m in each clock cycle, as opposed to conventional FSM-based functions which are restricted to one-step transitions. The algorithm for integer FSM-based functions is proposed as shown in Algorithm 2. The output of the proposed integer FSM-based functions in integral SC domain and its encoding format are similar to the conventional FSM-based functions. For instance, the output of the integer tanh function is in bipolar format while the output of integer exponentiation function is in unipolar format. Moreover, the integer FSM-based functions require m times more states compared to its conventional counterpart. Therefore, the approximate transfer function of integer tanh and exponentiation functions, which are referred to as NStanh and NSexp, respectively, are: In order to show the validity of the proposed algorithm, Monte-Carlo simulation is used. Fig. 8 illustrates two examples of the proposed NStanh function compared to its corresponding Stanh and tanh functions for different values of m. Simulation results show that NStanh is more accurate than Stanh for m > 1 and that the accuracy improves as the value of m increases. Moreover, NStanh is able to approximate tanh for input values outside of the [-1, 1] range with negligible performance loss, while Stanh does not work. The proposed NStanh function can also approximate tanh functions with fractional scaling factor, e.g. tanh (3/2x) ≈ NStanh (3 × m, S), as long as the value m is even, to make sure that the number of states is even. The aforementioned statements also hold true for NSexp, unlike with Sexp, as shown in Fig. 9. The proposed FSM-based functions in integral TABLE I HARDWARE COMPLEXITY OF THE PROPOSED FSM-BASED FUNCTIONS @ 400 MHZ IN A 65 NM CMOS TECHNOLOGY m (Stream Length) 1 (1024) 2 (512) 4 (256) 8 (128) Area (µm 2 ) Power (µW) Area (µm 2 ) Power (µW) Area (µm 2 ) Power (µW) Area (µm 2 ) Power (µW) tanh(s) 24 3.5 74 9.8 117 18.3 150 24.9 tanh(2s) 63 9.4 107 17.2 141 22.6 182 31.2 exp(-s) --424 62.1 474 72.5 480 80 exp(-2s) 424 57.1 440 65.1 491 74.5 532 93.1 SC also result in better approximation as the value of n increases, similar to conventional stochastic FSM-based functions. The hardware complexity of the proposed FSM-based functions in a 65 nm CMOS technology is also summarized in Table I. The implementation results show that the proposed FSM-based functions consume roughly 7 times more power at most while having 8 times less latency, which results in a lower energy consumption, compared to the conventional FSM-based functions (i.e., FSM-based functions with m = 1). Note that the stream length of FSM-based functions denotes the latency."
    },
    {
      "heading": "A. A Review on the DBN Algorithm",
      "text": "DBNs are the hierarchical graphical models obtained by stacking RBMs on top of each other and training them in a greedy unsupervised manner [4], [5]. DBNs take lowlevel inputs and construct higher-level abstractions through the composition of layers. Both the number of layers and the number of inputs in each layer can be adjusted. Increasing the number of layers and their size tends to improve the performance of the network. In this paper, we exploit a DBN constructed using two layers of RBM, which are also called hidden layers, followed by a classification layer at the end for handwritten digit recognition.. As a benchmark, we use the Mixed National Institute of Standards and Technology (MNIST) data set [27]. This data set provides thousands of 28×28 pixel images for both training and testing procedures. Each pixel is represented by an integer number between 0 to 255, requiring 8 bits for digital representation. As mentioned in Section I, the training procedure can be performed on remote servers in the cloud. Therefore, the extracted weights are stored in a memory for the hardware inference engine to classify the input images in real-time. Fig. 10 shows the DBN used for handwritten digits classification in this paper. Inputs of DBN and outputs of a hidden layer are hereafter referred to as visible nodes and hidden nodes, respectively. Each hidden node is also called neuron. The hierarchical computations of each neuron are performed as follows: where M denotes the number of visible nodes, v j the value of visible nodes, W ij the extracted weights, b j the bias term, z j intermediate value, h j the output value of each hidden node and j an index to each hidden node. The nonlinearity function used in DBN , i.e., equation (23), is called a sigmoid function. The classification layer does not require a sigmoid function as it is only used for quantization. In other words, the maximum value of the output denotes the recognized label."
    },
    {
      "heading": "B. The Proposed Stochastic Architecture of a DBN",
      "text": "VLSI implementations of a DBN network in binary form are computationally expensive since they require many matrix multiplications. Moreover, there is no straightforward way to implement the sigmoid function in hardware. Therefore, this unit is normally implemented by LUTs, which requires additional memory in addition to the memory used for storing weights. Considering 10 bits for weights, 78400 10b×8bmultipliers are required to do the matrix multiplications of the first hidden layer for a parallel implementation of a network with configuration of 784-100-200-10, meaning 784 visible nodes, 100 first-layer hidden nodes, 200 second-layer hidden nodes and 10 output nodes. Note that the parallel implementation of such a networks results in huge silicon area in part due to its routing congestion caused by the layer interconnection. Stochastic implementation of DBN is a promising approach to perform the mentioned complex arithmetic operations using simple and low-cost elements. In order to find the output value of the first hidden node, 784 multiplications are required, which can be easily performed by using AND gates in unipolar format. Then, addition of multipliers output should be performed by using a scaled adder or an OR gate. Using a scaled adder to sum 784 numbers requires an extremely long bit-stream due to the fact that the output result of this adder is scaled down by 784 times, a very small number to be represented by short stream length. In [28], an OR gate is used as an adder to perform this computation while the inputs first are scaled down to make the term \"A • B\" close to 0 in (10), which potentially increases the required stream length for computations. An APC is also proposed in [22] to realize the matrix operations. Despite its good performance on additions, it is not a suitable approach for a stochastic DBN, since it converts the results to a binary form [22]. We have shown in Section III-A that the integer stochastic stream can be generated by adding conventional stochastic streams. Considering that the multiplications of the first layer of a DBN are performed in conventional stochastic domain, the nature of the algorithm is to add the multiplication results together. Exploiting a binary tree adder, the addition result remains in integer-stochastic form without any precision loss. The sigmoid function can also be implemented in the integer stochastic domain. It is well-known that the sigmoid function can be computed using the tanh function as follows: The tanh function can also be implemented by NStanh function (see (20)) in integer stochastic domain. The output of NStanh is in bipolar format in conventional stochastic domain. Therefore, considering its output in unipolar format according to ( 24) and ( 2), the output of NStanh is equivalent to the sigmoid function in stochastic domain. Fig. 11 shows the proposed integer stochastic architecture of a single neuron. The input signal stream is generated by using conventional stochastic domain: however, the weights TABLE II THE MISCLASSIFICATION ERROR OF THE PROPOSED ARCHITECTURES FOR DIFFERENT NETWORK SIZES AND STREAM LENGTHS Misclassification Error (%) [29] Proposed Code Type Floating Point Integeral SC m -1 2 4 Stream Length -1024 512 256 784-100-200-10 2.29 2.40 2.46 2.33 784-300-600-10 1.82 2.01 1.89 1.90 are represented by 2's complement format in integer stochastic domain with range of m, which requires log 2 (m) + 1 bits for representation. The multiplications are performed bit-wise by AND gates since pixels and weights are represented by binary stochastic streams and integral stochastic streams, respectively. A tree adder and an NStanh unit are used to perform the additions and nonlinearity function, respectively. The output of the integer stochastic sigmoid function is represented by a single wire in unipolar format. Therefore, the input and output formats are the same. Integer stochastic architecture of DBN is formed by stacking the proposed single neuron architecture. The input images require a minimum bit-stream length of 256, but since the weights lie in the [-4, 4] interval they require a minimum bit-stream length of 1024 in conventional stochastic domain. Therefore, the latency of the proposed integer-stochastic implementation of the DBN is equal to 1024 for m = 1. The input range of the NStanh function, i.e. the value of m in Fig. 11, is selected through simulation. The histogram of the adder outputs identifies this range by taking a window which covers 95% of data. For instance, Fig. 12 shows the histogram of integer values as inputs of NStanh function at the first layer of a 784-100-200-10 DBN. This diagram is generated based on the non-correlated stochastic inputs and the selected range for this network is 6, i.e., the value of m in Fig. 11. This range strongly depends on the correlations among the stochastic inputs. The range would be a bigger number as the correlation increases. For instance, summation of two correlated stochastic streams, {1, 1, 0, 0, 1, 0} and {1, 1, 0, 1, 0, 0}, representing real value of 0.5 results in integral stochastic stream of {2, 2, 0, 1, 1, 0} and input range TABLE III IMPLEMENTATION RESULTS OF THE PROPOSED ARCHITECTURE ON FPGA VIRTEX-7 Network Size Stream Length Misclassification Error Area (# of LUTs) Latency (µs) Throughput (Mbps) 784-100-200-10 256 2.33% 1,013,002 1.705 3822 Proposed 784-100-200-10 512 2.46% 682,352 3.412 1874 784-100-200-10 1024 2.40% 437,461 6.503 974 784-100-200-10 1024 5.72% 144,450 8.561 NA [28] 784-300-600-10 1024 2.92% 603,750 9.797 NA 784-500-1000-10 1024 2.32% 1,292,310 10.77 NA of 2 while summation of two uncorrelated stochastic streams, {0, 0, 1, 0, 1, 1} and {1, 1, 0, 1, 0, 0}, representing real value of 0.5 results in integral stochastic stream of {1, 1, 1, 1, 1, 1} and input range of 1. Correlation among the inputs is introduced when the same LFSR units are shared among several inputs, in order to reduce hardware area. In this paper, the set of LFSR units that are used for one neuron are shared for all the other neurons. More precisely, 785 11-bit LFSRs with different seeds are used in total to generated all inputs and weights of the proposed DBN architectures and guarantee non-correlated stochastic streams."
    },
    {
      "heading": "A. Misclassification Error Rate Comparison",
      "text": "The misclassification error rate of DBNs plays a crucial role in the performance of the system. In this part, the misclassification errors of the proposed integer stochastic architectures of DBNs with different configurations are summarized in Table II. Simulation results have been obtained by using MATLAB on 10000 MNIST handwritten test digits [27] for both floating point code and the proposed architecture using LFSRs as the stream generators. The method proposed in [29] is used as our training core to extract the network weights. In fixed-point format, a precision of 10 bits is used to represent the weights. A stochastic stream of equivalent precision requires a length of 1024. The length of the stream can be reduced by increasing m. For example, using m = 2 the length can be reduced to 512, and using m = 4 it can be reduced to 256. Because the input pixels only require 8 bits of precision, they can be represented using a binary (m = 1) stochastic stream of length 256. Therefore, by using m = 1 for the pixels and m = 4 for the weights, it is possible to reduce the stream length to 256 while still using AND gates to implement multiplications. The simulation results show the negligible performance loss of the proposed integer stochastic DBN for different sizes compared to their floating point versions. The reported misclassification errors for the proposed integral stochastic architecture were obtained using LFSR units as random number generators in MATLAB."
    },
    {
      "heading": "B. FPGA Implementation",
      "text": "As mentioned previously, a fully-or semi-parallel VLSI implementation of DBN in binary form requires a lot of hardware resources. Therefore, many works target FPGAs [30]- [35], but none manage to fit a fully-parallel deep neural TABLE IV ASIC IMPLEMENTATION RESULTS FOR A 784-100-200-10 NETWORK @ 400 MHZ AND 1V IN A 65 NM CMOS TECHNOLOGY Implementation Type Integral SC Binary Radix Stream Length 256 512 1024 -Misclassification error [%] 2.33 2.46 2.40 2.3 Energy [µJ] 2.96 3.3 3.35 0.380 Gate Count [M Gates (NAND2)] 4.2 2.2 1.1 23.6 Latency [ns] 650 1290 2570 30 network architecture in a single FPGA board. Recently, a fully pipelined FPGA architecture of a factored RBM (fRBM) was proposed in [9], which could implement a single layer neural network consisting of 4096 nodes using virtualization technique, i.e., time multiplex sharing technique, on a Virtex-6 FPGA board. However, the largest fRBM neural network achievable without virtualization is on the order of 256 nodes. In [28], a stochastic implementation of DBN on a FPGA board is presented for different network sizes, however, this architecture cannot achieve the same misclassification error rate as a software implementation. Table III shows both the hardware implementation and performance results of the proposed integer stochastic architecture of DBN for different network sizes on a Virtex7 xc7v2000t Xilinx FPGA. The implementation results show that the misclassification error of the proposed architectures for network size of 784-100-200-10 is the same as for the largest network presented in [28], i.e., the network size of 784-500-1000-10, while the area of the proposed designs are reduced by 66%, 47% and 21% for m = 1, m = 2 and m = 4. Moreover, the latency of the proposed architectures are also reduced by 40%, 63% and 84% for m = 1, m = 2 and m = 4. Therefore, as the value of m increases, the latency of the integer stochastic hardware is reduced and becomes suitable for throughput-intensive applications. Note that the reported areas in Table III include the costs of B2S and B2IS units."
    },
    {
      "heading": "C. ASIC Implementation",
      "text": "Table IV shows the ASIC implementation results for a fixedpoint implementation of the network size of 784-100-200-10. Despite the improvements that the proposed architectures provide over previously proposed stochastic implementations, the stochastic implementations still uses more energy than the fixed-point implementation in 65 nm CMOS, even if the TABLE V ASIC IMPLEMENTATION RESULTS FOR A 784-300-600-10 NETWORK BASED ON INTEGRAL SC @ 400 MHZ AND 1V IN A 65 NM CMOS TECHNOLOGY Implementation Type Integral SC Binary Radix Network Configuration 784-300-600-10 784-100-200-10 Value of m 1 2 4 -Stream Length 64 128 256 512 32 64 128 256 16 32 64 128 -Misclassification error [%] 2.49 2.24 2.22 2.07 2.42 2.30 2.24 1.96 2.27 2.22 2.07 1.95 2.3 Energy [µJ] 0.740 1.436 2.802 5.640 0.505 1.029 1.997 3.933 0.299 0.640 1.28 2.53 0.380 Gate Count [M Gates (NAND2)] 5.4 5.6 5.6 5.6 9.2 9.7 10.2 10.2 15.6 16.9 17.8 18.9 23.6 Latency [ns] 170 330 650 1290 90 170 330 650 50 90 170 330 30 TABLE VI DEVIATIONS OF LAYER-1 AND LAYER-2 NEURONS FOR A 784-300-600-10 NETWORK Deviation (%) Layer-1 Neuron Layer-2 Neuron 0.7V 17.90 15.41 0.75V 8.57 3.95 0.8V 0.011 ≈ 0 power consumption and area of a stochastic neuron are smaller. A similar result was also obtained in [36] for stochastic implementations of image processing circuits. In order to improve the energy consumption of the proposed stochastic architectures, we select a bigger network size with better misclassification rate and reduce the stream length to achieve roughly the same misclassification error rate as the binary radix implementation in Table IV. The implementation results of a 784-300-600-10 neural network based on integral SC for different stream lengths and values of m are summarized in Table V. The implementation results show that the integral stochastic architecture for value of m = 4 and stream length of 16 at misclassification error rate of 2.3% consumes 21% less energy as well as 34% less area compared to the binary radix implementation."
    },
    {
      "heading": "D. Quasi-Synchronous Implementations",
      "text": "In order to further reduce the energy consumption of the system, we also consider a quasi-synchronous implementation, in which the supply voltage of the circuit is reduced beyond the critical voltage by permitting some timing violations to occur. Timing violations introduce deviations in the computations, but because the stochastic architecture is fault-tolerant, we can obtain the same classification performance by slightly increasing the length of the streams. This yields further energy savings without any compromise on performance. We characterize the effect of timing violations on the algorithm by studying small test circuits that can be simulated quickly, using the same approach as in [37]. In the proposed architecture, the same processing circuit can be replicated several times to form each layer, depending on the required degree of parallelism. Therefore, we characterize the effect of timing violations on these small processing circuits: each neuron processor (one for each layer) is synthesized in a 65 nm CMOS technology and deviations are measured at different voltages, from 0.7V to 1.0V in 0.05V increments, TABLE VII ASIC IMPLEMENTATION RESULTS FOR A 784-300-600-10 NETWORK @ 400 MHZ IN A 65 NM CMOS TECHNOLOGY UNDER FAULTY CONDITIONS Implementation Type Integral SC Supply Voltage (Layer-1-layer-2-layer-3) 0.8-0.7-0.8 0.75-0.75-0.8 0.8-0.8-0.8 Stream Length 30 30 22 Misclassification error [%] 2.29 2.28 2.30 Energy [µJ] (improvement w.r.t. 1V) 0.283 (-5%) 0.286 (-4%) 0.256 (-14%) Gate Count [M Gates (NAND2)] 15.6 15.6 15.6 Latency [ns] 85 85 65 as shown in Table VI. Note that no deviations are observed when the supply voltage is larger than 0.8V. The output of first and second layers is binary, while the output of classification layer has 6 bits. Binary to stochastic converter units are also considered for each neuron and the weights are hard coded for the implementations. The deviation error of the layer-3 neuron for 0.7V and 0.75V results in a huge misclassification error. It is not beneficial to allow large deviations to occur in that layer since there are only 10 neurons in the third layer, and therefore we do not expect the supply voltage of layer-3 processing circuits to have a big impact on the overall energy consumption. Therefore, the layer-3 neurons supplied with 0.8V are used. Note that no deviations are observed when the supply voltage is 0.8V in the layer-3 neurons. The performance results for a 784-300-600-10 network and m = 4 at different supply voltages are provided in Table VII. The misclassification performance obtained by the quasi-synchronous system is very similar to the performance of the reliable system, despite the fact that the deviation rate is up to 9% in layer-1 neurons and 16% in layer-2 neurons. This results in up to a 14% lower energy consumption without any compromise on performance. On the other hand, introducing bit-wise deviations at a rate of 1% in the fixed-point system results in a 87% misclassification rate. Note that the reported implementation results in this paper include costs of B2N and B2IS units. Moreover, because a stochastic implementation is much more fault-tolerant than a fixed-point implementation, it can be preferable for future process technologies, and in particular for inherently unreliable ones such as nanoscale memristor devices. Note that memristor devices consume substantially less energy compared to CMOS and can be scaled to sizes below 10 nm [23]. In [23], stochastic implementations were suggested as a promising approach for use in such devices."
    },
    {
      "heading": "VI. CONCLUSION",
      "text": "Integral SC makes the hardware implementation of precision-intensive applications feasible in the stochastic domain, and allows computations to be performed with streams of different lengths, which can improve the latency of the system. An efficient stochastic implementation of a deep belief network is proposed using integral SC. The simulation and implementation results show that the proposed design reduces the area occupation by 66% and the latency by 84% with respect to the state of the art. We also showed that the proposed design consumes 21% less energy than its binary radix counterpart. Moreover, the proposed architectures can save up to 33% energy consumption w.r.t. the binary radix implementation by using quasi-synchronous implementation without any compromise on performance."
    }
  ]
}