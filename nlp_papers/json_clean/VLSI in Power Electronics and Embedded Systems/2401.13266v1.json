{
  "paperid": "2401.13266v1",
  "title": "SpecLLM: Exploring Generation and Review of VLSI Design Specification with Large Language Model",
  "authors": [
    "Li",
    "Fang",
    "Zhang",
    "Xie",
    "Achiam",
    "Adler",
    "Agarwal",
    "Ahmad",
    "Akkaya",
    "Aleman",
    "Almeida",
    "Altenschmidt",
    "Altman",
    "Anadkat",
    "Liu",
    "Fang",
    "Lu",
    "Zhang",
    "Zhang",
    "Xie",
    "Blocklove",
    "Garg",
    "Karri",
    "Pearce",
    "Lu",
    "Liu",
    "Zhang",
    "Xie",
    "Liu",
    "Pinckney",
    "Khailany",
    "Ren",
    "Thakur",
    "Ahmad",
    "Fan",
    "Pearce",
    "Tan",
    "Karri",
    "Dolan-Gavitt",
    "Garg",
    "Thakur",
    "Blocklove",
    "Pearce",
    "Tan",
    "Garg",
    "Karri",
    "Nair",
    "Sadhukhan",
    "Mukhopadhyay",
    "Liu",
    "Ene",
    "Kirby",
    "Cheng",
    "Pinckney",
    "Liang",
    "Alben",
    "Anand",
    "Banerjee",
    "Bayraktaroglu",
    "He",
    "Wu",
    "Zhang",
    "Yao",
    "Zheng",
    "Zheng",
    "Yu",
    "Fu",
    "Zhang",
    "Yu",
    "Li",
    "Ye",
    "Li",
    "Wan",
    "Lin",
    "Yan",
    "Qin",
    "Hu",
    "Shi",
    "Kande",
    "Pearce",
    "Tan",
    "Dolan-Gavitt",
    "Thakur",
    "Karri",
    "Rajendran",
    "Ahmad",
    "Thakur",
    "Tan",
    "Karri",
    "Pearce",
    "Isa",
    "Isa",
    "Inc",
    "Weaver",
    "Complex",
    "Tm",
    "External",
    "Support",
    "Specification",
    "Risc-V",
    "Risc-V",
    "Opensparc",
    "Risc-V",
    "Specifications",
    "Celio",
    "Patterson",
    "Asanovic",
    "Xu",
    "Yu",
    "Tang",
    "Chen",
    "Chen",
    "Gou",
    "Jin",
    "Li",
    "Li",
    "Li",
    "White",
    "Fu",
    "Hays",
    "Sandborn",
    "Olea",
    "Gilbert",
    "Elnashar",
    "Spencer-Smith",
    "Schmidt",
    "Chang",
    "Wang",
    "Wang",
    "Wu",
    "Zhu",
    "Chen",
    "Yang",
    "Yi",
    "Wang",
    "Wang"
  ],
  "year": 2024,
  "abstract": "The development of architecture specifications is an initial and fundamental stage of the integrated circuit (IC) design process. Traditionally, architecture specifications are crafted by experienced chip architects, a process that is not only timeconsuming but also error-prone. Mistakes in these specifications may significantly affect subsequent stages of chip design. Despite the presence of advanced electronic design automation (EDA) tools, effective solutions to these specification-related challenges remain scarce. Since writing architecture specifications is naturally a natural language processing (NLP) task, this paper pioneers the automation of architecture specification development with the advanced capabilities of large language models (LLMs).The absence of a clear and precise definition of architecture specifications poses the first challenge in our research. To address this, we propose a structured definition of architecture specifications, categorizing them into three distinct abstraction levels. Leveraging this definition, we create and release a specification dataset 1 by methodically gathering 46 architecture specification documents from various public sources. Our clear definitions of architecture specifications, coupled with the dataset we have formed, lay a solid foundation for prospective research in employing LLMs for architecture specifications.Leveraging our definition and dataset, we explore the application of LLMs in two key aspects of architecture specification development: (1) Generating architecture specifications, which includes both writing specifications from scratch and converting RTL code into detailed specifications. (2) Reviewing existing architecture specifications. We got promising results indicating that LLMs may revolutionize how these critical specification documents are developed in IC design nowadays. By reducing the effort required, LLMs open up new possibilities for efficiency and accuracy in this crucial aspect of chip design.",
  "sections": [
    {
      "heading": "I. INTRODUCTION",
      "text": "Developing architecture specifications is a critical initial step in the process of IC design. It lays the foundational framework and guidelines necessary for the subsequent stages of design and development. Traditionally, the task of writing and reviewing architecture specifications is undertaken by skilled chip architects. This process, while expertise-driven, tends to be time-consuming and can be susceptible to human errors, soliciting a more automated methodology to enhance efficiency and accuracy. In recent years, LLMs such as ChatGPT [1] have showcased remarkable capabilities in the field of artificial intelligence, with a wide range of applications from question answering to content creation. The growth of chip computing power will endow LLMs with greater capabilities. Consequently, researchers have started to investigate the potential of LLMs in augmenting the process of chip design, reversely enhancing 1 The dataset will be available at https://github.com/hkust-zhiyao/SpecLLM"
    },
    {
      "heading": "Dataset",
      "text": "Middle-level Architecture Specifications (MAS) Highest-level Architecture Specifications (HAS) Fig. 1: The overall structure of this paper. We first propose basic definitions and an organized dataset dedicated to architecture specifications. Leveraging them, we explore the use of LLMs in the generation and review of architecture specifications. the computing power of the chips themselves. For instance, recent studies [2,3,4,5,6,7,8,9] have utilized LLMs to generate RTL code like Verilog. Other works develop LLM-based solution to control EDA tools [9,10], design AI accelerator architectures [11,12], hardware security assertion generation [13], fix security bugs [14], etc. These research efforts imply a promising future for LLMs in chip design. In this paper, we conduct a pioneering investigation in the potential and practicality of LLMs in processing specifications. To the best of our knowledge, there has been no prior design automation or LLM research focusing on this important topic. This paper focuses on employing LLMs to address the challenges inherent in the traditional management of architecture specifications. Figure 1 highlights the overall structure of this paper. Considering the absence of a formal definition or categorization of architecture specifications, we start with investigating existing architecture specifications across a diverse range of products. Then we categorize architecture specifications into three levels: Highest-level Architecture Specification (HAS), Middle-level Architecture Specification (MAS), and Lowest-level Architecture Specification (LAS). HAS is defined as the specification that establishes standards applicable across a range of products. It is at the highest abstraction level. MAS represents the specification that outlines the high-level architecture of a single-chip design. LAS is the detailed specification focused on the microarchitecture design of an individual chip. Building upon our definition, we have assembled a comprehensive dataset that includes 46 public architecture specifications from various types of products. For the HAS, MAS, or LAS, the architecture specifications related to RISC-V are among the most accessible and widely available. In contrast, architecture specifications for other instruction sets are relatively scarce. We have also observed that current architecture specifications suffer from a lack of unified writing standards, and the length of these specifications may exceed the processing capacity of LLMs. Both of them complicate the process of handling architecture specifications using LLMs. Based on the basic formulation, we investigate the application of LLMs in both generation and reviewing architecture specifications. Regarding specification generation, we suggest two potential approaches. The first is to simplify the process of writing architecture specifications for designers, making it more efficient and less error-prone. The second approach is applicable when architecture specifications are absent for an already implemented chip. In such scenario, we can transform the RTL code back into architecture specifications, essentially reconstructing the original design documentation from the implemented code. According to our experiment, when generating specifications for simple logic circuits, the majority of the human tasks could be done by LLMs. We are optimistic that, even for more complex logic circuits, it is promising for LLMs to progressively take over a large portion of the work. We also demonstrate that the LLMs can efficiently review the architecture specifications. We first propose our definition of various types of defects in architecture specification document. Building on this, we utilized these defects as the target responses and developed specific prompts, seeking for LLM's review. As for the public architecture specifications, our experiments have demonstrated that the LLMs could provide valuable feedback for enhancing these documents. Moving forward, we plan to extend our research to include the evaluation of the review results generated by the LLMs, streamlining the review process and enhancing the reliability of the outcomes. In summary, we formulate the task of adopting LLMs in the development of architecture specifications. We provide fundamental definitions and explore applications of LLMs in the realm of architecture specification development, including the basic definitions of architecture specifications and various tasks that LLMs can perform in this context. Our key contributions are summarized below: • We provide structured definitions of architecture specifications, facilitating efficient utilization of LLMs in developing architecture specifications. (Section II) • We generate a dataset of design specifications by methodically collecting and systematically organizing architecture specification documents from a variety of online sources. This paves the way for exploring LLMs in the development of architecture specifications. (Section III) • We explore the use of LLMs as tools for generating architecture specifications, including assisting designers in writing these specifications and converting RTL code into comprehensive specifications. Our findings suggest that LLMs hold considerable promise in efficiently generating architecture specifications. (Section IV) • We explore the use of LLMs in the review of architecture specifications. We identify various potential defects that may arise in these specifications. Based on these identified defects, we have crafted specific processes and prompts to guide the LLMs in their review. Our experimental results indicate that LLMs are capable of providing valuable feedback for improving these documents in aspects of accuracy. (Section V)"
    },
    {
      "heading": "II. OUR DEFINITION ON ARCHITECTURE SPECIFICATION",
      "text": "We define the architecture specification as the document that describes the chip architecture prior to RTL coding. Writing architecture specifications for the target chip is usually the starting point of the IC design flow. The term architecture specification is specifically chosen to emphasize that the document captures the architectural aspects of a chip, distinguishing it from general specifications. We categorize the architecture specifications into three levels. • The Highest-level Architecture Specification (HAS) establishes standards applicable to a range of products. A notable example is the RISC-V specifications [61]. It defines the ISA specifications (e.g., instruction formats, register usages) and Non-ISA specifications (e.g., trace). Designing specific RISC-V chips should comply with these specifications. • The Middle-level Architecture Specification (MAS) outlines the high-level architecture of a single product. These specifications encompass the essential information required to profile the chip design. For example, one MAS for a RISC-V CPU may include an overview of the microarchitectures (e.g., block diagram) and their primary parameters (e.g., cache size). • The Lowest-level Architecture Specification (LAS) details the microarchitecture design of a single product. Unlike HAS and MAS, LAS should give the implementation details for each microarchitecture, which may involve the ports, internal signals, pipelines, and the associated descriptions. By reading them, the designers are expected to write the corresponding RTL code correctly. The architecture specifications are distinct from the user manuals. We define the user manuals as the documents that succinctly outline the chip design post-production. In contrast to architecture specifications, which primarily cater to chip designers, user manuals are typically crafted for the end users and programmers. Nonetheless, we note that certain contents in the user manuals exhibit similarities to the HAS or MAS. For example, as described in Section III, we identify the ARMv8-M Architecture Reference Manual [17], Intel 64 and IA-32 Architectures Software Developer's Manual [18] as HAS; and a series of Arm Core Technical Reference Manuals [28,27,26], Intel 64 and IA-32 Architectures Optimization Reference [29] as MAS. TABLE I: Our proposed dataset for architecture specifications, including approximately 46 specification documents. Type Highest-level Architecture Specifications (HAS) Middle-level Architecture Specifications (MAS) Lowest-level Architecture Specifications (LAS)"
    },
    {
      "heading": "CPU",
      "text": "• RISC-V ISA Specifications, Unprivileged Specification [15] • RISC-V ISA Specifications, Privileged Specification [16] • ARMv8-M Architecture Reference Manual [17] • Intel 64 and IA-32 Architectures Software Developer's Manual [18] • The SPARC Architecture Manual, Version 9 [19] • OpenRISC 1000 Architecture Manual [20] • *The NEORV32 RISC-V Processor: Datasheet [21] • *OpenSPARC T1 Microarchitecture Specification [22] • *OpenSPARC T2 Core Microarchitecture Specification [23] • E31 Core Complex Manual [24] • E51 Core Complex Manual [25] • Arm Cortex-A78 Core Technical Reference Manual [26] • Arm Cortex-X2 Core Technical Reference Manual [27] • Arm Neoverse-N2 Core Technical Reference Manual [28] • Intel 64 and IA-32 Architectures Optimization Reference [29] • OpenRISC 1200 IP Core Specification [30] • The NEORV32 RISC-V Processor: Datasheet [21] • OpenSPARC T1 Microarchitecture Specification [22] • OpenSPARC T2 Core Microarchitecture Specification [23] • Amber 2 Core Specification [31] • LXP32, a lightweight open source 32-bit CPU core, Technical Reference Manual [32] • OpenMSP430, Texas Instruments [33] • NEO430, based on the Texas Instruments MSP430(TM) ISA [34] SoC • #The NEORV32 RISC-V Processor: Datasheet [21] • OpenSPARC T2 System-On-Chip (SoC) Microarchitecture Specification [42] Accelerator • RISC-V \"V\" Vector Extension [43] • Intel Advanced Performance Extensions (Intel APX) Architecture Specification [44] • Intel Advanced Vector Extensions 10 (Intel AVX10) Architecture Specification [45] • NVIDIA Deep Learning Accelerator (NVDLA), Hardware Architectural Specification [46] Bus & Network • TileLink Specification [47] • AMBA5 CHI Architecture Specification [48] • AMBA5 ACE Protocol Specification (superseded by CHI) [49] • AMBA5 AXI Protocol Specification [50] • AMBA4 AXI and ACE Protocol Specification [51] • 10GE MAC Core Specification [52] • Ethernet IP Core Specification [53] • I2C-Master Core Specification [54] • UART to Bus Core Specifications [55] Arithmetic • Elliptic Curve Group Core Specification [56] • Tate Bilinear Pairing Core Specification [57] • Tiny Tate Bilinear Pairing Core Specification [58]"
    },
    {
      "heading": "Crypto",
      "text": "• AES Core Specification [59] • SHA3 Core Specification [60] ⋆ Notes: *NEORV32 [21], OpenSPARC T1 [22], OpenSPARC T2 [23] include chapters meeting the criterion of MAS. #NEORV32 [21] encompasses chapters describing the SoC implementation. III. DATASET OVERVIEW Table I provides an overview of our proposed dataset for architecture specifications. It shows a variety of public architecture specifications and user manuals, organized by product types like CPU, SoC, Accelerator, Bus and Network, Arithmetic and Crypto, and by levels such as HAS, MAS, and LAS. It is important to note that in Table I, we only display a representative selection of about 50 architecture specifications. For documents exhibiting a high degree of similarity, like additional Arm Core Technical Reference Manuals and AMBA Protocol Specifications, we have omitted them for simplicity. Our collection has yielded several notable findings. Availability. For the HAS, MAS, or LAS, the architecture specifications related to RISC-V are among the most accessible and widely available. Especially for the HAS, there are various established standards that exist, catering to different kinds of products, such as the CPU [16,15], SoC [35,37,38,39], Accelerator [43] and Cache Coherence Bus [47]. An interesting observation is that despite the vast number of open-source designs in the RISC-V ecosystem, there is a scarcity of available MAS and LAS documents. Many documents, such as the Boom Core [62] and XiangShan Core [63], which describe the design of open-source chips, do not fulfill the standards required for formal architecture specifications. Therefore, we have chosen not to include these in our table. This gap highlights a potential area for improvement in the documentation and standardization of open-source chip designs. For the Arm and X86 ecosystem, the availability of formal architecture specifications is weaker. We can only find some reference manuals intended for programmers or end-users. Despite this limitation, upon investigation, it is observed that the contents of these manuals partially align with what one would expect in formal architecture specifications. Consequently, we have chosen to include these reference manuals for conducting research. Standard. While writing architecture specifications is a common practice in commercial chip manufacturing, we observe the available open specification documents exhibit a variety of writing styles and lack unified writing standards. Within individual semiconductor companies, there's a tendency to maintain a consistent format for architecture specifications. Yet, the absence of unified writing standards across the industry leads to a diversity in the presentation and structuring of these documents, especially evident in open-source chip design [21,31,32,33,34]. This variation in writing styles and lack of standardized formats in architecture specifications pose additional challenges for LLMs in handling and accurately interpreting these documents. Length. The length of HAS spans from just over 100 pages to more than 1000 pages. The lengths of MAS and LAS can vary widely, with their extent directly correlating to the complexity of the chip designs they describe. MASs outline the chip designs, and thus are usually shorter than the LASs, ranging from several pages to in excess of 100 pages. LASs extend from over 10 pages to hundreds of pages. The longer the architecture specifications are, the more contextual information the LLMs tend to process. However, current commercial LLM products have a limitation on the number of tokens they can handle, which is not infinite. In Section V, as we will discuss, the increase in contextual information due to longer architecture specifications poses challenges. It can lead to a decrease in the accuracy of the LLM's output. Therefore, the length of the architecture specifications must be carefully considered when employing an LLM to manage these documents. In the following sections, we will choose portions of them to demonstrate LLM's capabilities in developing architecture specifications. Constrained by the scarcity of existing architecture specifications, we consider certain sections of user manuals to function as architecture specifications."
    },
    {
      "heading": "IV. LLM GENERATES ARCHITECTURE SPECIFICATION A. Motivation",
      "text": "Traditionally, writing architecture specifications is a nontrivial, but critical step in the process of IC design. Our research indicates that chip architects spend a considerable amount of time writing architecture specifications for several reasons: • Massive Information Organization: Whether for HAS, MAS, or LAS, a significant amount of information must be organized. Systematically arranging them is crucial for the ensuing RTL coding process. While criteria for writing architecture specifications exist in separate companies, the complexity of this task escalates with the increasing scale of the designs. • Diverse Modules Interconnection: MAS is responsible for establishing the interconnection between various hardware modules. This plays a critical role in ensuring the overall correctness of the complete product. Despite this, the process of integrating these modules often encounters challenges, such as the time-consuming tasks of discerning different interfaces and identifying the functions of each module. • Complicate Algorithm Implementation: LAS delineates the structures and behaviors for each microarchitectural design. According to our observation, LAS is closest to the final RTL design among the three types of architecture specifications. When dealing with complex microarchitectural algorithms, such as branch prediction, writing LAS presents significant challenges, which include accurately defining signals and state machines. LLMs are promising in solving the above challenges and assisting designers in writing architecture specifications. According to Section II, HASs set the standards for a variety of products and are inherently determined by human decisions. Consequently, they are highly flexible and challenging to generate. We thus mainly focus on using LLMs to automatically generate the MAS and LAS. We explore two LLM-based applications: 1) LLMs can reduce human effort by writing architecture specifications (Section IV-B). 2) Many open-source chip designs lack comprehensive and formal architecture specifications. In situations where these specifications are absent, LLMs could reversely convert the RTL code into detailed specification documents. This reverse engineering process can bridge the"
    },
    {
      "heading": "Prompt:",
      "text": "From now on, you act as a chip architect writing the architecture specification. This specification must encompass detailed descriptions of microarchitectures, including aspects such as ports, internal signals, state machines. Subsequently, I will assign you a specific module to focus on in your writing. Fig. 2: An example prompt to initiate generating LAS. This generation is based on the designers' brief description."
    },
    {
      "heading": "Prompt:",
      "text": "Please write an architecture specification regarding a perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle. Fig. 3: An example prompt to request GPT generating an architecture specification for perpetual calendar. The response is shown in Figure 4. gap in the documentation and enhance understanding and accessibility of the chip designs (Section IV-C). In the upcoming sections, we will leverage the widely-used commercial LLM product-GPT-4 [1], to demonstrate how this technology can be effectively exploited to enhance the process of writing architecture specifications."
    },
    {
      "heading": "B. Assist Designers to Write Architecture Specifications",
      "text": "Figure 2 presents an example of a prompt to initiate the generation of LAS. This example, referencing [64], indicates the specific role expected to be performed by the LLMs, and the expected response format. Then we employ the prompt in Figure 3 to direct GPT generating the architecture specifications. This particular example, sourced from [4], has been selected due to its moderate level of complexity, making it suitable for testing purposes. Figure 4 presents the outcomes of GPT-4. The experimental results demonstrate that the GPT can accurately understand the questions. These specifications, spanning from the high-level functional description to the lowlevel state machines, offer in-depth information for subsequent RTL coding. Yet, the design of a perpetual calendar is a classical task in the field of circuit design. The LLMs have abundant corpus about it. The commercial products, usually include internal IPs, which are not used to train the external LLMs like ChatGPT. We believe it is non-trivial to generate that kind of architecture specifications. However, our experiments at least demonstrate that the LLMs possess the potential to conduct the task of generating architecture specifications. The speed of the LLMs in performing this task, compared to the experienced chip architects, still has significant advantages."
    },
    {
      "heading": "C. Convert RTL code to Architecture Specifications",
      "text": "Figure 5 showcases the prompt employed for converting the RTL code into LAS. Following this prompt, we provide the RTL code to the LLM, which can be in the form of textual format or as a source code file. In our example, we adopt the Verilog file that is open-sourced by RTLLM [65] and it is uploaded to our GitHub repo. The response of GPT is shown in Figure 6. In summary, the generated architecture Response:"
    },
    {
      "heading": "Architecture Specification for a Perpetual Calendar Module Overview",
      "text": "This document outlines the architectural specification for a Perpetual Calendar Module (PCM). The PCM is responsible for tracking time in seconds, minutes, and hours, with a continuous looping mechanism. The time is represented in a 24-hour format. The module initializes with all time values (seconds, minutes, hours) at zero and increments according to predefined rules."
    },
    {
      "heading": "Functional Description",
      "text": "Time Units Seconds (Secs): This unit ranges from 0 to 59. It resets to 0 after reaching 59. Minutes (Mins): This unit also ranges from 0 to 59. It increments by 1 when Secs roll over from 59 to 0. Hours: This unit ranges from 0 to 23. It increments by 1 when both Mins and Secs roll over from 59 to 0. Initial State All units (Secs, Mins, Hours) are initialized to 0 at the start. Increment Logic Secs Increment: Occurs every cycle. Rolls over to 0 after reaching 59. Mins Increment: Occurs when Secs roll over from 59 to 0. Hours Increment: Occurs when both Mins and Secs simultaneously roll over from 59 to 0. Microarchitecture Components Counter Units: Three independent counters for Secs, Mins, and Hours. Control Logic: Determines the rollover conditions and triggers the increment of Mins and Hours. Clock Signal: Drives the incrementation of Secs. Counter Behavior Each counter is a modulo-60 counter for Secs and Mins, and a modulo-24 counter for Hours. The counters are synchronized with the clock signal. Control Logic Monitors the state of Secs and Mins. When Secs reach 59, it sends a pulse to increment Mins at the next cycle. When both Secs and Mins are 59, it sends a pulse to increment Hours at the next cycle. Interface Input: Clock signal. Output: Current time in hours, minutes, and seconds."
    },
    {
      "heading": "Prompt:",
      "text": "From now on, you act as a chip architect writing the architecture specification. This specification must encompass detailed descriptions of microarchitectures, including aspects such as ports, internal signals, state machines. Subsequently, I will provide you with the RTL code. Please read the RTL code and generate the corresponding architecture specification. Fig. 5: An example prompt to initiate writing architecture specifications on the basis of RTL code. The response is shown in Figure 6. specifications are slightly shorter than those depicted in Figure 4, yet they effectively preserve the correct meaning. We conduct experiments to analyze this phenomenon. Our findings indicate that the provided RTL code confines the scope for the specification generation. Without the RTL code, the LLM may generate the architecture specifications on the basis of the previously trained corpus, which exhibits diverse explanations for the single circuit design. On the contrary, after we offer the LLM with a unique RTL code, its responses are likely to be more orientated."
    },
    {
      "heading": "A. Motivation",
      "text": "The accuracy and precision of architecture specifications directly affect the overall quality of chip designs. Ensuring these specifications are correct is crucial for the successful development and functionality of the chips. Traditionally, the chip company should spend efforts to review architecture specifications. Analogous to the reasons mentioned in Section IV-A, reviewing architecture specifications also requires significant human efforts. LLMs can also help reviewers in these tasks. At least, the reviewers could use these tools to get an overview of the specification files and obtain some comments from them. Fortunately, as we will demonstrate in Section V-B and Section V-C, the LLMs show promise in achieving more profound objectives in the review of architectural specifications, going beyond basic overviews to provide detailed and meaningful insights."
    },
    {
      "heading": "B. Defects Category",
      "text": "Type Potential Defects Common Case • Typographical Error • Inconsistence or Contradiction Error • Incomplete or Unclear Error Level Specific • Combinational Loops Error (LAS) • Uninitialized Register Value Error (LAS) • Improvement for Micro-architectural Design (LAS) • Improvement for Architectural Design (MAS) Level Spanning • Inconsistence or Contradiction Error (Across Various Levels) TABLE II: Potential Defects Occurred in Different Levels Architecture Specifications Initially, we have pinpointed various types of potential defects that may occur in architecture specifications. Table II Response: I have received the RTL (Register Transfer Level) code file named \"verified_calendar.v\". I'll proceed to read and analyze this file to generate a corresponding architecture specification. Let's start by examining the contents of the file. The RTL code in \"verified_calendar.v\" defines a module named verified_calendar. This module appears to be designed as a simple digital clock. Here's a brief overview of the module and its key components based on the initial part of the code:"
    },
    {
      "heading": "Outputs:",
      "text": "• Hours: 6-bit output representing hours. • Mins: 6-bit output representing minutes. • Secs: 6-bit output representing seconds."
    },
    {
      "heading": "Behavioral Description:",
      "text": "The module contains three always blocks, each triggered on the positive edge of CLK or RST. Seconds Logic: • On reset (RST), seconds (Secs) are set to 0. • If seconds equal 59, they roll over to 0; otherwise, they increment every clock cycle."
    },
    {
      "heading": "Minutes Logic:",
      "text": "• On reset, minutes (Mins) are set to 0. • Minutes increment when seconds roll over from 59 to 0. If minutes are at 59 when seconds roll over, they reset to 0."
    },
    {
      "heading": "Hours Logic:",
      "text": "• Not fully visible in the provided snippet, but likely similar to minutes, incrementing as minutes roll over."
    },
    {
      "heading": "State Machine for Seconds:",
      "text": "States: Reset, Count Transitions: • Reset to Count: When RST de-asserted. • Count to Reset: When RST asserted or Secs reach 59. Output: Increments Secs or resets to 0 based on the state."
    },
    {
      "heading": "State Machine for Minutes:",
      "text": "States: Reset, Count Transitions: • Reset to Count: When RST de-asserted. • Count to Reset: When Mins reach 59 and Secs are 59. Output: Increments Mins or resets to 0 based on the state and Secs. Fig. 6: A GPT response example to the prompt in Figure 5. summarizes these defects, categorizing them according to the level of architecture specifications. In many instances, there are defects that could manifest in all three tiers of architecture specifications: HAS, MAS, and LAS. They include the Typographical Error, Inconsistence or Contradiction Error, and Incomplete or Unclear Error. The Inconsistence or Contradiction Error denotes situations within a single specification file where either two concepts describing the same object are inconsistent, or two related concepts are contradictory. The Incomplete or Unclear Error refers to instances where certain concepts lack essential information, resulting in sentences that are open to ambiguous interpretations. Furthermore, the potential defects could also be levelspecific, indicating that HAS, MAS, or LAS may each have distinct defects. For example, LAS might include details about port connections between various modules. LLMs can be employed to scrutinize the LAS for identifying potential Combinational Loops Error. Such scrutiny, however, may not be applicable to HAS and MAS. In addition to locating the writing issues, we also identify some high-level objectives for the review of architecture specification, such as the Improvement for Architectural Design and Improvement for Micro-architectural Design. These objectives are aimed at leveraging the potential of the review process to enhance both the architectural and micro-architectural design aspects. This goes beyond mere error correction, focusing on the overall optimization and refinement of the design. Additionally, these defects might span across different levels. One example of this is the Inconsistence or Contradiction Error (Across Various Levels), that the lower-level architecture specifications should not contradict the contents established in the higher-level specifications. Note that it is not equivalent to the Inconsistence or Contradiction Error established for the common case. The former indicates the inconsistence or contradiction between different levels of architecture specification files, while the latter confines the error in one individual specification file."
    },
    {
      "heading": "C. Architecture Specification Review",
      "text": "We exploit the potential defects in architecture specifications as the types of feedback (Section V-B) we aim to receive from the review conducted by the LLMs. We have developed two methodologies to guide the LLMs in reviewing architecture specifications. The first method involves directly uploading the entire specification file and requesting the LLMs to provide feedback section by section. The second method entails splitting the specification file into sections, uploading each section individually, and then asking the LLMs to conduct a review immediately upon the upload of each section. Regarding the first approach, it has the advantage of not requiring extra steps to divide the specification file. However, we've observed that even when instructed to give feedback for each section, the LLMs struggle to accurately recognize the boundaries between different sections. This often results in the provision of incorrect or misleading indication messages by the LLMs. The second approach, which involves splitting the specification file into sections and uploading each one separately for review, can effectively alleviate this problem by providing clearer boundaries for the LLMs to analyze and respond to each section individually. In the subsequent sections, we will use part of the architecture specifications, as shown in Table I, to demonstrate LLM's strengths and weaknesses in reviewing architecture specifications. 1) Reviewing One File at a Time: We employ the Amber 2 Core Specification [31] to conduct the experiments of reviewing architecture specifications. The tested file used in our example is from [66] and it has been uploaded to our Prompt: From now on, you act as a chip architect reviewing the architecture specification. For the following document, please find any typo, inconsistence/contradiction, incomplete/unclear and propose the corresponding improvement suggestions. The responding format should separately list the findings about typo, inconsistence/contradiction, incomplete/unclear and the corresponding improvement suggestions. Fig. 7: An example prompt to initiate the review of architecture specifications. The response is shown in Figure 8."
    },
    {
      "heading": "Response:",
      "text": "I have thoroughly reviewed the Amber Core Specification document. Here are the summarized findings: 1. Typos and Grammatical Errors: The document contains some typographical and grammatical errors which can be corrected for clarity and professionalism. 2. Inconsistencies/Contradictions: Certain technical specifications and descriptions appear to be inconsistent or contradictory, which could lead to confusion in understanding the architecture and functionality of the Amber Core. 3. Incomplete/Unclear Sections: Some sections of the document are either incomplete or not clearly explained, which may hinder the complete understanding of the core's architecture and operations. For a detailed report including specific instances of these issues and improvement suggestions, please let me know, and I will provide a comprehensive breakdown. Fig. 8: A GPT response example to the prompt in Figure 7."
    },
    {
      "heading": "Prompt:",
      "text": "Good, let's review Section 1, and please provide specific and comprehensive review results. The response format should comply with the previous requirements. GitHub repo. Its concise contents enable current LLMs like GPT-4 to review it at a time. According to Table II, we develop a prompt to request GPT-4 providing feedback on common defects. We use the prompt, as illustrated in Figure 7, to initiate the process of writing architecture specifications. Next, we upload the specification file selected for testing and ask GPT to summarize its findings. As illustrated in Figure 8, the LLM will then provide an overview of its analysis. This information can offer designers a quick glimpse into the results of the review. Subsequently, as depicted in Figure 9, we request GPT to provide us with detailed review results for each individual section of the specification document. Figure 10 displays the in-depth review results specifically for Section 1 of the Amber Core Specification. In general, we have observed that GPT-4 is adept at correctly identifying typographical errors. Furthermore, in more complex cases such as inconsistence or contradiction errors, as well as incomplete or unclear errors, GPT-4 is also capable of offering constructive advice. It can give the reasons why these types of errors exist and suggest ways to improve them. Nonetheless, our research has revealed that GPT-4 faces challenges in effectively dividing an archi-Response: Section 1 Review of the Amber Core Specification Typos: 1. \"seperate\" (in the description of Amber 25) should be \"separate.\" 2. \"Mhz\" (in the capability description of Amber 25) should be \"MHz.\" 3. \"that\" (in the performance comparison of Amber 25 and Amber 23) should be \"than.\" 4. \"has\" (in the paragraph about Linux kernel verification) should be \"have.\" 5. \"pipline\" (in the last sentence) should be \"pipeline.\" Inconsistencies/Contradictions: 1. The document states that the Amber 23 and Amber 25 cores are 100% software compatible, yet they have differing pipeline stages and cache architectures. This could potentially lead to different performance characteristics not addressed in the compatibility claim. Incomplete/Unclear Sections: 1. The description of the Wishbone interface is vague. More detailed specifications or references to the interface's documentation would improve clarity. 2. The performance metrics (DMIPS per MHz) are provided, but there's no baseline comparison or explanation of what these figures imply in practical terms. 3. The document mentions that the cores have been verified with a 2.4 Linux kernel but does not detail the extent or scope of this verification. 4. The information about the FPGA synthesis is incomplete. Details about the synthesis process, along with any challenges or optimizations, would provide a clearer picture of the implementation process. Improvement Suggestions: 1. Typos: Correct all typographical errors for accuracy and professionalism. 2. Inconsistencies/Contradictions: Clarify the software compatibility claim considering the different architectures of Amber 23 and Amber 25. Include any limitations or specific scenarios where this compatibility might not hold."
    },
    {
      "heading": "Incomplete/Unclear Sections:",
      "text": "• Expand the description of the Wishbone interface, possibly including a subsection dedicated to its architecture and how it interfaces with the Amber cores. • Provide a brief explanation or a reference to what DMIPS per MHz represents, helping readers unfamiliar with this metric understand the core's performance. • Detail the scope of the Linux kernel verification. Specify what tests were performed, any limitations encountered, and how these tests validate the core's functionality. • Elaborate on the FPGA synthesis process, including challenges faced, optimizations made, and why specific FPGA boards were chosen for testing. Fig. 10: A GPT response example to the prompt in Figure 9. tecture specification file into distinct sections. This limitation often results in the feedback provided for one section possibly originating from other sections of the document. To mitigate this problem, we propose to split the complete specification file into individual sections, and request GPT to review them sequentially. 2) Splitting and Reviewing File Section-by-Section: Similar to the first method, we begin by using prompts, as shown in Figure 7, to initiate the review of architecture specifications. Next, instead of uploading the entire architecture specification file for review, we submit only the file containing the contents of the individual section as an attachment. Simultaneously, we provide the prompt, as illustrated in Figure 11, directing Prompt: Please review the section 1 first, and give me specific and comprehensive reviewing results. The responding format should comply with the previous requirements. ( Note: attach the divided file that represents Section 1 of the architecture specification file) Fig. 11: An example prompt to review the split files. Though the response from GPT is similar to the Figure 10, the feedback is more likely to concentrate on the individual section. GPT to review each section. In this strategy, each review task for different sections is paired with its corresponding chapter file, ensuring that each section is reviewed in isolation and in context. The responses given by the GPT in this review process maintain a format similar to the outputs generated by the previous, more holistic review method. However, we have observed that the feedbacks are more likely to concentrate on each individual section. Furthermore, the GPT appears more effective in identifying a broader range of errors, which increases the number of available output items. The accurate and abundant review results enable designers to quickly but comprehensively locate the defects in their specification documents."
    },
    {
      "heading": "D. Feedbacks Evaluation",
      "text": "Not all feedback provided by the LLM is correct or useful. Therefore, it is essential to have strategies in place to evaluate the review results of architecture specifications effectively. The most intuitive method is to ask the designers to check the outputs of the LLM. This approach, compared to directly reviewing the architecture specifications themselves, is already more efficient, potentially saving significant time and effort. Nonetheless, an alternative approach involves training a new language model specifically for evaluating and filtering the review results provided by the LLMs. This specialized model could be designed to assess the relevance and accuracy of the LLM's feedback [67], thereby streamlining the review process and enhancing the reliability of the outcomes. We leave this part for future exploration."
    },
    {
      "heading": "VI. CONCLUSION",
      "text": "In this paper, we propose a novel framework for utilizing LLMs to generate and review architecture specifications. We defined architecture specifications, categorized them into clear levels, and compiled a corresponding dataset. Our approach focuses on two primary applications of LLMs: firstly, in generating architecture specifications, including assistance in writing and converting RTL code into specifications, and secondly, in the review of these specifications. This innovative methodology signifies a transformative step in architecture specification development, offering a path toward more efficient, accurate, and streamlined processes in chip design."
    }
  ]
}