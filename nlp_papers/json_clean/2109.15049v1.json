{
  "paperid": "2109.15049v1",
  "title": "Quantum Identity-Based Encryption from the Learning with Errors Problem",
  "authors": [
    "Wenhua Gao",
    "Li Yang",
    "Daode Zhang",
    "Xia Liu",
    "S Agrawal",
    "D Boneh",
    "X Boyen",
    "M Ajtai",
    "J Alwen",
    "C Peikert"
  ],
  "year": 2024,
  "abstract": "In order to prevent eavesdropping and tampering, the network security protocols use a handshake with an asymmetric cipher to establish a session-specific shared key with which further communication is encrypted using a symmetric cipher. The commonly used asymmetric algorithms include public key encryption, key exchange and identity-based encryption (IBE). However, the network security protocols based on classic identity-based encryption do not have perfect forward security. To solve the problem, we construct the first quantum IBE (QIBE) scheme based on the learning with errors problem, and prove that our scheme is fully secure under the random oracle. Moreover, we construct the quantum circuit of our QIBE scheme and give an estimate of the quantum resource of our circuit including the numbers of Hadamard gate, phase gate, T gate, CNOT gate and the total qubits used in the circuit, and conclude that the quantum resources required by our scheme increase linearly with the number of bits of the encrypted quantum plaintext. Our scheme exhibits the following advantages:â€¢ The classic key generation center (KGC) system still can be used for our QIBE scheme to generate and distribute the secret identity keys so that the cost can be reduced when the scheme is implemented. The reason why the classic KGC can be used is that the public and private keys are in the form of classic bits.â€¢ The network security protocols using a handshake with our QIBE scheme can provide perfect forward security. In our scheme, the ciphertext is transmitted in the form of a quantum state that is unknown to the adversary and therefore cannot be copied and stored. Thus, in the network security protocols based on our QIBE construction, the adversary cannot decrypt the previous quantum ciphertext to threat the previous session keys even if the identity secret key is threatened.",
  "sections": [
    {
      "heading": "INTRODUCTION",
      "text": "Identity-based cryptosystem is a public key cryptosystem first proposed by Shamir in 1984 [23], whose public key is calculated directly from the receiver's identity ğ‘–ğ‘‘ ğ‘… such as phone number, email address, or network address, and the corresponding secret key ğ‘ ğ‘˜ ğ‘… is calculated by the trusted key generation center (KGC) who owns the master public key mpk and master secret key msk. When the sender wants to send message ğ‘š to the receiver, the sender encrypts the message to get the ciphertext ğ‘ = Encrypt(mpk, ğ‘–ğ‘‘ ğ‘… , ğ‘š; ğ‘Ÿ ), where ğ‘Ÿ ( ) Li Yang yangli@iie.ac.cn is a random number. On receiving the ciphertext ğ‘, the receiver can decrypt and get the message ğ‘š = Decrypt(ğ‘ ğ‘˜ ğ‘… , ğ‘). Compared with cryptographic systems based on public key infrastructure (PKI), identity-based cryptosystems avoid the high cost of storing and managing public key certificates, simplify the management process of public keys, and reduce the pressure on the system. Therefore, identity-based cryptosystems have been widely developed and applied. The first practical identity-based encryption (IBE) scheme was proposed by Boneh et al. [6] in 2001, which was followed by numerous other classic IBE schemes. These classic identity-based encryption (IBE) schemes can be mainly divided into three categoreies: IBE schemes based on elliptic curve bilinear mapping [5,6,26], IBE schemes based on quadratic residue [7,10,16,17], and IBE schemes based on lattices [1,8,14,32,33]. With the development of quantum computers and quantum algorithms, especially the proposal of Shor algorithm [24], the security of IBE schemes based on elliptic curve bilinear pair and quadratic residue have been seriously threatened. Since there is no quantum algorithm that can solve lattice-based difficult problems, the design and research of lattice-based IBE schemes have become the research hotspot of cryptographers.  There are many applications of IBE such as constructing network security protocol (Chinese SSL VPN technology specification [9]). In the security protocol based on IBE, the receiver will send their identity ğ‘–ğ‘‘ ğ‘… and mpk to the sender, and the sender chooses a ğ‘ ğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›ğ¾ğ‘’ğ‘¦ and sends its ciphertext to the receiver. Then the receiver decrypts the ciphertext to obtain the ğ‘ ğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›ğ¾ğ‘’ğ‘¦. After that, both of them can own this secret key ğ‘ ğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›ğ¾ğ‘’ğ‘¦ with which further communication is encrypted using a symmetric cipher. The above process is briefly described in Figure 1. A security protocol is said to provide perfect forward secrecy [25] if the compromise of long-term keys does not compromise past session keys that have arXiv:2109.15049v1 [cs.CR] 26 Sep 2021 been established before the compromise of the long-term key. In the security protocol based on classic IBE, all session keys and their ciphertexts are in the form of classic bits. A patient attacker can capture conversations to store the ciphertexts of session keys whose confidentiality is protected by the secret identity key (which is called the long-term key) and wait until the long-term key is threatened. Once the patient attacker gets the long-term key, they can decrypt the ciphertext of all previous session keys. In a word, all encrypted communications and sessions recorded in the past can be retrieved. Therefore, the security protocol based on classic IBE does not have perfect forward security. To solve this problem, considering that an adversary cannot replicate an unknown quantum state [27], we construct an quantum identity-based encryption (QIBE) scheme based on learning with errors problem. In our QIBE scheme, the ciphertext is transmitted in the form of a quantum state that is unknown to the adversary, and the ciphertext of session keys can not be copied. Then, in the security protocol based on our QIBE construction, even if the secret identity key is threatened, the adversary does not have the previous ciphertexts of session keys to decrypt so that they can not threat the security of the previous session keys. Therefore, the security protocol based on our QIBE construction has perfect forward security."
    },
    {
      "heading": "Our Contributions",
      "text": "In this work, we give the definition of identity-based quantum encryption and construct the first QIBE scheme based on the proposed classic identity-based encryption scheme [14], and proved that our scheme is fully secure under the random oracle. In our scheme, the Setup and KeyGen algorithms are classic algorithms and then the public and private keys are classic bits. Thus the classic key generation center (KGC) system still can be used for our QIBE scheme to generate and distribute the secret identity keys so that the cost can be reduced when the scheme is implemented. In our scheme, the ciphertext is transmitted in the form of a quantum state that is unknown to the adversary and cannot be copied and stored. Therefore, in the network security protocols using a handshake with our QIBE scheme, if the identity private key is threatened, the adversary cannot decrypt the previous quantum ciphertext state to threat the previous session keys. Therefore, the network security protocol based on our QIBE can have perfect forward security compared to the network security protocol based on the classic IBE. we construct the quantum circuit of our QIBE scheme and give an estimate of the quantum resource of our circuit including the numbers of Hadamard gate, phase gate, T gate, CNOT gate and the total qubits used in the circuit, and conclude that the quantum resources required by our scheme increase linearly with the number of bits of the encrypted quantum plaintext."
    },
    {
      "heading": "Outline of the paper",
      "text": "The remainder of this paper is organised as follows: Section 2 describes the basic notation and previous work on quantum circuit, and basic knowledge and definitions of classic IBE and lattices. Section 3 gives the definition of QIBE, describes the concrete construction of our scheme, analyzes the correctness of our scheme and gives its security proof, and analyzes the forward security of the network protocol based on our scheme. Section 4 constructs the specific quantum circuit of our QIBE scheme, and estimates the quantum resources needed. Section 5 summarises our work and presents directions for future work."
    },
    {
      "heading": "PRELIMINARIES",
      "text": "The basic quantum gate involved in this study includes the singlequbit gate the NOT gate shown in Figure 2.(ğ‘), double-qubit gates the CNOT gate shown in Figure 2.(ğ‘) and a variant of it shown in 2.(ğ‘) which can be obtained by a CNOT gate and two NOT gates, and three-qubit gate the Toffoli gate shown in Figure 2.(ğ‘‘)."
    },
    {
      "heading": "Figure 2: The Basic quantum gates",
      "text": "The notations involved in this study is shown in Figure 3, where (ğ‘) means the input is multiple qubits and the black triangles in (ğ‘) represents the main output registers."
    },
    {
      "heading": "Figure 3: The involved notations",
      "text": "We use bold lowercase letters to denote vectors. On the basis of the above, the ğ‘™-controlled NOT gate and the combination of multi-CNOT gates involved in this study are shown in Figure 4, where (ğ‘) is the ğ‘™-controlled NOT gate and its simplified form, which can be decomposed into 2ğ‘™ -3 Toffoli gates, and (ğ‘) is a combination of ğ‘™ CNOT gates and its simplified form. In addition, the simplified circuit of controlled copying the classical constant ğ‘‘ which can be decomposed into ğ‘™ bit binary string t âˆˆ {0, 1} ğ‘™ is shown in Figure 5. This circuit is implemented by performing CNOT operation or not according the value of each bit of t is one or zero. If ğ‘¡ ğ‘– = 1(ğ‘– = 1, ..., ğ‘™), take |ğ‘˜ 1 âŸ© as control bit and the ğ‘–-th bit of |0âŸ© as target bit to perform CNOT operation; If ğ‘¡ ğ‘– = 0, do not any operation to the ğ‘–-th bit of |0âŸ©. Finally, the output will produce (|ğ‘˜ 1 âŸ©, |ğ‘‘ * ğ‘˜ 1 âŸ©). In general, zero and one in t are approximately uniform, so this circuit requires approximately ğ‘™/2 CNOT gates."
    },
    {
      "heading": "Quantum Circuit",
      "text": "The transformation of quantum states is realized by a series of unitary operations, which can be decomposed into many elementary gate operations. Therefore, the realization of quantum circuits is also accomplished by a series of gate operations. In this section, we describe the proposed quantum arithmatic operations including addition and subtraction, controlled addition, modular addition and comparison, and their corresponding quantum resources required including the numbers of CNOT gate, the Toffoli gate and the total qubit. All these works lay the foundation for the quantum circuit realization of our QIBE. To simplify the description, we show the simplified form of these arithmatic operations here and their specific implementation process can be seen in corresponding reference. â€¢ Addition and subtraction : Cuccaro et al. proposed a quantum addition circuit [11]. The quantum addition achieves the addition of two registers, that is To prevent overflows caused by carry, the second register (initially loaded in state |ğ‘âŸ©) should be sufficiently large, i.e. if both ğ‘ and ğ‘ are encoded on ğ‘™ qubits, the second register should be of size ğ‘™ + 1. In the addition network, the last carry is the most significant bit of the result and is written in the ğ‘™ + 1-th qubit of the second register. Because of the reversibility of unitary operations, by reversing the network of addition, i.e., apply each gate of the network in the reversed order, the subtraction network will be obtained. The simplified form of the addition and subtraction network are shown in (ğ‘) and (ğ‘) of Figure 6. In this paper, a network with a bar on the left side represents the reversed sequence of elementary gates embedded in the same network with the bar on the right side. On the subtraction network, with the input (|ğ‘âŸ©, |ğ‘âŸ©), the output will produce (|ğ‘âŸ©, |ğ‘ -ğ‘âŸ©) when ğ‘ â‰¥ ğ‘. When ğ‘ < ğ‘, the output is When ğ‘ < ğ‘, the significant qubit, the ğ‘™ + 1-th qubit of the second register, which indicates whether or not an overflow occurred in the subtraction, will always contains 1. To calculate the addition or subtraction of two ğ‘™-bit length inputs, a total of 2ğ‘™ Toffoli gates, 4ğ‘™ + 1 CNOT gates, and a total of 2ğ‘™ + 2-qubit are required for the addition or subtraction network. â€¢ Addition module ğ‘ : Liu et al. [34] improved Roetteler's [22] quantum modular addition circuit, reducing the number of quantum gates required. This quantum network effects |ğ‘, ğ‘âŸ© â†’ |ğ‘, (ğ‘ + ğ‘) mod ğ‘âŸ©, where 0 â‰¤ ğ‘, ğ‘ < ğ‘. The simplified form of the addition module ğ‘ network are shown in (ğ‘) of Figure 7. The modular subtraction can be obtained by reversing modular addition circuit and its bar is on the left hand. To calculate the addition or subtraction module ğ‘ of two âŒŠlog ğ‘ + 1âŒ‹-bit length inputs, a total of 8âŒŠlog ğ‘ + 1âŒ‹ Toffoli gates, 13âŒŠlog ğ‘ + 1âŒ‹ + 6 CNOT gates and 3âŒŠlog ğ‘ + 1âŒ‹ + 3-qubit are required for this addition or subtraction module ğ‘ network. â€¢ Comparison : Markov et al. construct a quantum comparison circuit by comparing |ğ‘âŸ© and |ğ‘âŸ© by whether the highest bit of |ğ‘ -ğ‘âŸ© is |0âŸ© or |1âŸ© [18] . This circuit is obtained by modifying the the previous subtraction circuit so that it outputs only the highest bit of |ğ‘ -ğ‘âŸ©. The comparison network achieves the comparison of two registers, that is The simplified form of the quantum comparison network is shown in Figure 7.(ğ‘). To comparing two ğ‘™-bit length inputs |ğ‘âŸ© and |ğ‘âŸ©, a total of 2ğ‘™ Toffoli gates, 4ğ‘™ + 1 CNOT gates, and 2ğ‘™ + 2 qubits are required for the comparison network."
    },
    {
      "heading": "Lattices",
      "text": "Let ğ‘‹ and ğ‘Œ be two random variables over some finite set ğ‘† ğ‘‹ , ğ‘† ğ‘Œ , respectively. The statistical distance Î”(ğ‘‹, ğ‘Œ ) between ğ‘‹ and ğ‘Œ is defined as For integer ğ‘ â‰¥ 2, Z ğ‘ denotes the quotient ring of integer modulo ğ‘. We use bold capital letters to denote matrices, such as A, B, and bold lowercase letters to denote vectors, such as x, y. We denote the ğ‘—-th row of a matrix R by r ğ‘— and its ğ‘–-th column by r ğ‘– . Moreover, we denote the ğ‘—-th element of a vector m by ğ‘š ğ‘— . The notations A âŠ¤ denote the transpose of the matrix A. Specially, we use i to denote a vector that each element is one, i.e Let S be a set of vectors that order, and âˆ¥Sâˆ¥ to denote the length of the longest vector in S. For positive integers ğ‘, ğ‘›, ğ‘š with ğ‘ prime, and a matrix A âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ , the ğ‘š-dimensional integer lattices are defined as: ğ‘ , the set of syndromes is defined as (Î›) , where x âˆˆ Î›. For simplicity, ğœŒ ğ‘ ,0 and D Î›,ğ‘ ,0 are abbreviated as ğœŒ ğ‘  and D Î›,ğ‘  , respectively. Lemma 2.1. Let ğ‘, ğ‘›, ğ‘š be positive integers with ğ‘ â‰¥ 2 and ğ‘ prime. There exists PPT algorithms such that â€¢ ([2, 3]): TrapGen(1 ğ‘› , 1 ğ‘š , ğ‘) a randomized algorithm that, when ğ‘š â‰¥ 6ğ‘›âŒˆlog ğ‘âŒ‰, outputs a pair (A, âˆšï¸ ğ‘› log ğ‘) with overwhelming probability. â€¢ ( [14]): SampleD(A, T A , u, ğœ) a randomized algorithm that, given a full rank matrix The following lemmas are used to manipulate and obtain meaningful bounds on discrete Gaussian vectors. Lemma 2.2. (Adopted from [14], Lem.5.2). Let ğ‘›, ğ‘š, ğ‘ be positive integers such that ğ‘š â‰¥ 2ğ‘› log ğ‘ and ğ‘ a prime. Let ğœ be any positive real such that ğœ â‰¥ âˆšï¸ ğ‘› + log ğ‘š. Then for all but 2 -Î© (ğ‘›) fraction of A âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ , we have that the distribution of u = Ar mod ğ‘ for r â† ğ· Z ğ‘š ,ğœ is 2 -Î© (ğ‘›) -close to uniform distribution over Z ğ‘› ğ‘ . Furthermore, for a fixed u âˆˆ Z ğ‘› ğ‘ , the conditional distribution of r â† ğ· Z ğ‘š ,ğœ , given Ar = u mod ğ‘ is D Î› u ğ‘ (A),ğœ . The security of our construction is based on the learning with errors (LWE) hardness assumption. The LWE problem is a hard problem based on lattices defined by Regev [21], which is stated below: given an input (A, d), where A âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ for any ğ‘š = ğ‘ğ‘œğ‘™ğ‘¦ (ğ‘›) and integer ğ‘ â‰¥ 2 is prime and d âˆˆ Z ğ‘š ğ‘ is either of the form d = (A âŠ¤ s + e) mod ğ‘ for s âˆˆ Z ğ‘› ğ‘ and e âˆˆ D Z ğ‘š ,ğœ or is uniformly random (and independent of A), distinguish which is the case, with non-negligible advantage. Regev proved that LWE problem is as hard as approximating standard lattice problems in the worst case using a quantum algorithm."
    },
    {
      "heading": "Classic Identity-Based Encryption",
      "text": "A classic IBE scheme consists of the following four algorithms: 1 ğœ† ) â†’ (mpk, msk). The key generation algorithm takes in a security parameter 1 ğœ† as input. It outputs master public key mpk and a master secret key msk. â€¢ Extract(mpk, msk, ğ‘–ğ‘‘) â†’ ğ‘ ğ‘˜ ğ‘–ğ‘‘ . The key extraction algorithm takes master public key mpk, master secret key msk, and identity ğ‘–ğ‘‘ as input. It outputs ğ‘ ğ‘˜ ğ‘–ğ‘‘ as the secret key. â€¢ Encrypt(mpk, ğ‘–ğ‘‘, M; ğ‘Ÿ ) â†’ ğ‘. The encryption algorithm takes in public parameters mpk, identities ğ‘–ğ‘‘, and a message M as input. It outputs a ciphertext ğ‘. â€¢ Decrypt(ğ‘ ğ‘˜ ğ‘–ğ‘‘ , ğ‘) â†’ M. The decryption algorithm takes in the secret key ğ‘ ğ‘˜ ğ‘–ğ‘‘ and a ciphertext ğ‘, as input. It outputs a message M. Correctness. For all (mpk, msk) Security. The security game is defined by the following experiment, played by a challenger and an adversary A: (1) The challenger runs KeyGen to generate (mpk, msk). It gives mpk to the adversary A. (2) The adversary A adaptively requests keys for any identity ğ‘–ğ‘‘ ğ‘– of its choice. The challenger responds with the corresponding secret key ğ‘ ğ‘˜ ğ‘–ğ‘‘ ğ‘– , which it generates by running Extract(mpk, msk, ğ‘–ğ‘‘ ğ‘– ). (3) The adversary A submits two messages M 0 and M 1 of equal length and a challenge identity ğ‘–ğ‘‘ * with the restriction that ğ‘–ğ‘‘ * is not equal to any identity requested in the previous phase. The challenger picks ğ›½ $ â† {0, 1}, and encrypts M ğ›½ under ğ‘–ğ‘‘ * by running the encryption algorithm. It sends the ciphertext to the adversary A. (4) A continues to issue key queries for any identity ğ‘–ğ‘‘ ğ‘– as in step (2) with the restriction that ğ‘–ğ‘‘ ğ‘– â‰  ğ‘–ğ‘‘ * . (5) The adversary A outputs a guess ğ›½ â€² for ğ›½."
    },
    {
      "heading": "The advantage Adv IBE",
      "text": "A (ğœ†) of an adversary A is defined to be ğ·ğ‘’ ğ‘“ ğ‘–ğ‘›ğ‘–ğ‘¡ğ‘–ğ‘œğ‘› 1. An IBE scheme is fully secure if for all probabilistic polynomial-time adversaries A, Adv IBE A (ğœ†) is a negligible function in ğœ†."
    },
    {
      "heading": "QUANTUM IBE 3.1 Definition of QIBE",
      "text": "In this section, we give the definition of QIBE and classify QIBE. Definition 2: If one or more elements of the quadruple (KeyGen, Extract, Encrypt, Decrypt) of the IBE scheme are quantum process, then we call the IBE scheme quantum IBE, namely QIBE scheme. It is analogous to the analysis and classification of quantum public key encryption [28] and quantum symmetric-encryption scheme [31], each element of the quadruple can be classic or quantum, so there may be sixteen types of QIBE schemes."
    },
    {
      "heading": "Our Construction",
      "text": "In this section, we utilise the proposed classic IBE scheme [14] to construct a kind of QIBE scheme based on quantum trapdoor one-way transformation [35], whose directly encrypted message is a multi-bit quantum state. In our QIBE scheme, the algorithms KeyGen and Extract are classic process and the algorithms Encrypt and Decrypt are quantum process. To make it easier to distinguish between classic IBE and QIBE, we denote that our scheme consists of four algorithms QIBE = (QKeyGen, QExtract, QEncrypt, QDecrypt). In the scheme, let integer parameters ğ‘› = O (ğœ†), ğ‘š = O (ğ‘›), ğœ = O (ğ‘› 0.5 ), ğ‘ = O (ğ‘š 3.5 ) according to [14], where ğœ† is a security parameter. â€¢QKeyGen : ( 1 â˜…Step 3: Take above result as the input of quantum absolute value circuit which will be described in section 4. 1, we can get âˆ‘ï¸ m ğ›¼ m abs x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘y mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ â€¢ i . â˜…Step 4: Take above result, âŒŠ ğ‘ 4 âŒ‹ and |0âŸ© as the inputs of quantum comparison network, we can get âˆ‘ï¸ m ğ›¼ m abs âŒŠx + ğ‘ 2 âŒ‹m mod ğ‘y mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ â€¢ i |mâŸ© . Next, we will unentangle the first and the second register of this quantum state. â˜…Step 5: Take the first register of above result as the input of the inverse of quantum absolute value circuit, we can get âˆ‘ï¸ m ğ›¼ m âŒŠx + ğ‘ 2 âŒ‹m mod ğ‘y mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ â€¢ i |mâŸ© . â˜…Step 6: Take âŒŠ ğ‘ 2 âŒ‹ and the first register of above result as quantum addition network's inputs, we can get âˆ‘ï¸ m ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘y mod ğ‘ |mâŸ© . â˜…Step 7: Take |yâŸ© and the first register of above result as the quantum adder modulo ğ‘ network's inputs, we can get âˆ‘ï¸ m ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘ |mâŸ© . â˜…Step 8: Take each bit of the second register of above result as the control bit and |0âŸ© as the input, by the controlled copying classic constant âŒŠ ğ‘ 2 âŒ‹ circuit, we can get âˆ‘ï¸ m ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘ |mâŸ© âŒŠ ğ‘ 2 âŒ‹m . â˜…Step 9: Take the first register and the third register of above result as the inputs of the inverse of quantum adder modulo ğ‘ network, we can get âˆ‘ï¸ m ğ›¼ m |xâŸ© |mâŸ© âŒŠ ğ‘ 2 âŒ‹m . Then, we need to unentangle the second and the third register of this result. â˜…Step 10: Take each bit of the second register of above result as the control bit, and the third register of above result as the input of controlled copying classic constant âŒŠ ğ‘ 2 âŒ‹ circuit, that's, by performing the inverse operation of step 8, we can get âˆ‘ï¸ m ğ›¼ m |mâŸ© |0âŸ© . Then, quantum state m ğ›¼ m |mâŸ© is no longer entangled with other registers and the decryption process is complete. (3) In a word, QDecrypt(ğ‘–ğ‘‘, mpk, R, (c 1 , |ğœ“ âŸ©)) â†’ m ğ›¼ m |mâŸ©."
    },
    {
      "heading": "Correctness",
      "text": "Consider a ciphertext"
    },
    {
      "heading": "Security proof",
      "text": "Theorem 3.1. The above IBE scheme QIBE is fully secure in the random oracle model assuming the hardness of LWE. Namely, for any classical PPT adversary A making at most ğ‘„ H random oracle queries to H and ğ‘„ ID secret key queries, there exists a classical PPT algorithm B such that (1) Proof (of Theorem 3.1.) Without loss of generality, we make some simplifying assumptions on A. First, we assume that whenever A queries a secret key or asks for a challenge ciphertext, the corresponding ğ‘–ğ‘‘ has already been queried to the random oracle H. Second, we assume that A makes the same query for the same random oracle at most once. Third, we assume that A does not repeat secret key queries for the same identity more than once. We show the security of the scheme via the following games. In each game, we define ğ‘‹ ğ‘– as the event that the adversary A wins in Game i . Game 0 : This is the real security game. At the beginning of the game, (A, T A ) â† TrapGen(1 ğ‘› , 1 ğ‘š , ğ‘) is run and the adversary A is given A. The challenger then samples ğ›½ â† {0, 1} and keeps it secret. During the game, A may make random oracle queries, secret key queries, and the challenge query. These queries are handled as follows: â€¢Hash queries: When A makes a random oracle query to H on ğ‘–ğ‘‘, the challenger chooses a random matrix U ğ‘–ğ‘‘ â† Z ğ‘› ğ‘ and locally stores the tuple (ğ‘–ğ‘‘, U ğ‘–ğ‘‘ , âŠ¥), and returns U ğ‘–ğ‘‘ to A. â€¢Secret key queries: When the adversary A queries a secret key for ğ‘–ğ‘‘, the challenger uses the algorithm SampleD which takes A, T ğ´ , ğœ, U ğ‘–ğ‘‘ as input to compute R ğ‘–ğ‘‘ and returns R ğ‘–ğ‘‘ to A. At the end of the game, A outputs a guess ğ›½ â€² for ğ›½. Finally, the challenger outputs ğ›½ â€² . By definition, we have Game 1 : In this game, we change the way the random oracle queries to H are answered. When A queries the random oracle H on ğ‘–ğ‘‘, the challenger generates a pair (U ğ‘–ğ‘‘ , R ğ‘–ğ‘‘ ) by first sampling r ğ‘– ğ‘–ğ‘‘ $ â† D Z ğ‘š ,ğœ to construct R ğ‘–ğ‘‘ and setting U ğ‘–ğ‘‘ = A â€¢ R ğ‘–ğ‘‘ . Then it locally stores the tuple (ğ‘–ğ‘‘, U ğ‘–ğ‘‘ , âŠ¥), and returns U ğ‘–ğ‘‘ to A. Here, we remark that when A makes a secret key query for ğ‘–ğ‘‘, the challenger uses the algorithm SampleD which takes A, T ğ´ , ğœ, U ğ‘–ğ‘‘ as input to compute R â€² ğ‘–ğ‘‘ and returns R â€² ğ‘–ğ‘‘ to A. Note that R â€² ğ‘–ğ‘‘ is independent from R ğ‘–ğ‘‘ that was generated in the simulation of the random oracle H on input ğ‘–ğ‘‘. Due to Lemma 2.2, the distribution of U ğ‘–ğ‘‘ in Game 1 is ğ‘› â€¢ 2 -Î© (ğ‘›) -close to that of Game 0 except for 2 -Î© (ğ‘›) fraction of A since we choose ğœ > âˆšï¸ ğ‘› + log ğ‘š. Therefore, we have Game 2 : In this game, we change the way secret key queries are answered. By the end of this game, the challenger will no longer require the trapdoor T A to generate the secret keys. When A queries the random oracle on ğ‘–ğ‘‘, the challenger generates a pair (U ğ‘–ğ‘‘ , R ğ‘–ğ‘‘ ) as in the previous game. Then it locally stores the tuple (ğ‘–ğ‘‘, U ğ‘–ğ‘‘ , R ğ‘–ğ‘‘ ) and returns U ğ‘–ğ‘‘ to A. When A queries a secret key for ğ‘–ğ‘‘, the challenger retrieves the unique tuple (ğ‘–ğ‘‘, U ğ‘–ğ‘‘ , R ğ‘–ğ‘‘ ) from local storage and returns R ğ‘–ğ‘‘ . For any fixed U ğ‘–ğ‘‘ , let R ğ‘–ğ‘‘,1 and R ğ‘–ğ‘‘,2 be random variables that are distributed according to the distributions of ğ‘ ğ‘˜ ğ‘–ğ‘‘ conditioning on H(ğ‘–ğ‘‘) = U ğ‘–ğ‘‘ in Game 1 and Game 2 , respectively. Due to Lemma 2.1, we have Game 3 : In this game, we change the way the matrix A is generated."
    },
    {
      "heading": "Concretely, the challenger chooses",
      "text": "without generating the associated trapdoor T A . By Lemma 2.1, this makes only 2 -Î© (ğ‘›)statistical difference. Since the challenger can answer all the secret key queries without the trapdoor due to the change we made in the previous game, the view of A is altered only by 2 -Î© (ğ‘›) . Therefore, we have â€¢Hash queries: on A's ğ‘—th distinct queries ğ‘–ğ‘‘ ğ‘— to H, the challenger does the following: if ğ‘— = ğ‘– * , then locally stores the tuple (ğ‘–ğ‘‘ ğ‘— , U, âŠ¥) and returns U to A. Otherwise for ğ‘— â‰  ğ‘– * , the challenger selects R ğ‘–ğ‘‘ ğ‘— and computes U ğ‘–ğ‘‘ ğ‘— = AR ğ‘–ğ‘‘ ğ‘— , then locally stores the tuple (ğ‘–ğ‘‘ ğ‘— , U ğ‘–ğ‘‘ ğ‘— , R ğ‘–ğ‘‘ ğ‘— ) and returns U ğ‘–ğ‘‘ ğ‘— to A. â€¢Challenge ciphertext: when A produces a challenge identity ğ‘–ğ‘‘ * (distinct from all its secret key queries) and messages m 0 ğ›¼ m 0 |m 0 âŸ©, m 1 ğ›¼ m 1 |m 1 âŸ©, assume without loss of generality that A already queried H on ğ‘–ğ‘‘ * . If ğ‘–ğ‘‘ * â‰  ğ‘–ğ‘‘ ğ‘– * , i.e., if the tuple (ğ‘–ğ‘‘ ğ‘– * , U, âŠ¥) is not in local storage, then the challenger ignores the output of A and aborts the game (we denote this event as abort). Otherwise, i.e., the abort does not happen(we denote this event as abort), the chal- Conditioned on the challenger not aborting, we claim that the view it provides to A in Game 4 is statistically close to that in Game 3 . Therefore, we have By a standard argument, the probability that the challenger does not abort during the simulation is 1 ğ‘„ H (this is proved by considering a game in which the challenger can answer all secret key queries, so that the value of ğ‘– * is perfectly hidden from A). Therefore, we have Game 5 : In this game, we change the way the challenge ciphertext is created. â€¢Challenge ciphertext: when A produces a challenge identity ğ‘–ğ‘‘ * (distinct from all its secret key queries) and messages m 0 ğ›¼ m 0 |m 0 âŸ©, m 1 ğ›¼ m 1 |m 1 âŸ©, assume without loss of generality that A already queried H on ğ‘–ğ‘‘ * . If ğ‘–ğ‘‘ * â‰  ğ‘–ğ‘‘ ğ‘– , i.e., if the tuple (ğ‘–ğ‘‘ ğ‘– , U, âŠ¥) is not in local storage, then the challenger ignores the output of A and aborts the game (we denote this event as abort). Otherwise, i.e., the abort does not happen (we denote this event as abort), the challenger picks ğ›½ Note that c 1 , x is statistically close to the uniform distribution over According to equations from ( 6) to (9), we can get Then because abort is independent of ğ‘‹ 3 , we can get Finally, according to equations from (2) to ( 5) together with equation (10), we can get equation (1)."
    },
    {
      "heading": "Security Network Protocols with Our QIBE",
      "text": "A fundamental fact in quantum information theory is that unknown or random quantum states cannot be cloned [27]. The quantum ciphertext state is For the adversary, the probability amplitude and the corresponding basis state of the ciphertext quantum states |ğœ“ âŸ© is unknown, so they cannot try to copy it during its transmission. Then in the handshake protocol based on our QIBE, an attacker cannot copy and store the quantum ciphertext states of session keys whose confidentiality is protected by the secret identity key (which is called the long-term key). Thus, although the attacker gets the long-term key, they has no the quantum ciphertext of previous session keys to decrypt and cannot threat the security of the previous session key. In a word, all encrypted communications and sessions happened in the past cannot be retrieved. Therefore, the security protocol based on our QIBE has perfect forward security, which cannot achieve by the security protocol based on classic IBE."
    },
    {
      "heading": "QUANTUM CIRCUIT REALIZATION 4.1 Quantum Circuit",
      "text": "In order to analyze the realizability of our scheme in quantum circuit construction and estimate the quantum resources required by the scheme, in this section we give the specific quantum circuit implementation of our QIBE scheme. The algorithms QKeyGen and QExtract of QIBE are classic algorithms and can be implemented with classic circuits. Thus we show the quantum circuit implementation of algorithms QEncrypt and QDecrypt of QIBE here. â€¢ Quantum circuit of the algorithm QEncrypt: To simplify the description, we present the encryption quantum circuit of |ğ‘š ğ‘– âŸ©, and the encryption quantum circuit of m ğ›¼ m |mâŸ© is its ğ‘›-fold expansion. The quantum circuit implementation of the algorithm QEncrypt is shown in Figure 8. In the first two steps of the encryption process, through the quantum controlled addition network and the quantum addition module ğ‘ network, we can get |ğ‘š ğ‘– âŸ©|(ğ‘¥ ğ‘– + âŒŠ â€¢ Quantum circuit of the algorithm QDecrypt: The algorithm QDecrypt extracts m ğ›¼ m |mâŸ© from the ciphertext quantum state. To simplify the description, we present the decryption quantum circuit of the ciphertext whose corresponding plaintext is |ğ‘š ğ‘– âŸ©, and the decryption quantum circuit of the ciphertext whose corresponding plaintext is m ğ›¼ m |mâŸ© is its ğ‘›-fold expansion. According to Appendix, we can know that if abs ğ‘¥ ğ‘– + âŒŠ ğ‘ 2 âŒ‹ğ‘š ğ‘– mod ğ‘ -ğ‘¦ ğ‘– mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ < âŒŠ ğ‘ 4 âŒ‹, |ğ‘š ğ‘– âŸ© = |1âŸ©; otherwise, |ğ‘š ğ‘– âŸ© = |0âŸ©. Thus, before constructing the decryption quantum circuit, we need to construct the quantum absolute value circuit which implements the step 3 and step 5 of the QDecrypt process. The analysis and construction process of the quantum absolute value circuit is as follows: Denote |ğœ‘âŸ© = ğ‘¥ ğ‘– + âŒŠ ğ‘ 2 âŒ‹ğ‘š ğ‘– mod ğ‘ -ğ‘¦ ğ‘– mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ , to prevent overflow when storing |ğœ‘âŸ©, the size of the register to store |ğœ‘âŸ© should be âŒŠlog ğ‘ + 1âŒ‹ + 1. Denote ğ‘” ğ‘— ( ğ‘— = 1, ..., âŒŠlog ğ‘ + 1âŒ‹ + 1) as the ğ‘—-th bit of |ğœ‘âŸ© and ğ‘” â€² ğ‘— ( ğ‘— = 1, ..., âŒŠlog ğ‘ + 1âŒ‹ + 1) as the ğ‘—-th bit of |abs (ğœ‘)âŸ©, where ğ‘” âŒŠlog ğ‘+1âŒ‹+1 and ğ‘” â€² âŒŠlog ğ‘+1âŒ‹+1 are the most significant bits of |ğœ‘âŸ© and |abs (ğœ‘)âŸ©, respectively. Denote \"(â€¢)\" is to reverse \"(â€¢)\" bit by bit, for example 101 = |010âŸ©. It is clear that if |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© = 0, |abs (ğœ‘)âŸ© = |ğœ‘âŸ©; if |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© = 1, then |abs (ğœ‘)âŸ© can be also expressed as bellow: and we can also know that |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© = 1 in this situation from this result. Thus, we can conclude that |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© = |ğ‘” â€² âŒŠlog ğ‘+1âŒ‹+1 âŸ©. For constructing the quantum absolute value circuit to calculate |abs (ğœ‘)âŸ© from |ğœ‘âŸ©, we use |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© as the control bit. If ğ‘” âŒŠlog ğ‘+1âŒ‹+1 = |1âŸ©, the circuit perform the operation of bitwise negation and adding 1 on the result; otherwise, no useful operations are performed on the input. Then, we give the concrete quantum absolute value circuit and its simplified form shown in Figure 9, which realizes"
    },
    {
      "heading": "|ğœ‘âŸ© â†’ |abs (ğœ‘)âŸ©",
      "text": "To calculate the absolute value of |ğœ‘âŸ© which is âŒŠlog ğ‘ + 1âŒ‹ + 1qubits, a total of 2âŒŠlog ğ‘ + 1âŒ‹ + 2 Toffoli gates, 5âŒŠlog ğ‘ + 1âŒ‹ + 9 CNOT gates, and a total of 2âŒŠlog ğ‘ + 1âŒ‹ + 2 qubits are required for this quantum absolute value network. Then, the quantum circuit implementation of the algorithm QDecrypt is shown in Figure 10, which marks the steps 1 to 10 in the process of the quantum decryption algorithm QDecrypt in Section 4.1."
    },
    {
      "heading": "Quantum resource estimation",
      "text": "To measure the complexity of a quantum circuit, we should consider the number of quantum gates in the circuit and the total number of qubits used. In quantum circuits, it is meaningful to estimate the number of Hadamard gates, phase gate, CNOT gates and especially T gates. On the one hand, any unitary operator can be expressed exactly using single qubit and CNOT gates [12], and single qubit operation can be approximated to arbitrary accuracy using the Hadamard gate, phase gate and T gate [19]. On the other hand, the structure of the fault-tolerant T gate is non-transverse and requires more complex and expensive technology to achieve it [4,19]. According to the trues that one âŒŠlog ğ‘ + 1âŒ‹-controlled NOT gate can be decomposed into 2âŒŠlog ğ‘ + 1âŒ‹ -3 Toffoli gates, and one Toffoli gate can be broken down into two Hadamard gates, one phase gate, seven T gates and six CNOT gates [4], we estimate the quantum resources needed to encrypt the ğ‘›-qubit quantum state m ğ›¼ m |mâŸ© with the algorithm QEncrypt of QIBE, and decrypt the corresponding ciphertext with the algorithm QDecrypt of QIBE, including the numbers of Hadamard gate, phase gate, T gate, CNOT gate and the total qubits used, in which these gates constitute a universal quantum gate group. The quantum resources required by the quantum circuits of the encryption algorithm QEncrypt and the decryption algorithm QDecrypt are shown in the table 1. In order to save quantum resources, auxiliary bits can be reused according to the sequence of calculations in each circuit [15]. It can be seen from the table that the quantum resources required by our scheme increase linearly with the number of bits of the encrypted quantum plaintext."
    },
    {
      "heading": "CONCLUSION",
      "text": "In this paper, we proposed a kind of QIBE scheme based on the proposed classic IBE scheme [14], and proved that it is fully secure. We construct the quantum circuit of QEncrypt of our scheme. Moreover, to implement the quantum circuit of QDecrypt of our scheme, we construct a quantum absolute value circuit and then give the quantum circuit of QDecrypt based on it. We estimate the quantum resources required for the quantum circuit of our scheme, including the numbers of Hadamard gate, phase gate, T gate, CNOT gate and total qubits used, and conclude that the quantum resources required by our scheme increase linearly with the number of bits of the encrypted quantum plaintext. Our QIBE scheme is suitable for quantum computing environment can encrypt both quantum messages and classic messages, and the classic KGC can still be used for the generation and distribution of identity secret key so that the cost can be reduced when the quantum scheme is implemented. In our QIBE scheme, the ciphertexts are transmitted in the form of a quantum state that is unknown to the adversary and cannot be copied and stored due to the no-cloning theorem. Thus, in the network security protocol based on our QIBE construction, even if the long-term key is threatened, the adversary cannot decrypt the previous ciphertexts to threat the previous session keys. Therefore, our QIBE scheme can make the network security protocol based on it have perfect forward security. Our structure is one of the sixteen types of QIBE schemes described in section 3.1, and the other fifteen types of QIBE schemes are yet to be studied. Moreover, the security of our scheme is based on the classic difficulty problem assumption the LWE assumption. Compared with the rapid development of quantum public-key encryption schemes based on the basic principles of quantum mechanics [13,20,29,30,36], the design and research of the QIBE scheme based on the basic principles of quantum mechanics has a lot of room for development, which is also a very meaningful research direction."
    }
  ],
  "figures": [
    {
      "caption": "ğ‘ 2 âŒ‹ğ›¼ m |mâŸ© âŒŠ ğ‘ 2 âŒ‹m . â˜…Step 2 : 2 âŒ‹m) mod ğ‘ . â˜…Step 3 :ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹mğ‘ 2 âŒ‹ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹m 2 âŒ‹",
      "image_path": null
    },
    {
      "caption": "ğ‘ 2 âŒ‹ğ‘š 2 Figure 8 :",
      "image_path": null
    },
    {
      "caption": "Figure 10 :",
      "image_path": null
    }
  ],
  "equations": []
}