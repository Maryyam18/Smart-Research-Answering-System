{
  "paperid": "1502.07812v1",
  "title": "Anonymous HIBE with Short Ciphertexts: Full Security in Prime Order Groups *",
  "authors": [
    "Lee",
    "Hwan",
    "Dong",
    "Lee",
    "Abdalla",
    "Bellare",
    "Catalano",
    "Kiltz",
    "Kohno",
    "Lange",
    "Malone-Lee",
    "Neven",
    "Paillier",
    "Shi",
    "Abdalla",
    "Bellare",
    "Neven",
    "Agrawal",
    "Boneh",
    "Boyen",
    "Agrawal",
    "Boneh",
    "Boyen",
    "Boneh",
    "Boyen",
    "Boneh",
    "Boyen",
    "Boneh",
    "Boyen",
    "Goh",
    "Boneh",
    "Di Crescenzo",
    "Ostrovsky",
    "Persiano",
    "Boneh",
    "Franklin",
    "Boneh",
    "Franklin",
    "Boneh",
    "Hamburg",
    "Boneh",
    "Waters",
    "Boyen",
    "Waters",
    "Canetti",
    "Halevi",
    "Katz",
    "Canetti",
    "Halevi",
    "Katz",
    "De",
    "Iovino",
    "Persiano",
    "Cash",
    "Hofheinz",
    "Kiltz",
    "Peikert",
    "Chatterjee",
    "Sarkar",
    "Chen",
    "Lim",
    "Ling",
    "Wang",
    "Dodis",
    "Fazio",
    "Ducas",
    "Mandell",
    "Gentry",
    "Gentry",
    "Halevi",
    "Gentry",
    "Silverberg",
    "Goyal",
    "Pandey",
    "Sahai",
    "Waters",
    "Horwitz",
    "Lynn",
    "Katz",
    "Sahai",
    "Waters",
    "Lee",
    "Hoon",
    "Lewko",
    "Lewko",
    "Okamoto",
    "Sahai",
    "Takashima",
    "Waters",
    "Lewko",
    "Rouselakis",
    "Waters",
    "Lewko",
    "Waters",
    "Lewko",
    "Waters",
    "Lynn",
    "Okamoto",
    "Takashima",
    "Okamoto",
    "Takashima",
    "Okamoto",
    "Takashima",
    "Okamoto",
    "Takashima",
    "Jacob",
    "Schwartz",
    "Hong Seo",
    "Kobayashi",
    "Ohkubo",
    "Suzuki",
    "Shi",
    "Waters",
    "Shoup",
    "Waters",
    "Waters"
  ],
  "year": 2015,
  "abstract": "Anonymous Hierarchical Identity-Based Encryption (HIBE) is an extension of Identity-Based Encryption (IBE), and it provides not only a message hiding property but also an identity hiding property. Anonymous HIBE schemes can be applicable to anonymous communication systems and public key encryption systems with keyword searching. However, previous anonymous HIBE schemes have some disadvantages that the security was proven in the weaker model, the size of ciphertexts is not short, or the construction was based on composite order bilinear groups. In this paper, we propose the first efficient anonymous HIBE scheme with short ciphertexts in prime order (asymmetric) bilinear groups, and prove its security in the full model with an efficient reduction. To achieve this, we use the dual system encryption methodology of Waters. We also present the benchmark results of our scheme by measuring the performance of our implementation.",
  "sections": [
    {
      "heading": "Introduction",
      "text": "Hierarchical Identity-Based Encryption (HIBE) is an extension of Identity-Based Encryption (IBE) that uses an identity as a public key. In HIBE, a user's identity is represented as a hierarchical tree structure and an upper level user can delegate the private key generation capability to a lower level user. Horwitz and Lynn introduced the concept of HIBE to reduce the burden of the private-key generator of IBE [27]. After the introduction of HIBE, it was shown that HIBE can have various applications like identity-based signature [25], public-key broadcast encryption [20], forward-secure public key encryption [14], and chosenciphertext secure HIBE [15]. Recently, as a result of the increasing concern with users' privacy, the need for cryptographic systems that protect users' privacy also increases. Anonymous HIBE can provide users' privacy by supporting not only the message hiding property but also the identity hiding property that hides identity information in ciphertexts. Abdalla et al. formalized the concept of anonymous HIBE [1]. After that, Boyen and Waters proposed the first secure anonymous HIBE scheme without random oracles [13]. The main applications of anonymous HIBE are anonymous communication systems that provide anonymity between a received message and a true sender and public key encryption systems with keyword searching that enable keyword searches on encrypted data [8]. The security model of anonymous HIBE is defined as a game between a challenger and an adversary. In this game, the adversary adaptively requests private keys in the private key query step and selects two hierarchical identities ID 0 , ID 1 and two messages M 0 , M 1 in the challenge step. Next, the adversary is given a challenge ciphertext of ID γ , M γ where γ is a random bit chosen by the challenger. The adversary wins the game if he can correctly guess γ. The security model is divided as a selective model where the adversary should commit the target hierarchical identities in the initial step and a full model where the adversary can select the target hierarchical identities in the challenge step. Generally a selectively secure HIBE scheme is converted to a fully secure HIBE scheme, but the reduction is inefficient [5]. The efficiency of the reduction is important not only for theoretical reasons but also for practical reasons. Let Adv A be the advantage of an adversary A that breaks a scheme and Adv B be the advantage of an algorithm B that breaks an assumption using the adversary A. Suppose that Adv A ≤ L • Adv B where L is a reduction loss. Let λ , k be the security level of the scheme and the assumption, respectively. If the assumption provides the k-bit security, then it guarantees that Adv B ≤ 1/2 k for any PPT algorithm B. Then we can derive Adv A ≤ L • 1/2 k from two inequalities Adv A ≤ L • Adv B and Adv B ≤ 1/2 k . To construct the scheme that provides the λ -bit security, it should be guaranteed that Adv A ≤ 1/2 λ for any PPT adversary A. It is easy to achieve this by setting L • 1/2 k ≤ 1/2 λ since Adv A ≤ L • 1/2 k . Thus we can derive a relation k ≥ λ + log 2 (L). This relation says that the bit size k of a group order for the assumption should be larger than λ + log 2 (L) to construct the scheme with the λ -bit security. For example, if there is a selectively secure scheme with a hierarchical depth l = 10, then we should select k = 880 since λ = 80 and L = 2 λ l . Therefore, an ideal anonymous HIBE scheme should be fully secure with a reduction loss less than c•q for a polynomial value q and a constant c. To construct a fully secure HIBE scheme with an efficient reduction, the new proof methodology named the dual system encryption method was proposed by Waters [45]. In the dual system encryption method, ciphertexts and private keys can be a normal type or a semi-functional type, and the semi-functional types of ciphertexts and private keys are only used in security proofs. Additionally, the normal type and the semi-functional type are indistinguishable, and the semi-functional ciphertexts are not decrypted by using the semi-functional private keys. The proof of the dual system encryption method consists of hybrid games that change a normal ciphertext and normal private keys to a semi-functional ciphertext and semi-functional private keys. Using this methodology, Waters proposed a fully secure HIBE scheme with linear-size ciphertexts and a fully secure HIBE scheme with constant-size ciphertexts [33,45]. The dual system encryption method can be used to prove the security of fully secure attribute-based encryption [31], fully secure predicate encryption [37], and leakage-resilient cryptography [32]. The first secure anonymous HIBE scheme was proposed by Boyen and Waters [13], and it was proven to be selectively secure without random oracles. After the first construction of anonymous HIBE, several anonymous HIBE schemes were presented, but they were only proved to be secure in the selective model [21,29,41]. Recently, De Caro et al. proposed a fully secure anonymous HIBE scheme with short ciphertexts by using the dual system encryption method [16]. However, their scheme is inefficient since the scheme is based on composite order groups where the group order is a product of four prime numbers. One may use the conversion method of Freeman [22] to construct a scheme in prime order groups from a scheme in composite order groups, but this method can not be applied to the dual system encryption method of Lewko and Waters [33] since it does not provide the parameter hiding property in composite order groups 1 . Lewko recently devised another conversion method for the dual system encryption method and constructed a (nonanonymous) unbounded HIBE scheme with linear-size ciphertexts in prime order groups [30]. However, this method is not known to be applicable for the construction of an anonymous HIBE scheme with constant-size ciphertexts since it uses dual pairing vector spaces (DPVS) 2 . Anonymous HIBE can also be constructed from Predicate Encryption (PE) with the delegation capability. Shi and Waters constructed an anonymous HIBE scheme with linear-size ciphertexts from a delegatable Hidden Vector Encryption (dHVE) scheme [42] and Okamoto and Takashima constructed an anonymous HIBE scheme with linear-size ciphertexts from a Hierarchical Inner Product Encryption (HIPE) scheme [31,36,37,39]. However, currently known anonymous HIBE schemes from PE schemes with the delegation capability only have linear-size ciphertexts. It is also possible to derive anonymous HIBE from anonymous Spatial Encryption (SE) [11,19]. However, there is no known anonymous SE scheme with constant-size ciphertexts. Thus the construction of efficient and fully secure anonymous HIBE with short ciphertexts is an unsolved problem."
    },
    {
      "heading": "Our Contributions",
      "text": "Motivated by the above challenge, we propose the first fully secure and anonymous HIBE scheme with short ciphertexts in prime order (asymmetric) bilinear groups. The comparison between previous HIBE schemes and ours is given in Table 1. To construct a fully secure and anonymous HIBE scheme, we use the IBE scheme in prime order (asymmetric) bilinear groups of Lewko and Waters [33]. Note that their IBE scheme does not even converted to a (non-anonymous) HIBE scheme with short ciphertexts since it does not support private key re-randomization 3 . To construct an anonymous HIBE scheme, we should devise techniques for private key re-randomization and ciphertext anonymization. The private key re-randomization process is required in the delegation algo-SKOS-HIBE [41] Yes ANON = anonymity, R.L. = reduction loss, Prime = prime order bilinear groups λ = security parameter, l = hierarchical depth, q = polynomial value, k, k T = the bit size of group G and G T rithm of HIBE and anonymous HIBE. In HIBE, private keys are simply re-randomized using the public elements of public parameters. However, private keys of anonymous HIBE cannot be simply re-randomized using the public elements because an attacker can break anonymity using the public elements. To solve this problem, we may use the private re-randomization technique of Boyen and Waters [13] that re-randomizes private keys using the private elements of private keys. Nevertheless, if the private re-randomization technique is used in the dual system encryption method, then additional random values in semi-functional private keys are not completely randomized in the proof that distinguishes a normal private key from a semifunctional private key. To resolve this difficulty, we define two types of semi-functional private keys as semi-functional type-1 and semi-functional type-2, and we show that it is hard to distinguish these two types of semi-functional private keys. The main idea to provide ciphertext anonymity is that the Decisional Diffie-Hellman (DDH) assumption still holds in asymmetric bilinear groups of prime order. We prove the anonymity property of our scheme by introducing a new assumption since the simple DDH assumption is not enough for the security proof. Furthermore, we implemented our anonymous HIBE scheme using the PBC library to support our claim of efficiency and we measured the performance of our scheme."
    },
    {
      "heading": "Related Work",
      "text": "IBE was introduced to solve the certificate management problem in public key encryption systems, but it additionally requires a Private-Key Generator (PKG) [9,10]. HIBE was invented to reduce the burden of the IBE's PKG by re-arranging an identity as a hierarchical tree structure and by allowing the delegation of private key generation from upper level users to lower level users [27]. Gentry and Silverberg proposed the first HIBE scheme in the random oracle model [25]. Canetti et al. constructed the first HIBE scheme without random oracles and introduced a selective model to prove the security of their scheme [14]. The selective model was widely used in the security proof of IBE and HIBE even though it is weaker than the full model. For instance, Boneh and Boyen proposed an efficient HIBE scheme with linear-size ciphertexts [5,6], and Boneh et al. proposed an HIBE scheme with constant-size ciphertexts [7]. To construct a fully secure HIBE scheme, Boneh and Boyen showed that a selectively secure HIBE scheme is naturally converted to a fully secure HIBE scheme with exponential loss of a reduction efficiency [5]. However, this approach has a serious problem -that is, the efficiency of the reduction is 1/Ω(2 λ l ) where λ is a security parameter and l is the maximum hierarchical depth. To remedy this situation, Waters proposed an HIBE scheme by extending his fully secure IBE scheme with an efficient reduction to a HIBE scheme [44], and Chatterjee and Sarkar improved the efficiency of Waters' scheme [18]. However, these schemes also have the problem of an inefficient reduction 1/Ω(q l ) in the hierarchical setting where q is a polynomial value. Gentry and Halevi proposed another fully secure HIBE scheme with an efficient reduction by using complex assumptions [24]. Recently, Waters introduced the dual system encryption method that can be used to construct a fully secure HIBE scheme with an efficient reduction under simple assumptions [33,45]. Anonymous IBE is related to public key encryption with keyword search (PEKS) [8,23], and the concept of anonymous HIBE was introduced by Abdalla et al. [1] by extending the concept of anonymous IBE. Boyen and Waters proposed the first anonymous HIBE scheme without random oracles and proved its security in the selective model [13]. For the construction of anonymous HIBE, they devised a linear splitting technique for ciphertext anonymity and a private re-randomization technique for private key randomization. Seo et al. proposed the first anonymous HIBE scheme with short ciphertexts in composite order bilinear groups [41]. Ducas constructed anonymous HIBE schemes using asymmetric bilinear groups of prime order [21]. Lee and Lee proposed an efficient anonymous HIBE scheme with short ciphertexts that is secure in all types of bilinear groups of prime order [29]. De Caro et al. proposed the first fully secure and anonymous HIBE scheme with short ciphertexts using the dual system encryption method in composite order bilinear groups [16]. HIBE schemes also can be constructed from Attribute Based Encryption (ABE) schemes [26] and Predicate Encryption (PE) schemes with delegation capabilities [36,42]. PE schemes with linear-size ciphertexts that have the delegation capability include the dHVE scheme of Shi and Waters in composite order bilinear groups [42] and HIPE schemes of Okamoto and Takashima based on dual pairing vector spaces [31,36,37,39]. A non-anonymous HIPE scheme based on dual pairing vector spaces can have constant-size ciphertexts, but the ciphertext should contain a linear-size identity vector [38]. Though bilinear groups were widely used in the construction of HIBE, some HIBE schemes were designed in lattices [3,4,17]."
    },
    {
      "heading": "Preliminaries",
      "text": "We define anonymous HIBE and give the formal definition of its full model security. Let I be an identity space and M be a message space. A hierarchical identity ID of depth c is defined as an identity vector (I 1 , . . . , I c ) ∈ I c . A hierarchical identity ID = (I 1 , . . . , I c ) of depth c is a prefix of a hierarchical identity"
    },
    {
      "heading": "Anonymous HIBE",
      "text": "An anonymous HIBE scheme consists of five algorithms (Setup, KeyGen, Delegate, Encrypt, Decrypt). Formally it is defined as: The setup algorithm takes as input a security parameter 1 λ and a maximum hierarchical depth l. It outputs a master key MK and public parameters PP. KeyGen(ID, MK, PP). The key generation algorithm takes as input a hierarchical identity ID of depth m where m ≤ l, the master key MK, and the public parameters PP. It outputs a private key SK ID for ID. Delegate(ID ′ , SK ID , PP). The delegation algorithm takes as input a hierarchical identity ID ′ of depth m + 1 where m+1 ≤ l, a private key SK ID for a hierarchical identity ID of depth m, and the public parameters PP. If ID is a prefix of ID ′ , then it outputs a delegated private key SK ID ′ for ID ′ . Encrypt(ID, M, PP). The encryption algorithm takes as input a hierarchical identity ID of depth n where n ≤ l, a message M ∈ M, and the public parameters PP. It outputs a ciphertext CT for ID and M. Decrypt(CT, SK ID , PP). The decryption algorithm takes as input a ciphertext CT for a hierarchical identity ID ′ , a private key SK ID for a hierarchical identity ID, and the public parameters PP. If ID = ID ′ , then it outputs an encrypted message M. The correctness property of anonymous HIBE is defined as follows: For all MK, PP generated by Setup, all ID, ID ′ ∈ I n , any SK ID generated by KeyGen, and any M, it is required that • If ID = ID ′ , then Decrypt(Encrypt(ID ′ , M, PP), SK ID , PP) =⊥ with all but negligible probability. The second condition of the correctness property is not a trivial one to satisfy since the decryption algorithm of anonymous HIBE cannot easily check whether ID = ID ′ or not because of anonymity. One possible relaxation is to use a computational condition instead of a statistical condition. For a computational condition, we can use weak robustness of Abdalla et al. [2]. The security property of anonymous HIBE under a chosen plaintext attack is defined in terms of the following experiment between a challenger C and a PPT adversary A: 1. Setup: C runs Setup(1 λ , l) to generate a master key MK and public parameters PP. It keeps MK to itself and gives PP to A."
    },
    {
      "heading": "Query 1:",
      "text": "A may adaptively request a polynomial number of private keys for hierarchical identities ID 1 , . . . , ID q 1 of arbitrary depths. In response, C gives the corresponding private keys SK ID 1 , . . . , SK ID q 1 to A by running KeyGen(ID i , MK, PP)."
    },
    {
      "heading": "Challenge:",
      "text": "A submits two hierarchical identities ID * 0 , ID * 1 ∈ I n and two messages M * 0 , M * 1 with equal length subject to the restriction: for all ID i of private key queries, ID i is not a prefix of ID * 0 and ID * 1 . C flips a random coin γ ∈ {0, 1} and gives the challenge ciphertext CT * to A by running Encrypt(ID * γ , M * γ , PP)."
    },
    {
      "heading": "Query 2:",
      "text": "A may continue to request a polynomial number of private keys for hierarchical identities ID q 1 +1 , . . . , ID q subject to the restriction as before."
    },
    {
      "heading": "5.",
      "text": "Guess: A outputs a guess γ ′ ∈ {0, 1} of γ, and wins the game if γ ′ = γ. The advantage of A is defined as where the probability is taken over all the randomness of the experiment. An anonymous HIBE scheme is fully secure under a chosen plaintext attack if for all PPT adversary A, the advantage of A in the above experiment is negligible in the security parameter λ . The security experiment of anonymous HIBE can be relaxed to complete one introduced by Shi and Waters [42] that traces the path of delegation. Our definition of the security experiment that does not trace the path of delegation is stronger than the complete one of Shi and Waters. Thus if an anonymous HIBE scheme is secure in the security experiment of this section, then the scheme is also secure in the complete one."
    },
    {
      "heading": "Asymmetric Bilinear Groups",
      "text": "Let G, Ĝ and G T be multiplicative cyclic groups of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ. The bilinear map e : G × Ĝ → G T has the following properties: 2. Non-degeneracy: ∃g, ĝ such that e(g, ĝ) has order p, that is, e(g, ĝ) is a generator of G T . We say that G, Ĝ, G T are bilinear groups with no efficiently computable isomorphisms if the group operations in G, Ĝ, and G T as well as the bilinear map e are all efficiently computable, but there are no efficiently computable isomorphisms between G and Ĝ."
    },
    {
      "heading": "Complexity Assumptions",
      "text": "We introduce five assumptions under asymmetric bilinear groups of prime order. Assumptions 1 and 2 were introduced in Lewko and Waters [33], and Assumptions 3 and 4 are well-known. Assumption 5 (Asymmetric 3-Party Diffie-Hellman) is an asymmetric version of the Composite 3-Party Diffie-Hellman assumption introduced by Boneh and Waters [12] with a slight modification by augmenting one additional element, and it is secure in the generic group model. Assumption 1 (LW1) Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ respectively. The assumption is that if the challenge values D = ((p, G, Ĝ, G T , e), g, g a , g b , g ab 2 , g b 2 , g b 3 , g c , g ac , g bc , g b 2 c , g b 3 c , ĝ, ĝb ) and T are given, no PPT algorithm B can distinguish T = T 0 = g ab 2 c from T = T 1 = g d with more than a negligible advantage. The advantage of B is defined as where the probability is taken over the random choice of a, b, c, d ∈ Z p . Assumption 2 (LW2) Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ respectively. The assumption is that if the challenge values D = ((p, G, Ĝ, G T , e), g, g a , g a 2 , g bx , g abx , g a 2 x , ĝ, ĝa , ĝb , ĝc ) and T are given, no PPT algorithm B can distinguish T = T 0 = ĝbc from T = T 1 = ĝd with more than a negligible advantage. The advantage of B is defined as Adv The assumption is that if the challenge values D = ((p, G, Ĝ, G T , e), g, g a , g b , g c , g ab , g a 2 b , ĝ, ĝa , ĝb ) and T are given, no PPT algorithm B can distinguish T = T 0 = g abc from T = T 1 = g d with more than a negligible advantage. The advantage of B is defined as where the probability is taken over the random choice of a, b, c, d ∈ Z p ."
    },
    {
      "heading": "Anonymous HIBE",
      "text": "We construct an anonymous HIBE scheme in prime order (asymmetric) bilinear groups and prove its full model security under static assumptions."
    },
    {
      "heading": "Construction",
      "text": "Let I = Z * p . Our anonymous HIBE scheme is described as follows: Setup(1 λ , l): This algorithm first generates the asymmetric bilinear groups G, Ĝ, G T of prime order p of bit size Θ(λ ). It chooses random elements g ∈ G and ĝ ∈ Ĝ. It also chooses random exponents ν, φ 1 , φ 2 ∈ Z p and sets τ = φ 1 + νφ 2 . Next, it selects random exponents y h , {y u i } l i=1 , y w , α ∈ Z p and sets h = g y h , ĥ = ĝy h , {u i = g y u i , ûi = ĝy u i } l i=1 , ŵ = ĝy w . It outputs a master key MK = ( ĝ, ĝα , ĥ, { ûi } l i=1 ) and public parameters as KeyGen(ID, MK, PP): This algorithm takes as input a hierarchical identity ID = (I 1 , . . . , I m ) ∈ I m and the master key MK. It first selects random exponents r 1 , c 1 , c 2 , {c 3,i } l i=m+1 ∈ Z p and creates the decryption and delegation components of a private key as Next, it selects random exponents r 2 , c 4 , c 5 , {c 6,i } l i=m+1 ∈ Z p and creates the randomization components of the private key as Finally, it outputs a private key as Delegate(ID ′ , SK ID , PP): This algorithm takes as input a hierarchical identity ID ′ = (I 1 , . . . , I m+1 ) ∈ I m+1 and a private key SK ID for a hierarchical identity ∈ Z p and creates the decryption and delegation components of a delegated private key as Next, it selects random exponents γ 2 , δ 4 , δ 5 , {δ 6,i } l i=m+2 ∈ Z p and creates the randomization components of the delegated private key as Finally, it outputs a delegated private key as The distribution of the delegated private key is the same as the original private key since the random values are defined as r ′ 1 = r 1 + r 2 γ 1 , r ′ 2 = r 2 γ 2 where r 1 , r 2 are random exponents in the private key SK ID . Note that c 1 , c 2 , {c 3,i }, c 4 , c 5 , {c 6,i } are perfectly re-randomized since ŵφ 1 , ŵφ 2 , ŵ are publicly known and δ 1 , δ 2 , {δ 3,i }, δ 4 , δ 5 , {δ 6,i } are chosen randomly."
    },
    {
      "heading": "Encrypt(ID, M, PP):",
      "text": "This algorithm takes as input a hierarchical identity ID = (I 1 , . . . , I n ) ∈ I n , a message M ∈ G T , and the public parameter PP. It selects a random exponent t ∈ Z p and outputs a ciphertext as"
    },
    {
      "heading": "Decrypt(CT, SK ID , PP):",
      "text": "This algorithm takes as input a ciphertext CT and a private key SK ID for a hierarchical identity ID = (I 1 , . . . , I n ). It outputs the encrypted message as"
    },
    {
      "heading": "Correctness",
      "text": "The first condition of the correctness property can be easily checked by the following equation as since the inner product of (1, ν, -τ) and (φ 1 , φ 2 , 1) are zero. The second condition of the correctness prop- erty can be satisfied by using the technique of Boneh and Waters [12] that uses the limited message space. If we use a computational condition instead of a statistical condition, then we can achieve weak robustness by using the transformation of Abdalla et al. [2]."
    },
    {
      "heading": "Security Analysis",
      "text": "Theorem 3.1. The above anonymous HIBE scheme is fully secure under a chosen plaintext attack if Assumptions 1, 2, 3, 4 and 5 hold. That is, for any PPT adversary A, there exist PPT algorithms B 1 , B 2 , B 3 , B 4 , and B 5 such that where q is the maximum number of private key queries of A. Proof. To prove the security of our scheme, we use the dual system encryption technique of [33,45]. We first describe a semi-functional key generation algorithm and a semi-functional encryption algorithm. They are not used in a real system, but they are used in the security proof. For semi-functionality, we set f = g y f , f = ĝy f where y f is a random exponent in Z p . KeyGenSF-1. The semi-functional type-1 key generation algorithm first creates a normal private key using the master key. Let ) be the normal private key of a hierarchical identity ID = (I 1 , . . . , I m ) with random exponents ∈ Z p and outputs a semi-functional type-1 private key as Note that the randomization components should contain the semi-functional part since this semifunctional part enables the correct simulation of the security proof for anonymity."
    },
    {
      "heading": "KeyGenSF-2.",
      "text": "The semi-functional type-2 key generation algorithm first creates a normal private key using the master key. Let and outputs a semi-functional type-2 private key the same as the semi-functional type-1 private key except that the randomization components are generated as Note that new random exponents z k,3 , {z k,4,i } l i=1 are chosen to generate the randomization components of the semi-functional type-2 private key, whereas the same exponents z k,1 , {z k,2,i } l i=1 of the decryption and delegation components are used to generate the randomization components in the semi-functional type-1 private key. EncryptSF. The semi-functional encryption algorithm first creates a normal ciphertext using the public parameters. Let (C ′ ,C ′ 1,1 , . . . ,C ′ 2,3 ) be the normal ciphertext. It selects random exponents s c , z c ∈ Z p and outputs a semi-functional ciphertext as If we decrypt a semi-functional ciphertext by using a semi-functional type-2 private key, then the decryption fails since an additional element e( f , f ) s c ((s k,1 z k,1 +s k,2 z k,3 γ)-(s k,1 +s k,2 γ)z c ) remains. Note that the decryption can be done after re-randomizing the private key using a random exponent γ. then the decryption algorithm succeeds. However, the probability of this is negligible since s k,1 , s k,2 , z k,1 , z k,3 , z c , γ are randomly chosen. In case of the semi-functional type-1 private key, the additional random element can be restated as e( f , f ) (s k,1 +s k,2 γ)s c (z k,1 -z c ) . If z k,1 = z c , then the decryption algorithm succeeds. In this case, we say that the private key is nominally semi-functional type-1. The security proof consists of a sequence of games. The first game will be the original security game and the last one will be a game such that the adversary has no advantage. We define the games as follows: Game G 0 . This game is the original security game. That is, the private keys and the challenge ciphertext are normal. Game G 1 . We first modify G 0 into a new game G 1 . This game is almost identical to G 0 except that the challenge ciphertext is semi-functional. Game G 2 . Next, we modify G 1 into a game G 2 . In this game, the private keys are semi-functional type-2 and the challenge ciphertext is semi-functional. Suppose that an adversary makes at most q private key queries. For the security proof, we define a sequence of games 1,k and G 1,k , a normal private key is given to the adversary for all j-th private key queries such that j > k and a semi-functional type-2 private key is given to the adversary for all j-th private key queries such that j < k. However, for k-th private key query, a semi-functional type-1 private key is given to the adversary in G ′ 1,k where as a semi-functional type-2 private key is given in Game G 3 . We now define a new game. This game differs from G 2 where the challenge ciphertext component C is replaced by a random element in G T . Game G 4 . Finally, we change G 3 to a new game G 4 . In this game, the semi-functional ciphertext components (C 2,1 ,C 2,2 ,C 2,3 ) are formed as (P t , (P ν ) t f s c z c , (P -τ ) t ( f -φ 2 ) s c z c ) where P is a random element in G. In this game, the challenge ciphertext gives no information about the random coin γ. Therefore, the adversary can win this game with probability at most 1/2."
    },
    {
      "heading": "G j",
      "text": "A be the advantage of A in G j for j = 0, . . . , 4. Let Adv A , and Adv G 4 A = 0. From the following five Lemmas, we obtain that it is hard to distinguish G i-1 from G i under the given assumptions. Therefore, we have that This completes our proof of Theorem 3.1."
    },
    {
      "heading": "Lemma 3.2.",
      "text": "If Assumption 1 holds, then no PPT algorithm can distinguish between G 0 and G 1 with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm ). Lemma 3.3. If Assumption 2 holds, then no PPT algorithm can distinguish between G 1,k-1 and G ′ 1,k with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm B 2 such that Lemma 3.4. If Assumption 3 holds, then no PPT algorithm can distinguish between G ′ 1,k and G 1,k with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm B 3 such that Adv 3.5. If Assumption 4 holds, then no PPT algorithm can distinguish between G 2 and G 3 with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm B 4 such that Adv G 2 A -Adv G 3 A = Adv A4 B 4 (λ ). Lemma 3.6. If Assumption 5 holds, then no PPT algorithm can distinguish between G 3 and G 4 with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm B 5 such that Adv The security proof of Lemmas 3.2, 3.3, 3.4, 3.5, and 3.6 are given in Section 5."
    },
    {
      "heading": "Extensions",
      "text": "Relaxed Security Model. The original security experiment of anonymous HIBE requires that an adversary should select two hierarchical identities ID * 0 , ID * 1 ∈ I n with equal depth n [1]. One possible relaxation of the security experiment of anonymous HIBE is to allow the adversary to select two hierarchical identities Our scheme is also fully secure in this relaxed security experiment since the ciphertext size is constant. The two challenge hierarchical identities with different depths only matter in the security proof that distinguishes G 3 from G 4 . In that proof, we showed that the adversary cannot distinguish the challenge hierarchical identity ID * γ from a random value. Thus our scheme is secure in this relaxed experiment since the ciphertext size does not reveal the depth of the hierarchical identity."
    },
    {
      "heading": "Performance Analysis",
      "text": "In this section, we analyze the running time of our scheme, and then we measure the performance of the scheme by implementing it."
    },
    {
      "heading": "Runtime Analysis",
      "text": "To analyze the efficiency of our scheme, we use the abstract cost of expensive mathematical operations. In bilinear groups, the expensive operations are exponentiation operations and pairing operations. Additionally, the efficiency of exponentiations and pairings can be improved by doing m-term exponentiations and m-term pairings respectively. The abstract cost of these operations is defined as follows: • MPairCost(G, Ĝ, m): m-term pairing ∏ m i=1 e(g i , ĥi ) where g i ∈ G, h i ∈ Ĝ • PairCost(G, Ĝ): pairing e(g, ĥ) where g ∈ G, h ∈ Ĝ • MExpCost(G, m): m-term exponentiation ∏ m i=1 g a i i where g i ∈ G • ExpCost(G): exponentiation g a where g ∈ G Let l be the maximum number of hierarchical depth and d be the depth of ID. We define the abstract costs of the setup algorithm, the key generation algorithm, the delegation algorithm, the encryption algorithm, and the decryption algorithm as SetupCost, GenCost, DelCost, EncCost, DecCost respectively. The abstract costs of these algorithm are obtained as follows: In asymmetric bilinear groups, the bit size of Ĝ and the bit size of G T increase proportionally to the embedding degree of asymmetric bilinear groups. Thus the cost of exponentiation in Ĝ is higher than the cost of exponentiation in G. In our scheme, the cost of the key generation algorithm and the cost of the delegation algorithm are higher than the cost of other algorithm since our scheme uses group elements in G for ciphertexts and group elements in Ĝ for private keys, and these costs decrease proportionally to the depth of ID. The cost of the encryption algorithm is small since it uses m-term exponentiations in G, and the cost of the decryption algorithm is constant."
    },
    {
      "heading": "Implementation",
      "text": "To show the efficiency of our scheme, we present the implementation of our scheme and analyze the performance of it. We use the Pairing Based Cryptography (PBC) library [35] to implement our scheme, and we use a notebook computer with an Intel Core i5 2.53 GHz CPU as a test machine. We select a 175-bit Miyaji-Nakabayashi-Takano (MNT) curve with embedding degree 6. In the 175-bit MNT curve, the group size of G is about 175 bits, the group size of Ĝ is about 525 bits, and the group size of G T is about 1050 bits. The PBC library on the test machine can compute an exponentiation of G in 1.6 ms, an exponentiation of Ĝ in 20.3 ms, an exponentiation of G T in 4.7 ms, and a pairing in 15.6 ms. Additionally, the PBC library can compute a three-term multi-exponentiation of G in 2.1 ms, a two-term multi-exponentiation of Ĝ in 27.3 ms, a three-term multi-exponentiation of Ĝ in 28.6 ms, and a three-term multi-pairing in 31.2 ms. Therefore, we can obtain the cost of our scheme using the 175-bit MNT curve on the test machine as follows: Let l = 30. The performance results of each algorithms are described in Figure 1. The setup algorithm takes about 0.936 seconds to generate the public parameters and the master key. The key generation algorithm and the delegation algorithm for one depth take about 4.259 seconds and 5.257 seconds respectively. One method to improve the performance of the key generation algorithm is to preprocess the public parameters and the master key. If the preprocessing method is used, then the cost of the key generation algorithm is reduced to 1/5. This method also can be used in the delegation algorithm."
    },
    {
      "heading": "Proof of Lemma 3.2 (Indistinguishability of G 0 and G 1 )",
      "text": "In this proof, private keys are normal and the challenge ciphertext should be normal or semi-functional depending on the T value of the given assumption. The main idea of this proof is that a simulator can only create normal private keys since an element for semi-functional private keys is not given in the assumption and the simulator embeds the T element of the assumption into the challenge ciphertext. Simulator. Suppose there exists an adversary A that distinguishes between G 0 and G 1 with a nonnegligible advantage. A simulator B 1 that breaks Assumption 1 using A is given: a challenge tuple Then B 1 that interacts with A is described as follows: B 1 first chooses random exponents φ 2 , B, {A i } l i=1 , α ∈ Z p and random blinding values y g , y h , {y u i } l i=1 , y w ∈ Z p . It implicitly sets ν = a, φ 1 = b, τ = b + aφ 2 and creates the public parameters as It also implicitly sets ĝ = kb 2 ky g , ĥ = kb 2 B ky h , ûi = kb 2 A i ky u i for the master key, but it cannot create these elements since kb 2 is not given. Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i and Γ(ID) = B + ∑ m i=1 A i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). To response the private key query, B 1 first selects random exponents r and creates the decryption and delegation components of a private key as It also creates the randomization components of a private key similarly by selecting random exponents 1 does not have ĝα . We omit the detailed description of these. In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . , I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 . B 1 flips a random coin γ ∈ {0, 1} internally. It implicitly sets t = c and creates a challenge ciphertext as Finally, A outputs a guess γ ′ . If γ = γ ′ , B 1 outputs 0. Otherwise, it outputs 1. Analysis. We first show that the distribution of the simulation using D, T = T 0 = k ab 2 c is the same as G 0 . The public parameters are correctly distributed since the random blinding values y g , y h , {y u i }, y w are used. The private key is correctly distributed as Note that it can create a normal private key since c 1 , c 2 , {c 3,i }, c 4 , c 5 , {c 6,i } enable the cancellation of kb 2 , but it cannot create a semi-functional private key since ka is not given. The challenge ciphertext is correctly distributed as We next show that the distribution of the simulation using D, T = T 1 = k ab 2 c+d is the same as G 1 . We only consider the distribution of the challenge ciphertext since T is only used in the challenge ciphertext. The only difference between T 0 and T 1 is that T 1 additionally has k d . Thus C 1,2 ,C 1,3 ,C 2,2 ,C 2,3 components that have T in the simulation additionally have respectively. If we implicitly set s c = d, z c = Γ(ID * γ ), then the challenge ciphertext is semi-functional. The distribution of this semifunctional challenge ciphertext is the same as G 1 since B, {A i } for z c are information theoretically hidden to A. We obtain Pr A from the above analysis. Thus, we can easily derive the advantage of B 1 as This completes our proof."
    },
    {
      "heading": "Proof of Lemma 3.3 (Indistinguishability of G 1,k-1 and G ′ 1,k )",
      "text": "In this proof, the challenge ciphertext is semi-functional and the k-th private key should be normal or semifunctional type-1 depending on the T value of the given assumption. However, the paradox of dual system encryption occurs in this proof since a simulator can create a semi-functional ciphertext to check the type of the k-th private key by decrypting the semi-functional ciphertext using the k-the private key. The main idea to solve this paradox is to use a nominally semi-functional type-1 private key. If the k-th private key is nominally semi-functional type-1, then z k,1 of the nominally semi-functional private key is the same as the z c of a semi-functional challenge ciphertext. Thus the simulator cannot distinguish the type of k-th private key since the decryption of the semi-functional ciphertext using the k-th private key always succeeds. Before proving this lemma, we introduce Assumption 2-A as follows: Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p. Let g, ĝ be generators of G, Ĝ respectively. Assumption 2-A is that if the challenge values D = ((p, G, Ĝ, G T , e), k, k a , k a 2 , k bx , k abx , k a 2 x , k, ka , kb , ky 1 , ky 2 ) and T = (D 1 , D 2 ) are given, no PPT algorithm can distinguish T = ( kby 1 , kby 2 ) from T = ( kd 1 , kd 2 ) with more than a negligible advantage. It is easy to show that if there exists an adversary that breaks Assumption 2-A, then an algorithm can break Assumption 2 with the same probability by setting ky 1 = ( kb ) r 1 ks 1 , ky 2 = ( kb ) r 2 ks 2 , D 1 = (T ) r 1 ( kc ) s 1 , D 2 = (T ) r 1 ( kc ) s 1 where kb , kc , T are given in Assumption 2 and r 1 , r 2 , s 1 , s 2 are random exponents in Z p . The simulated values are correctly distributed since there exists one-to-one correspondence between {r 1 , s 1 , r 2 , s 2 } and {y 1 , y 2 , d 1 , d 2 }. Simulator. Suppose there exists an adversary A that distinguishes between G 1,k-1 and G ′ 1,k with a non-negligible advantage. A simulator B 2 that breaks Assumption 2-A using A is given: a challenge tuple . Then B 2 that interacts with A is described as follows: B 2 first chooses random exponents ν, y τ , B, {A i } l i=1 , α ∈ Z p and random blinding values y h , {y u i } l i=1 , y w ∈ Z p . It implicitly sets φ 1 = -νb + (a + y τ ), φ 2 = b, τ = a + y τ and creates the public parameters as It also sets ĝ = ka , ĝα = ( ka ) α , ĥ = ( ka ) B ky h , { ûi = ( ka ) A i ky u i } l i=1 for the master key. Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i and Γ(ID) = B + ∑ m i=1 A i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). If this is a j-th private key query, then B 2 handles this query as follows: • Case j < k : It creates a semi-functional private key by calling KeyGenSF-2 since it knows the master key and the tuple ( f -ν , f , 1) for the semi-functional private key. and creates the decryption and delegation components of a private key as It also creates the randomization components of a private key similarly by selecting random exponents r ′ 2 , c ′ 4 , c ′ 5 , {c ′ 6,i } l i=m+1 ∈ Z p except that it uses ky 2 , D 2 instead of ky 1 , D 1 . We omit the detailed description of these. • Case j > k : It creates a normal private key by calling KeyGen since it knows the master key. In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . , I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 . B 2 flips a random coin γ ∈ {0, 1} internally and chooses a random exponent t ′ ∈ Z p . It implicitly sets t = bx + t ′ , s c = -a 2 x, z c = Γ(ID * γ ) and creates a semi-functional ciphertext as Finally, A outputs a guess γ ′ . If γ = γ ′ , B 2 outputs 0. Otherwise, it outputs 1. Analysis. We first show that the distribution of the simulation using D, T 0 = (D 0 1 , D 0 2 ) = ( kby 1 , kby 2 ) is the same as G 1,k-1 . The public parameters are correctly distributed since the random blinding values y h , {y u i }, y w are used. The k-th private key is correctly distributed as The semi-functional challenge ciphertext is correctly distributed as Note that it can create the semi-functional ciphertext with only fixed z c = Γ(ID * γ ) since s c , z c enable the cancellation of k a 2 bx . Even though the simulator uses the fixed z c , the distribution of z c is correct since B, {A i } for z c are information theoretically hidden to A. We next show that the distribution of the simulation using is the same as G ′ 1,k except the k-th private key is nominally semi-functional. We only consider the distribution of the k-th private key since T = (D 1 , D 2 ) is only used in the k-th private key. The only difference between 2 ) additionally has ( kd 1 , kd 2 ). The decryption and delegation components that have D 1 in the simulation additionally have ( kd 1 ) -νΓ(ID) , ( kd 1 ) Γ(ID) , ( kd 1 ) -ν , kd 1 , {( kd 1 ) -νA i , ( kd 1 ) the simulation also have the additional values except that kd 2 is used instead of kd 1 . If we implicitly set then the distribution of the k-th private key is the same as G ′ 1,k except that the k-the private key is nominally semi-functional type-1. Finally, we show that the adversary cannot distinguish the nominally semi-functional type-1 private key from the semi-functional type-1 private key. The main idea of this proof is that the adversary cannot request a private key for ID that is a prefix of a challenge identity ID * in the security model. Suppose there exists an unbounded adversary, then the adversary can gather the values i=m+1 from the k-the private key query for ID = (I 1 , . . . , I m ) and z c = Γ(ID * γ ) = B + ∑ n i=1 A i I * γ,i from the challenge ciphertext for ID * γ = (I * γ,1 , . . . , I * γ,n ). In case of n ≥ m, the values that are revealed to the adversary are described as . . . It is easy to show that the row rank of the above (lm + 2) × (l + 1) matrix is lm + 2 since there exists an index j such that I j = I * γ, j . It means that the above matrix is non-singular. In case of n < m, the revealed values to the adversary also can be described as a similar matrix equation as the above one. The row rank of this (lm + 2) × (l + 1) matrix is lm + 2 since I m = 0. Therefore these values look random to the unbounded adversary since the matrixes for two cases are non-singular and B, A 1 , . . . , A l are chosen randomly. We obtain Pr A from the above analysis. Thus, we can easily derive the advantage of B 2 as This completes our proof."
    },
    {
      "heading": "Proof of Lemma 3.4 (Indistinguishability of G ′ 1,k and G 1,k )",
      "text": "In this proof, the challenge ciphertext is semi-functional and the k-th private key should be semi-functional type-1 or semi-functional type-2 depending on the T value of the given assumption. The main idea of this proof is to show that the semi-functional type-1 and semi-functional type-2 private keys are computationally indistinguishable using the given assumption. Before proving this lemma, we introduce Assumption 3-A as follows: Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p. Let g, ĝ be generators of G, Ĝ respectively. Assumption 3-A is that if the challenge values D = ((p, G, Ĝ, G T , e), k, k, kx 1 , kx 2,1 , . . . , kx 2,l , ky ) and T = (D 1 , D 2,1 , . . . , D 2,l ) are given, no PPT algorithm can distinguish T = T 0 = ( kx 1 y , kx 2,1 y , . . . , kx 2,l y ) from T = T 1 = ( kd 1 , kd 2,1 , . . . , kd 2,l ) with more than a negligible advantage. It is easy to show that if there exists an adversary that breaks Assumption 3-A, then an algorithm can break Assumption 3 with the same probability by setting kx 1 = ( ka ) where ka , kb , T are given in Assumption 3 and r 1 , s 1 , {r 2,i , s 2,i } l i=1 are random exponents in Z p . The simulated values are correctly distributed since there exists one-to-one correspondence between {r 1 , s 1 , {r 2,i }, {s 2,i }} and {x 1 , {x 2,i }, d 1 , {d 2,i }}. Simulator. Suppose there exists an adversary A that distinguishes between G ′ 1,k and G 1,k with a nonnegligible advantage. A simulator B 3 that breaks Assumption 3-A using A is given: a challenge tuple D = ((p, G, Ĝ, G T , e), k, k, kx 1 , kx 2,1 , . . . , kx 2,l , ky ) and T = (D 1 , . . . , D 2,l ) where T = T 0 = (D 0 1 , . . . , D 0 2,l ) = ( kx 1 y , kx 2,1 y , . . . , kx 2,l y ) or T = T 1 = (D 1 1 , . . . , D 1 2,l ) = ( kd 1 , kd 2,1 , . . . , kd 2,l ). Then B 3 that interacts with A is described as follows: B 3 first chooses random exponents ν, φ 1 , φ 2 , α ∈ Z p and random blinding values y g , y h , {y u i } l i=1 , y w ∈ Z p . It implicitly sets τ = φ 1 + νφ 2 and sets g = k y g , ĝ = ky g , h = k y h , ĥ = ky h , {u i = k y u i , ûi = ky u i } l i=1 , ŵ = ky w . It creates the public parameters as and the master key as MK = ( ĝ, ĝα , ĥ, { ûi } l i=1 ). Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). If this is a j-th private key query, then B 3 handles this query as follows: • Case j < k : It creates a semi-functional private key by calling KeyGenSF-2 since it knows the master key and the tuple ( f -ν , f , 1) for the semi-functional private key. i=m+1 and creates the decryption and delegation components of a private key as Next, it selects random exponents r 2 , c 4 , c 5 , {c 6,i } l i=m+1 ∈ Z p . It implicitly sets s k,2 = y and creates the randomization components of a private key as • Case j > k : It creates a normal private key by calling KeyGen since it knows the master key. In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . , B 3 flips a random coin γ ∈ {0, 1} internally. It creates a semi-functional challenge ciphertext by calling EncryptSF on the message M γ and the hierarchical identity ID * γ since it knows the tuple (1, f , f -φ 2 ) for the semi-functional ciphertext. Finally, A outputs a guess γ ′ . If γ = γ ′ , B 3 outputs 0. Otherwise, it outputs 1. Analysis. We first show that the distribution of the simulation using D, T 0 = (D 0 1 , . . . , D 0 2,l ) is the same as G ′ 1,k . It is easy to check that the private key components are correctly distributed except the randomization components of the k-th private key. If we implicitly set z k,1 = x 1 , {z k,2,i = x 2,i } l i=m+1 , s k,2 = y, then the randomization components of the k-th private key have the same distribution as G ′ 1,k . We next show that the distribution of the simulation using D, T 1 = (D 1 1 , . . . , D 1 2,l ) is the same as G 1,k . We only consider the distribution of the randomization components of the k-th private key since T is only used in the randomization components of the k-th private key. If we implicitly set s k,2 = y, z k,3 = d 1 /y, {z k,4,i = d 2,i /y} l i=m+1 , then the randomization components are correctly distributed as From the above analysis, we can obtain Pr[B 3 (D, A . Thus, we can easily derive the advantage of B 3 as This completes our proof."
    },
    {
      "heading": "Proof of Lemma 3.5 (Indistinguishability of G 2 and G 3 )",
      "text": "In this proof, private keys and the challenge ciphertext are semi-functional type-2 and semi-functional respectively, but a session key should be correct or random depending on the T value of the given assumption. The main idea of this proof is to enforce a simulator to solve the Computational Diffie-Hellman (CDH) problem in order to create the normal types of private keys and ciphertexts. However, the simulator can generate the semi-functional types of private keys and ciphertexts since an additional random value in semi-functional types enables the cancellation of the CDH value. Simulator. Suppose there exists an adversary A that distinguishes between G 2 and G 3 with a nonnegligible advantage. A simulator B 4 that breaks Assumption 4 using A is given: a challenge tuple D = ((p, G, Ĝ, G T , e), k, k a , k b , k c , k, ka , kb , kc ) and T where T = T 0 = e(k, k) abc or T = T 1 = e(k, k) d . Then B 4 that interacts with A is described as follows: B 4 first chooses random exponents φ 1 , φ 2 ∈ Z p and random blinding values y g , y h , {y u i } l i=1 , y w ∈ Z p . It sets g = k y g , h = k y h , {u i = k y u i } l i=1 , ĝ = ky g , ĥ = ky h , { ûi = ky u i } l i=1 , ŵ = ky w . It implicitly sets ν = a, τ = φ 1 + aφ 2 , α = ab and creates the public parameters as Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). To response the private key query, B 4 first selects random exponents k,1 and creates the decryption and delegation components of a semifunctional private key as Next, it selects random exponents r 2 , c 4 , c 5 , {c 6,i } l i=m+1 , s k,2 , z k,3 , {z k,4,i } l i=m+1 ∈ Z p and creates the randomization components of a semi-functional private key. In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . , I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 . B 4 flips a random coin γ ∈ {0, 1} internally and chooses random exponents s ′ c , z ′ c ∈ Z p . It implicitly sets t = c, s c = -acy g + s ′ c , z c = -ac∆(ID * γ )/s c + z ′ c /s c and creates the semi-functional ciphertext as Finally, A outputs a guess γ ′ . If γ = γ ′ , B 4 outputs 0. Otherwise, it outputs 1. Analysis. We first show that the distribution of the simulation using D, T 0 = e(k, k) abc is the same as G 2 . The public parameters are correctly distributed since the random blinding values y g , y h , {y u i }, y w are used. The semi-functional private key is correctly distributed as Note that it can only create a semi-functional private key since z k,1 = by g /s k,1 + z ′ k,1 enables the cancellation of kab . The semi-functional challenge ciphertext is correctly distributed as Note that it can create a semi-functional ciphertext since s c , z c enable the cancellation of k ac . We next show that the distribution of the simulation using D, T 1 = e(k, k) d is the same as G 3 . It is obvious that C is a random element since T 1 = e(k, k) d . From the above analysis, we obtain Pr[B 4 (D, A . Thus, we can easily derive the advantage of B 4 as A . This completes our proof."
    },
    {
      "heading": "Proof of Lemma 3.6 (Indistinguishability of G 3 and G 4 )",
      "text": "In this proof, private keys and the challenge ciphertext are semi-functional type-2 and semi-functional respectively, and the elements of the challenge ciphertext should be well-formed or random depending on the T value of the given assumption. The idea to generate semi-functional type-2 private keys and semifunctional ciphertexts is similar to Lemma 3.5, but it uses a different assumption. To prove anonymity, the simulator embeds the T value of the assumption into the all elements of the challenge ciphertext that contains an identity. Simulator. Suppose there exists an adversary A that distinguishes between G 3 and G 4 with a nonnegligible advantage. A simulator B 5 that breaks Assumption 5 using A is given: a challenge tuple D = ((p, G, Ĝ, G T , e), k, k a , k b , k c , k ab , k a 2 b , k, ka , kb ) and T where T = T 0 = k abc or T = T 1 = k d . Then B 5 that interacts with A is described as follows: B 5 first chooses random exponents φ 1 , φ 2 , α ∈ Z p and random blinding values y g , y h , {y u i } l i=1 , y w ∈ Z p . It sets g = k y g , h = (k ab ) y h , {u i = (k ab ) y u i } l i=1 , ĝ = ky g , ŵ = ky w , ĝα = ky g α . It implicitly sets ν = a, τ = φ 1 + aφ 2 and publishes the public parameters as It also implicitly sets ĥ = ( kab ) y h , { ûi = ( kab ) y u i } for the master key, but it cannot create these values since kab is not given. Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). To response the private key query, B 5 first selects random exponents r and creates the decryption and delegation components of a semi-functional private key as Next, it selects random exponents r 2 , c 4 , c 5 , {c 6,i } l i=m+1 , s k,2 , z ′ k,3 , {z ′ k,4,i } l i=m+1 ∈ Z p and creates the randomization components of a semi-functional private key by implicitly setting z k,3 = b∆(ID)r 2 /s k,2 +z ′ k,3 , {z k,4,i = by u i r 2 /s k,2 + z ′ k,4,i } l i=m+1 . We omit the detailed description of these, since these are similar to the decryption and delegation components except that R 1,1 does not have ĝα . In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . , I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 . B 5 flips a random coin γ ∈ {0, 1} internally and chooses random exponents δ , s ′ c , z ′ c ∈ Z p . It implicitly sets t = c, s c = -acy g + s ′ c , z c = -a 2 bc∆(ID * γ )/s c + abcz ′ c /s c and creates the semi-functional ciphertext as Finally, A outputs a guess γ ′ . If γ = γ ′ , B 5 outputs 0. Otherwise, it outputs 1. Analysis. We first show that the distribution of the simulation using D, T 0 = k abc is the same as G 3 . The public parameters are correctly distributed since the random blinding values are used. The semi-functional private key is correctly distributed as Note that it can only create a semi-functional type-2 private key since z k,1 , {z k,2,i }, z k,3 , {z k,4,i } enable the cancellation of kab . The semi-functional challenge ciphertext is correctly distributed as Note that it can only create a semi-functional ciphertext since s c , z c enable the cancellation of k a 2 bc . We next show that the distribution of the simulation using D, T 1 = k d is the same as G 4 . We only consider C 2,1 ,C 2,2 ,C 2,3 components of the semi-functional challenge ciphertext since T is used for these components. If we implicitly sets P = k ∆(ID * γ )d/c and z c = -ad∆(ID * γ )/s c + dz ′ c /s c , then the semi-functional challenge ciphertext is correctly distributed as From the above analysis, we obtain Pr[B 5 (D, T A . Thus, we can easily derive the advantage of B 5 as A . This completes our proof."
    },
    {
      "heading": "Generic Group Model",
      "text": "In this section, we prove that the new assumption of this paper is secure under the generic group model. The generic group model was introduced by Shoup [43], and it is a tool for analyzing generic algorithms that work independently of the group representation. In the generic group model, an adversary is given a random encoding of a group element or an arbitrary index of a group element instead of the actual representation of a group element. Thus, the adversary performs group operations through oracles that are provided by a simulator, and the adversary only can check the equality of group elements. The detailed explanation of the generic group model is given in [7,28]."
    },
    {
      "heading": "Master Theorem",
      "text": "To analyze the new assumption of this paper, we slightly modify the master theorem of Katz et al. [28] since the new assumption is defined over asymmetric bilinear groups of prime order. Let G, Ĝ, G T be asymmetric bilinear groups of prime order p. The bilinear map is defined as e : G × Ĝ → G T . In the generic group model, a random group element of G, Ĝ, G T is represented as a random variable P i , Q i , R i respectively where P i , Q i , R i are chosen uniformly in Z p . We say that a random variable has degree t if the maximum degree of any variable is t. The generalized definition of dependence and independence is given as follows: Definition 6.1. Let P = {P 1 , . . . , P u }, T 0 , T 1 be random variables over G where T 0 = T 1 , let Q = {Q 1 , . . . , Q w } be random variables over Ĝ, and let R = {R 1 , . . . , R v } be random variables over G T . Let l = max{u, w, v}. We say that T b is dependent on P if there exists constants α, where α = 0. We say that T b is independent of P if T b is not dependent on P. We say that {e(T b , Q i )} i is dependent on P ∪ Q ∪ R if there exist constants {α i }, {β i, j }, {γ i } such that w where α i = 0 for at least one i. We say that {e(T b , Q i )} i is independent of P ∪ Q ∪ R if {e(T b , Q i )} i is not dependent on P ∪ Q ∪ R. We can obtain the following theorem by using the above dependence and independence of random variables. If T b is independent of P for all b ∈ {0, 1}, and {e(T b , Q j )} j is independent of P ∪ Q ∪ R for all b ∈ {0, 1}, then any algorithm A issuing at most q instructions has an advantage at most 3(q + 2l) 2 t/p. Proof. The proof consists of a sequence of games. The first game will be the original experiment that is described in the theorem and the last game will be a game that the algorithm has no advantage. We define the games as follows: Game G 1 . This game is the original game. In this game, the simulator instantiates each of random variables P, Q, R, T b by choosing random values for each of the formal variables. Then it gives the handles of P, Q, R, T b to the algorithm A. Next, A requests a sequence of multiplication, exponentiation, and pairing instructions, and is given the handles of results. Finally, A outputs a bit b ′ . Game G 2 . We slightly modify G 1 into a new game G 2 . In this game, the simulator never concretely instantiates the formal variables. Instead it keeps the formal polynomials themselves. Additionally, the simulator gives identical handles for two elements only if these elements are equal as formal polynomials in each of their components. That is, the simulator of this game assigns different handles for X and Y since these are different polynomials. Note that the simulator of G 1 assigned the same handle for X = (X 1 , . . . , X n ) and Y = (Y 1 , . . . ,Y n ) if X i = Y i for all i. To prove the theorem, we will show that the statistical distance between two games G 1 and G 2 is negligible and the advantage of the algorithm in G 2 is zero. Then the advantage of the algorithm in the original game is bounded by the statistical distance between two games. We first show that the statistical distance between two games G 1 and G 2 is negligible. The only difference between two games is the case that two different formal polynomials take the same value by concrete instantiation. The probability of this event is at most t/p from the Schwartz-Zippel Lemma [40]. If we consider all pairs of elements produced by the algorithm A, the statistical distance between two games is at most 3(q + 2l) 2 t/p since A can request at most q instructions, the maximum size of handles in each group is at most q + 2l, and there are three different groups. We next show that the advantage of the algorithm in G 2 is zero. In this game, the algorithm A only can distinguish whether it is given T 0 or T 1 if it can generate a formal polynomial that is symbolically equivalent to some previously generated polynomial for one value of b but not the other. In this case, we have α • T b = ∑ u i=1 β i • P i where α = 0, or else we have ∑ w i=1 α i • e(T b , Q i ) = ∑ u i=1 ∑ w j=1 β i, j • e(P i , Q j ) + ∑ v i=1 γ i • R i where α i = 0 for at least one i (otherwise, symbolic equality would hold for both value of b). However, the above equations are contradict to the independence assumptions of the theorem. Therefore, the advantage of A in this game is zero."
    },
    {
      "heading": "Analysis of Asymmetric 3-Party Diffie-Hellman",
      "text": "To apply the master theorem of the previous section, we only need to show the independence of T 0 , T 1 random variables. Using the notation of previous section, Assumption 5 (Asymmetric 3-Party Diffie-Hellman) can be written as P = {1, A, B,C, AB, A 2 B}, Q = {1, A, B}, R = {1}, T 0 = ABC, T 1 = D. At first, we show the independence of T 1 . It is trivial that T 1 is independent of P since a random variable D does not exist in P. It is easy to show that {e(T 1 , Q i )} i is independent of P ∪ Q ∪ R since T 1 contains a random variable D that does not exist in P, Q, R. Next, we show the independence of T 0 . It is easy to show that T 0 is independent of P since the random variables with degree 3 are different. To show the independence of {e(T 0 , Q i )} i , we can derive the sets of random variables as {e(T 0 , Q j )} j = {ABC, A 2 BC, AB 2 C}, {e(P i , Q j )} i, j = {1, A, B,C, AB, A 2 B, A 2 , AC, A 3 B, B 2 , BC, AB 2 , A 2 B 2 }, The random variables of {e(T 0 , Q i )} i always contain C and the degree of these random variables is greater than 3. However, the random variables of {e(P i , Q j )} i, j that contain C have the degree at most 2. Thus {e(T 0 , Q i )} i is independent of P ∪ Q ∪ R."
    },
    {
      "heading": "Conclusion",
      "text": "In this paper, we proposed an efficient anonymous HIBE scheme with short ciphertexts and proved its full model security under static assumptions. Though our construction is based on the IBE scheme of Lewko and Waters [33], it was not trivial to construct an anonymous HIBE scheme, since the randomization components of private keys cause a problem in the security proof of dual system encryption. We leave it as an interesting problem to construct a fully secure and anonymous HIBE scheme with short ciphertexts under standard assumptions."
    }
  ]
}