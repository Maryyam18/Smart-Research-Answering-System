{
  "paperid": "2111.05523v1",
  "title": "Anonymous communication system provides a secure environment without leaking metadata, which has many application scenarios in IoT",
  "authors": [
    "Van Nguyen",
    "Thuy",
    "Pham",
    "Abb10a",
    "Agrawal",
    "Boneh",
    "Boyen",
    "Abb10b",
    "Agrawal",
    "Boneh",
    "Boyen",
    "Boneh",
    "Boyen",
    "Boneh",
    "Boyen",
    "Goh",
    "Blazy",
    "Brouilhet",
    "Hieu Phan",
    "Boneh",
    "Franklin",
    "Bert",
    "Fouque",
    "Roux-Langlois",
    "Sabt",
    "Bw06a",
    "Boyen",
    "Waters",
    "Boyen",
    "Waters",
    "Cash",
    "Hofheinz",
    "Kiltz",
    "Peikert",
    "Díaz",
    "Martín",
    "Rubio",
    "Gentry",
    "Peikert",
    "Vaikuntanathan",
    "Jll + 18. Liaoliang",
    "Jiang",
    "Li",
    "Li",
    "Atiquzzaman",
    "Ahmad",
    "Wang",
    "Katsumata",
    "Yamada",
    "Ltt + 21",
    "Zi-Yuan",
    "Liu",
    "Tseng",
    "Tso",
    "Mambo",
    "Chen",
    "Micciancio",
    "Peikert",
    "Reg09",
    "Regev",
    "Srb14",
    "Singh",
    "Pandu Rangan",
    "Banerjee"
  ],
  "year": 2021,
  "abstract": "Anonymous Identity Based Encryption (AIBET) scheme allows a tracer to use the tracing key to reveal the recipient's identity from the ciphertext while keeping other data anonymous. This special feature makes AIBET a promising solution to distributed IoT data security. In this paper, we construct an efficient quantum-safe Hierarchical Identity-Based cryptosystem with Traceable Identities (AHIBET) with fully anonymous ciphertexts. We prove the security of the AHIBET scheme under the Learning with Errors (LWE) problem in the standard model.* Oracle O TskGen (id) takes input an identity id different from id * , returns the output of TskGen(MPK, MSK, id).",
  "sections": [
    {
      "heading": "Introduction",
      "text": "Internet of Things (IoT) has emerged as a set of interconnected technologies like Wireless Sensors Networks (WSN) and Radio Frequency Identification (RFID), that provide identification, computation, and mutual information exchange among the connected devices all over the world. The key idea of the IoT is to obtain information about our environment to understand and control and act on it [DMR16]. Identity-Based Encryption (IBE) is a type of public-key encryption where the public key is an arbitrary string that uniquely defined the user (for example an email address or a telephone number). The Private-key Generator (PKG) who has knowledge of a master secret key generates the private key for the corresponding identities. This concept was first introduced by Shamir [Sha84] and then in 2001, Boneh and Franklin [BF01] proposed the first practical IBE scheme based on bilinear map. The idea of Hierarchical Identity-Based Encryption (HIBE), which is an extension of IBE where each level can issue private keys for identites of the next level, was first proposed in the work of Gentry and Silverberg [GS02]. Since then, there have been many efficient constructions of HIBE, ranging from classical setting [BB04, BBG05,Wat05] to post-quantum setting [ABB10a,CHKP10,SRB14] just to name a few. The concept of \"Anonymous\" IBE offers an additional privacy guarantee to standard IBE schemes where the ciphertexts do not leak the identity of the recipients. AIBE is a promising solution to anonymous communications and it can be applied to many realistic scenarios that provide privacy-preserving and security under cloud environment. It can also bring a secure environment without leaking metadata which has many application scenarios in the aforementioned distributed IoT system [JLL + 18]. However, the first AIBE construction of Boneh and Frankl in [BF01] is just anonymous in the random oracle model and it was a challenging problem to achieve anonymous IBE in the standard model until [BW06b]. In [BW06a], Boyen and Waters proposed the first secure anonymous HIBE scheme without random oracles. More recently, the HIBE constructions in the post-quantum setting [ABB10a,SRB14] are proven to be anonymous secure in the standard model in the mean of a ciphertext encrypted for a target identity is indistinguishable from a random element in the ciphertext space which helps hide this identity from any malicious attacker. Although this strong unconditional privacy seems very attractive from the user's point of view, it can potentially be a dangerous tool against public safety if there is no way to revoke such privacy when illegal behavior is detected. For example, in the case where the email filtering system has to filter out all encrypted email from members are suspected of illegal activity, standard anonymous IBE and HIBE prevent the system reveal the recipients of those ciphertexts. Traceability can provide a solution to this problem in which an additional traceability function can detect specific identities in ciphertexts and all the others remain anonymous. In 2019, Blazy et al. [BBP19] first considered the traceability for identity-based encryption and constructed an Anonymous Identity Based Encryption (AIBET) scheme in the standard model but under the matrix Diffie Hellman (MDDH) assumption. Two security notions are formally defined in [4] are anonymity and ciphertext indistinguishability. Anonymity requires that someone without an associated user secret key or tracing key should not be able to guess the targeted identity. The notion of indistinguishability requires that no one can distinguish between a valid ciphertext and a random string from the ciphertext space even having access to the tracing key of the target identity. Recent, in [LTT + 21], Liu et al. proposed a lattice-based construction for AIBET which is based on the anonymous IBE by Katsumata and Yamada [KY16]. However, they do not address the notion of indistinguishability which is the main difference between an AIBET and a standard anonymous IBE. Note that the role of the tracer and the Private-key Generator PKG are distinguishable where the tracer has less power than the PKG. For example, it could be a gateway that checks whether an email for a suspected illegal user is passed. Even if the tracers are corrupted, the privacy and the confidentiality of the system will still remain intact."
    },
    {
      "heading": "Our contribution:",
      "text": "We propose a concrete construction of an Anonymous Lattice Hierarchical Identity-Based Encryption with Traceable Identities (AHIBET) scheme which is secure in the standard model based on the hardness assumption of lattices. In particular, our AHIBET construction is anonymous across all the levels of hierarchy, i.e., ciphertexts conceal recipients' identities from everyone which does not know the corresponding keys for decryption or tracing. Traceability cannot be extended down the hierarchy, i.e., knowing the tracing key for identity id doesn't imply knowing tracing key for any of its descendants. Besides, our construction is ciphertext indistinguishable, i.e., even having the tracing key for identity id, one cannot distinguish the ciphertexts of message m from the one of random messages for identity id. An instance of our AHIBET yields a lattice-based construction of AIBET that can be easily converted to a construction over ideal lattices using the techniques in [BFRS18], which outperforms the AIBET by Liu et al. [LTT + 21]foot_0 ."
    },
    {
      "heading": "Technical Overview:",
      "text": "The first main idea is that an AHIBET system must be controlled by three levels of trapdoors: -The master secret key MPK can be used to generate secret key SK id and tracing key Tsk id for each identity id of any level. -The secret keys SK id enable recipients to decrypt the corresponding ciphertexts. Each secret key SK id can be used to generate the secret keys for identities of the next level and thus control all descendants of id. -The tracing keys Tsk id enable tracers to detect only the ciphertexts sent to identities id without leaking information of the messages. To achieve the identity traceability property, we attach each ciphertext a random tag and its encapsulation whereas tracing keys are the trapdoors for decapsulation. We exploit the power of lattice trapdoors in [MP12,CHKP10] combining with the HIBE construction by Agrawal et al. [ABB10a] to achieve our AHIBET. In [ABB10a], each identity id is assigned a matrix F id and message m is encrypted following the dual-Regev scheme: In our scheme, we use one dual-Regev part to encrypt the message and another one to encapsulate the random tag to allow the ciphertext to reveal the recipients' identity from the tracing key holder. In [MP12], the authors introduced a so-called G-trapdoor where G is a gadget matrix in Z n×ω q . A G-trapdoor for matrix F is a matrix R ∈ Z (m-ω)×ω such that F = [A|AR + HG] for some invertible matrix H ∈ Z n×n q where A ∈ Z n×(m-ω) q . The authors called it \"strong trapdoor\" since a good basis T F ∈ Z m×m for Λ ⊥ q (F) can be obtained from the knowledge of the matrix R but the reverse is hard. Moreover, with either R or T F , one can easily generate a low norm matrix D F ∈ Z n×t q satisfying F.D F = U with respect to a given random matrix U ∈ Z n×t q using the sampling algorithms from [ABB10a] and [MP12]. Since D F is a kind of weaker trapdoor than T F , we can use such matrices R, T F and D F as the three levels of trapdoors MSK, SK id , Tsk id respectively for a traceable identity-based encryption where the matrix F is associated to an identity id = (id 1 , . . . , id ℓ ), namely, F = F id = [A|A 1 + FRD(id 1 )G| . . . |A ℓ + FRD(id ℓ )G] for the public matrices A, A 1 , . . . , A ℓ and the full-rank difference encoding function FRD. However, such trapdoors do not guarantee the anonymity and even the secrecy of messages across the hierarchy of identities. For example, knowing D F id 1 and D F [id 1 |id 2 ] , one can easily find a low norm matrix T of the same size as D F id 1 |id 2 such that F [id 1 |id 2 ] T = 0, which reveals information of the messages. Therefore, we use a collision resistance hash function H to construct a matrix F ′ id = [A|A 0 + FRD(H(id))G] and use the sampling algorithms to generate the tracing key D F ′ id of the identity id such that F ′ id D F ′ id = U. Such tracing keys are determined uniquely by the identities and independent of the secret keys, which ensures the anonymity and secrecy of the messages."
    },
    {
      "heading": "Anonymous Lattice Hierarchical Identity-Based Encryption with Traceable",
      "text": "Identities (AHIBET) In this section, we describe the model of Anonymous Lattice Hierarchical Identity-Based Encryption with Traceable Identities (AHIBET) based on the Anonymous Lattice Identity-Based Encryption with Traceable Identities (AIBET) from [BBP19] and its security model. Definition 1 (AHIBET). An AHIBET scheme consists of the following seven algorithms: -Setup(λ, d) takes as input the security parameter λ and the maximal hierarchy depth d of the scheme and outputs the master public key MPK and the master secret key MSK. -Extract(MPK, MSK, id) uses the master public key MPK and the master secret key MSK to generate the secret key SK id for an identity id at depth 1. -Derive(MPK, SK id ), (id|id ℓ ) takes as input the master public key MPK and a secret key SK id corresponding to an identity id at depth ℓ -1, outputs the secret key SK id|id ℓ for the identity (id|id ℓ ) at depth ℓ. -TskGen(MPK, MSK, id) uses the master public key MPK and the master secret key MSK to generate the tracing key Tsk id for a given identity id. -Encrypt(MPK, id, m) takes as input the master public key MPK, a given identity id and a message m, outputs the ciphertext CT. -Decrypt(MPK, CT, SK id ) takes as input the master public key MPK, a ciphertext CT and a secret key SK id . The algorithm outputs the message m if CT is encrypted for id; otherwise, it outputs the rejection symbol ⊥. -TkVer(MPK, id, Tsk id , CT) takes as input the master public key MPK, an identity id and a ciphertext CT, uses the tracing key Tsk id to check whether a ciphertext CT is encrypted for id. TkVer outputs 1 if CT is for the user with identity id; otherwise, it outputs 0."
    },
    {
      "heading": "Correctness and soundness.",
      "text": "The correctness of AHIBET scheme requires that if for all key pairs (MPK, MSK) output by Setup, all 1 ≤ ℓ ≤ d, all identities id = (id 1 , . . . , id ℓ ) where id i ∈ Z n q \\ {0} and all messages m ∈ {0, 1} λ , it holds that and the soundness of AHIBET requires Security models of AHIBET. For the security models, we give the definition of anonymity and ciphertext indistinguishability for the AHIBET scheme. -Anonymity is the property that the adversary can not distinguish the encryption of a chosen message for a first chosen identity from the encryption on the same message for a second chosen identity. Similarly, the adversary can not decide whether a ciphertext it received from the challenger was encrypted for a chosen challenge identity, or for a random identity in the identity space. The anonymity game, denoted ANON-sID-CPA, is played between an adversary A and a challenger C, provided that the adversary A does not have the corresponding tracing key of the challenge identity, is defined through the following game: • Init: The adversary A is given the maximum depth of the hierarchy d and then A decides a target pattern id * = (id * 1 , . . . , id * ℓ ), ℓ ≤ d."
    },
    {
      "heading": "Lattices",
      "text": "A lattice Λ in Z m is a set of all integer linear combinations of (linearly independent) basis vectors We call n the rank of Λ and if n = m we say that Λ is a full rank lattice. In this paper, we mainly consider full rank lattices containing qZ m , called q-ary lattices, Λ q (A) := e ∈ Z m s.t. ∃s ∈ Z n q where A T s = e mod q Λ ⊥ q (A) := {e ∈ Z m s.t. Ae = 0 mod q} and translations of lattice Λ ⊥ q (A) defined as follows We denote by S := max 1≤i≤k s i the maximum ℓ 2 length of the vectors in S. We also denote S := {s 1 , • • • , sk } the Gram-Schmidt orthogonalization of the vectors s 1 , • • • , s k in that order. We refer to S the Gram-Schmidt norm of S. Note that for any matrix B ∈ Z n×m , there exists a singular value decomposition B = QDP T , where Q ∈ R n×n , P ∈ R m×m are orthogonal matrices, and D ∈ R n×m is a diagonal matrix with nonnegative entries s i ≥ 0 on the diagonal, in non-increasing order. The s i are called the singular values of B. Under this convention, D is uniquely determined and s 1 (B) = max u Bu = max u B T u ≥ B , B T where the maxima are taken over all unit vectors u ∈ R m . Note that the singular values of B and B T are the same. Gaussian distribution. We will use the following definitions of the discrete Gaussian distributions. Definition 2. Let Λ ⊆ Z m be a lattice. For a vector c ∈ R m and a positive parameter σ ∈ R, define: The discrete Gaussian distribution over Λ with center c and parameter σ is For convenience, we will denote by ρ σ and D Λ,σ for ρ σ,0 and D Λ,σ,0 respectively. When σ = 1 we will write ρ instead of ρ 1 . It is well-known that for a vector x sampled from D m Z,σ , one has that x ≤ σ √ m with overwhelming probability. Lemma 4. For a prime q and a positive integer n, let m ≥ n⌈log q⌉. with σ ≥ ω( √ log n), the distribution of u = Ar ∈ Z n q is statistically close to the uniform distribution over Z n q . Furthermore, fix u ∈ Z n q , the distribution of r conditioned on Ar = u is D Λ u q (A),σ . The security of our construction reduces to the LWE (Learning With Errors) problem introduced by Regev [Reg09]. Definition 5 (Learning With Errors -LWE problem). Consider a prime q, a positive integer n, and a distribution χ over Z q . An LWE n,m,q,χ problem instance consists of access to an unspecified challenge oracle O, being either a noisy pseudorandom sampler O s associated with a secret s ∈ Z n q , or a truly random sampler O $ who behaviors are as follows: O s : samples of the form (a i , b i ) = (a i , s T a i + e i ) ∈ Z n q × Z q where s ∈ Z n q is a uniform secret key, a i ∈ Z n q is uniform and e i ∈ Z q is a noise withdrawn from χ. O $ : samples are uniform pairs in Z n q × Z q . The LWE n,m,q,χ problem allows respond queries to the challenge oracle O. We say that an algorithm A decides the LWE n,m,q,χ problem if"
    },
    {
      "heading": "Adv",
      "text": "LWEn,m,q,χ A is non-negligible for a random s ∈ Z n q . Regev [Reg09] showed that (see Theorem 6 below) when χ is a distribution Ψ α with α ∈ (0, 1), the LWE problem is hard. Theorem 6. If there exists an efficient, possibly quantum, algorithm for deciding the LWE n,m,q,Ψα problem for q > 2 √ n/α then there is an efficient quantum algorithm for approximating the SIVP and GapSVP problems, to within Õ(n/α) factors in the ℓ 2 norm, in the worst case. The theorem implies, for n/α is a polynomial in n, the LWE problem is as hard as approximating the SIVP and GapSVP problems in lattices of dimension n to within polynomial (in n) factors. In this paper, we will use the discrete Gaussian distribution D m Z,σ and denote LWE n,m,q,σ instead of LWE n,m,q,D m Z,σ for convenience. We use the following lemma which was introduced by Katsumata and Yamada in [KY16] to rerandomize LWE instances: Lemma 7. Let ℓ, q, m be positive integers and let r be a positive real number satisfying r ≥ max{ω( √ log m), ω( √ log ℓ)}. Let b ∈ Z m q be arbitrary and z ← D m Z,r . Then there exists an efficient algorithm ReRand such that for any D ∈ Z m×ℓ and positive real σ ≥ s 1 (D), the output of q where the distribution of z ′ is close to D ℓ Z,2rσ ."
    },
    {
      "heading": "Lattice trapdoors",
      "text": "Our work heavily bases on the notion G-trapdoor introduced in [MP12]. In the following, we recap this notion as well as some usefull algorithms. As in [MP12], let n ≥ 1, q ≥ 2 and let ω = n⌈log q⌉ = nk, we will use the vector g T = (1, 2, 4, . . . , 2 k-1 ) and extend it to get the gadget matrix The quality of the trapdoor is measured by its largest singular value s 1 (R). [MP12] also presented an algorithm to generate a pseudorandom matrix F ∈ Z n×(m+ω) q together with a \"strong\" G-trapdoor for the lattice Λ ⊥ q (F): ) and an invertible matrix H ← Z n×n q 2. Return F = [A|AR + HG] and the G-trapdoor R. The matrix R ← D m×ω Z,ω( √ log n) can do everything that a low-norm basis of Λ ⊥ q (F) does. Moreover, R can be used to efficiently generate low-norm basis T F ∈ Z (m+ω)×(m+ω) for Λ ⊥ q (F). Next, we recall the following lemma from [GPV08]: Lemma 9. Let q, k, n, m be integers with q > 2, k > 1, m > n and let A ∈ Z n×m q , U ∈ Z n×k q . Let T A be a basis for Λ ⊥ q (A). For σ ≥ T A •ω( √ log m), there is a PPT algorithm SamplePre(A, T A , U, σ) that returns a matrix D ∈ Z n×k q sampled from a distribution statistically close to D Λ U q (A),σ , whenever Λ U q (A) is not empty such that AD = U. The following lemma consists of algorithms for generating bases for lattices collected from the sampling technique in the work of Agrawal et al. [ABB10a] and the SamplePre algorithm from the work of Micciancio et al. [MP12, Theorem 5.1] which will be used in our construction. Note that the SamplePre algorithm in [MP12] is different from the SamplePre algorithm from [ABB10a] in Lemma 9 above. -Let T A be a basis for Λ ⊥ q (A), M ← Z n×m 1 q and σ ≥ T A • ω( log(m + m 1 )). Then there exists a PPT algorithm SampleBasisLeft(A, M, T A , σ) that outputs a basis of , and let H ← Z n×n q be an invertible matrix. , there exists a PPT algorithm SampleRight(R, F, H, U, σ) that outputs a matrix D ∈ Z (m+ω)×ω distributed statistically close to D Λ U q (F),σ s.t. FD = U. In particular, there exits a PPT algorithm SampleBasisRight(R, F, H, U, σ) that outputs a basis T ∈ Z (m+ω)×(m+ω) of Λ ⊥ q (F) which distributes statistically close to D Λ ⊥ q (F),σ , i.e., FT = 0. Here, we note that the algorithm SampleBasisRight basically runs SampleRight(R, F, H, 0, σ) many times until there are enough linearly independent output vectors to form a basis of Λ ⊥ q (F). According to [ABB10b], 2(m + ω) samples are needed in expectation to get the basis T for Λ ⊥ q (F). Peikert [Pei09] shows how to construct a basis for Λ ⊥ q (A 1 |A 2 |A 3 ) from a basis for Λ ⊥ q (A 2 ). Theorem 11. For i = 1, 2, 3, let A i be a matrix in Z n×m i and let A = (A 1 |A 2 |A 3 ). Let T 2 be a basis of Λ ⊥ q (A 2 ). There is a deterministic polynomial time algorithm ExtendBasis that outputs a basis T for Λ ⊥ q (A) such that T = T 2 . We will also use the following lemma in the decryption algorithm to recover the message. Lemma 12. Let A be a uniformly random matrix in Z n×m q where m > 2n. Let T ∈ Z m×m be a basis of Λ ⊥ q (A). Given y = s T A + e T where s ∈ Z n q , e ∈ Z m with e T T ∞ < q/4, there exists an algorithm Invert(A, T, y) that outputs s and e with overwhelming probability. It can be easily seen that the lemma is true since the algorithm works by computing y T T mod q = e T T mod q. We have e T T ∞ < q/4, so e T T mod q = e T ∈ Z m . Since T ∈ Z m×m is a basis of lattice Λ ⊥ q (A), T has linearly independent columns, one can simply use the Gaussian elimination to recover e and then get s T A. Finally, s can be recovered by Gaussian elimination because A ∈ Z n×m has at least n linearly independent column vectors."
    },
    {
      "heading": "AHIBET Construction over Integer Lattices",
      "text": "-Let λ be the security parameter, d be the hierarchy depth and identities are vector id = (id 1 , . . . , id ℓ ) (1 ≤ ℓ ≤ d) where all components id i are in Z n \\ {0}. -Let FRD : Z n q -→ Z n×n q be a full-rank difference encoding (FRD) from [ABB10a] s.t. for all distinct u, v ∈ Z n q , FRD(u) -FRD(v) ∈ Z n×n q is an invertible matrix. -Let H : (Z n q ) * -→ Z n q be a collision resistant hash function. -For an integer q > 2, x ∈ Z q , the algorithm Round(x) returns 0 if x is closer to 0 than to q 2 modulo q; otherwise, it returns 1. In the construction of the AHIBET scheme, we assume each identity id can only be given exactly one tracing key Tsk id ."
    },
    {
      "heading": "Setup(λ, d)",
      "text": "On input security parameter λ and a maximum hierarchy depth d, set the parameters (n, m, q, ω, σ, τ, α, r) as in section 3.1, the algorithm does: 1. Sample uniformly random matrices uniformly at random. 3. Output the master public key and the master secret key"
    },
    {
      "heading": "Extract(MPK, MSK, id)",
      "text": "On input the master pubic key MPK, the master secret key MSK and an identity id of level 1, the algorithm generates secret key for id as follows: Derive(MPK, SK id , (id|id ℓ )) On input the master pubic key MPK, a secret key SK id corresponding to an identity id = (id 1 , . . . , id ℓ-1 ) at depth ℓ -1 and an identity id|id ℓ = (id 1 , . . . , id ℓ-1 , id ℓ ) of level ℓ > 1, the algorithm generates secret key for id as follows:"
    },
    {
      "heading": "TskGen(MPK, MSK, id)",
      "text": "On input the master pubic key MPK, the master secret key MSK and an identity id = (id 1 , . . . , id ℓ ), the algorithm generates the tracing key for id as follows:"
    },
    {
      "heading": "Encrypt(MPK, id, m)",
      "text": "On input the master pubic key MPK, the algorithm encrypts the message m ∈ {0, 1} λ for identity id = (id 1 , . . . , id ℓ ) at depth ℓ as follows: Decrypt(MPK, CT, SK id ) On input the master pubic key MPK, a ciphertext CT and a secret key SK id where id = (id 1 , . . . , id ℓ ) is an identity at depth ℓ, the algorithm does: TkVer(MPK, id, Tsk id , CT) On input the master pubic key MPK, the algorithm uses the tracing key Tsk id = D id corresponding to the identity id to check whether a ciphertext CT is encrypted for the given identity id:"
    },
    {
      "heading": "Parameters",
      "text": "Let λ be the security parameter, d is the maximum hierarchical depth of the scheme, 1 ≤ ℓ ≤ d. We assume that all parameters are functions of λ. Now for the system to work correctly, we need to ensure: the error term in decryption is less than q/4 with high probability, i.e. α < (8σ ℓ τ (m + ℓω)) -1 , Hence the following choice of parameters (n, m, q, ω, σ, τ, α, r) satisfies all of the above conditions, taking λ to be the security parameter: (1)"
    },
    {
      "heading": "Correctness and soundness",
      "text": "When the cryptosystem is operated as specified, during decryption of a correctly generated ciphertext encrypted a message m to an identity id = (id 1 , . . . , id ℓ ) at depth ℓ ≤ d, with the parameters as specified in 3.1, we have: -Since e 0 ← D m Z,r , e 1 ← D ℓω Z,2rτ , by applying Lemma 3 and the parameters set up, we get ]) will output s with overwhelming probability. -Since e 2 ← D λ Z,r , e 3 ← D λ Z,2rτ , by applying Lemma 3 and the parameters set up we get e 2 ≤ e 3 ≤ 2rτ √ λ < q/4. will correctly recover k and m. In the algorithm TkVer, Round(c Hence by the parameters set up, TkVer will correctly recover the key k. 4 Security analysis"
    },
    {
      "heading": "Proof of Anonymity",
      "text": "In this part, we will prove that our proposed AHIBET scheme is ANON-sID-CPA secure in the standard model. Theorem 1. The AHIBET scheme Π := (Setup, Extract, Derive, Encrypt, Decrypt, TskGen, TkVer) with parameters (λ, n, m, q, ω, σ, τ, α, r) as in (1) is ANON-sID-CPA secure for the maximal hierarchy depth d provided that the hardness of the LWE n,m+λ,q,r problem holds. Proof. We will proceed the proof via a sequence of games where the Game 0 is identical to the original ANON-sID-CPA game and the adversary in the last game has advantage at most the advantage of an efficient LWE adversary. Let A be a PPT adversary that attacks the AHIBET scheme Π and has advantage Adv ANON-sID-CPA A,Π = ǫ. We will then construct a simulator B that solves the LWE problem using A. Let G i denote the event that the adversary A wins Game i. The adversary's advantage in Game Game 0. This is the original ANON-sID-CPA game between the adversary A against our scheme and an ANON-sID-CPA challenger. Game 1. Game 1 is analogous to Game 0 except that we slightly modify the way that the challenger C generates the master public key MPK and responds to the key derivation oracles O Derive as well as the tracing key oracles O TskGen . Let id * = (id * 1 , . . . , id * ℓ ) (ℓ ≤ d) be the target identity that A intends to attack. After receiving id * , C does: 5. Send master public key -Recall that the adversary A is not allowed to use the challenge identity id * or its prefixes for its key derivation queries. To respond to the key derivation queries O Derive for id = (id 1 , . . . , • If k ≤ ℓ, then Let h be the sallowest level where id h = id * h (h ≤ k). By the property of the full-rank difference encoding FRD, FRD(id h ) -FRD(id * h ) ∈ Z n×n q is an invertible matrix, C then samples and FRD(id ℓ+1 ) ∈ Z n×n q is an invertible matrix. The challenger C samples and uses algorithm ExtendBasis to extend the basis T id ℓ+1 of Λ ⊥ q ([A|AR ℓ+1 +FRD(id ℓ+1 )G]) to a basis T id of Λ ⊥ q (F id ). Finally, C returns SK id = T id . -To respond to the tracing key query O TskGen for id = (id 1 , . . . , Since H is a collision resistant hash function, H(id) = H(id * ) even if id is a prefix of id * and thus FRD(H(id)) -FRD(H(id * )) is an invertible matrix in Z n×n q . Challenger C samples then invokes the algorithm SamplePre and returns Tsk id = D id . Using Lemma 4, we can easily prove that the matrices A i (0 ≤ i ≤ d) are statistically close to uniform. Hence, in the adversary's point of view, A 0 , A 1 , . . . , A d in Game 0 and Game 1 are computationally indistinguishable. Next, we consider the responses to the secret key derivation queries O Derive and the tracing key queries O TskGen . For secret key derivation queries O Derive , Theorem 10 shows that when , the algorithms SampleBasisRight and ExtendBasis generate a basis T id for Λ ⊥ q (F id ) which is statistically close to the one generated in the original game. Similarly, the tracing keys generate by SampleBasisRight and SamplePre in Game 1 have distribution statistically close to ones in Game 0. Since the master public key MPK and responses to key derivation queries and tracing key queries in Game 1 are statistically close to those in Game 0, these games are statistically indistinguishable in the view of the adversary. Thus we have In this game, we change the way the challenge ciphertext CT * for the challenge identity id * is created. Recall that, after receiving a message m ∈ {0, 1} λ from the adversary A, the challenger C then selects a random bit b ∈ {0, 1}. If b = 1, C chooses a random identity id ′ in the identity space which is not identical to any query identities in Phase 1. C then runs Encrypt(MPK, id, m) and sends the resulting ciphertext CT * 1 to A. If b = 0, the challenger C does the following steps to generate CT * 0 and sends it to A. Observe that c 0 and c 3 are distributed exactly as they as in the previous game. Since by Lemma 7, we get ."
    },
    {
      "heading": "Proof of Ciphertext Indistinguishability",
      "text": "Finally, we will prove that our proposed AHIBET scheme is IND-sID-CPA secure in the standard model. Recall that indistinguishable from random meaning that the challenge ciphertext encrypted for a given message m * is computationally indistinguishable from a challenge ciphertext encrypted for a random message m in the message space on the same challenge identity id * . Theorem 2. The AHIBET scheme Π := (Setup, Extract, Derive, Encrypt, Decrypt, TskGen, TkVer) with parameters (λ, n, m, q, ω, σ, τ, α, r) as in (1) is IND-sID-CPA secure for the maximal hierarchy depth d provided that the hardness LWE n,q,m+λ,r assumption holds. Proof. We will proceed the proof via a sequence of games where the Game 0 is identical to the original IND-sID-CPA game and the adversary has no advantage in winning the last game. Let A be a PPT adversary that attacks the AHIBET scheme Π and has advantage Adv IND-sID-CPA A,Π = ǫ. We will then construct a simulator B that solves the LWE problem using A. In Game i, let G i denote the event that the adversary A win the game. The adversary's advantage Game 0. This is the original IND-sID-CPA game between the adversary A against our scheme and an IND-sID-CPA challenger. Game 1 is similar to Game 0 except that we slightly modify the way that the challenger C generates the master public key MPK and responds to the key derivation oracles O Derive and tracing key oracles O TskGen . Let id * = (id * 1 , . . . , id * ℓ ) (ℓ ≤ d) be the identity that A intends to attack. After receiving id * , C does: 1. Sample A ← Z n×m q , R 0 , R 1 , . . . , R d ← D m×ω Z,ω( √ log n) and D 0 ← D m×λ Z,σ 1 , D 1 ← D ω×λ Z,σ 1 . 2. Set A i ← AR i -FRD(id * )G for i = 1, . . . , ℓ and A i ← AR i for ℓ < i ≤ d. -The adversary A is not allowed to ask for the key derivation queries of the challenge identity id * and its prefixes. To respond to a key derivation query O Derive for an identity id = (id 1 , . . . , id k ), C sets: • If k ≤ ℓ, then Let h be the sallowest level where id h = id * h (h ≤ k). By the property of the full-rank difference encoding FRD, FRD(id h ) -FRD(id * h ) ∈ Z n×n q is an invertible matrix, C then samples"
    }
  ]
}