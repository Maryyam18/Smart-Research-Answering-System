{
  "paperid": "1210.6441v1",
  "title": "Anonymous and Adaptively Secure Revocable IBE with Constant-Size Public Parameters",
  "authors": [
    "Chen",
    "Hoon",
    "Lim",
    "Ling",
    "Su",
    "Wang",
    "Agrawal",
    "Boneh",
    "Boyen",
    "Agrawal",
    "Boneh",
    "Boyen",
    "Aiello",
    "Lodha",
    "Ostrovsky",
    "Bethencourt",
    "Sahai",
    "Waters",
    "Boldyreva",
    "Goyal",
    "Kumar",
    "Boneh",
    "Franklin",
    "Boneh",
    "Boyen",
    "Goh",
    "Boneh",
    "Gentry",
    "Hamburg",
    "Boneh",
    "Sahai",
    "Waters",
    "Cash",
    "Hofheinz",
    "Kiltz",
    "Peikert",
    "Chen",
    "Lim",
    "Ling",
    "Wang",
    "Wee",
    "Cocks",
    "Gentry",
    "Peikert",
    "Vaikuntanathan",
    "Goyal",
    "Pandey",
    "Sahai",
    "Waters",
    "Hanaoka",
    "Hanaoka",
    "Shikata",
    "Imai",
    "Lewko",
    "Lewko",
    "Waters",
    "Lewko",
    "Okamoto",
    "Sahai",
    "Takashima",
    "Waters",
    "Libert",
    "Quisquater",
    "Libert",
    "Vergnaud",
    "Libert",
    "Vergnaud",
    "Naor",
    "Nissim",
    "Okamoto",
    "Takashima",
    "Okamoto",
    "Takashima",
    "Okamoto",
    "Takashima",
    "Okamoto",
    "Takashima",
    "Ostrovsky",
    "Sahai",
    "Waters",
    "Sahai",
    "Waters",
    "Shamir",
    "Waters",
    "Waters"
  ],
  "year": 2012,
  "abstract": "In Identity-Based Encryption (IBE) systems, key revocation is non-trivial. This is because a user's identity is itself a public key. Moreover, the private key corresponding to the identity needs to be obtained from a trusted key authority through an authenticated and secrecy protected channel. So far, there exist only a very small number of revocable IBE (RIBE) schemes that support non-interactive key revocation, in the sense that the user is not required to interact with the key authority or some kind of trusted hardware to renew her private key without changing her public key (or identity). These schemes are either proven to be only selectively secure or have public parameters which grow linearly in a given security parameter. In this paper, we present two constructions of non-interactive RIBE that satisfy all the following three attractive properties: (i) proven to be adaptively secure under the Symmetric External Diffie-Hellman (SXDH) and the Decisional Linear (DLIN) assumptions; (ii) have constant-size public parameters; and (iii) preserve the anonymity of ciphertexts-a property that has not yet been achieved in all the current schemes.",
  "sections": [
    {
      "heading": "I. INTRODUCTION",
      "text": "Identity-based encryption (IBE) allows one's identity to be directly used as a public key [29,6,12]. This obviates the need for a public key certificate that attests the binding between the identity and a (seemingly) random key, as in the case of more conventional certificate-based public-key systems. Thus, IBE systems have simpler public key management than that of certificate-based systems. In IBE, however, a private key (corresponding to an identity) needs to be generated by a trusted key authority. This and the fact that a user's identity is itself a public key complicates key renewal or revocation-one cannot simply change her public key, as this changes her identity as well. While there has been a great deal of work on IBE in recent years, see for example [7,30,8,13,31,10,1,2], not much work has been devoted to key revocation. One direct way to alleviate the key revocation problem in the IBE setting is to maintain a revocation list by some trusted third party. A sender checks on the trusted third party and just stops to encrypt messages if the corresponding receiver is revoked. However, this direct model requires the trusted third party to keep online in order to respond any sender's real time checking query. To address this problem, one simple solution is to append a validity period to a target identity during encryption [6]. This results in a public key with a limited validity period, and hence, restricting the window of exposure should the corresponding private key is compromised. If the validity period is sufficiently short, one may not require an explicit key revocation mechanism since an exposed private key is of little value to an adversary beyond the specified validity period. However, one major drawback of this approach is that each user has to periodically renew her private key. As a consequence, the key authority's workload increases linearly in the number of non-revoked users. Further, we must ensure that each transmission of a new private key between the key authority and a non-revoked user is performed through some form of authenticated and secure channel. There exist some improved key revocation techniques in the literature, for example [19,15]. However, they require interactions either between the user and the key authority, as before, or between the user and some kind of trusted hardware. These may not always be practical. The first non-interactive, revocable IBE (RIBE) scheme that neither presupposes the existence of trusted hardware nor requires a secure channel between the user and the key authority, is due to Boldyreva et al. [5]. Their scheme borrows the concept of fuzzy IBE (FIBE) [28] in which encryption of a message is associated with two \"attributes\", namely identity of the receiver and time period. The corresponding decryption key is also split into two private components, matching the identity and the time period, respectively. The private component that corresponds to the identity is essentially similar to a regular private key in IBE and it is issued to a user by the key authority through a secure channel. On the other hand, the private key component corresponding to the time period is regarded as a key update and is published by the key authority to all users. (Here the key update is public information and does not require secrecy protection.) Thus, to revoke a user, the key authority simply stops distributing the key update for that user. To reduce the number of key updates to be performed by the key authority, Boldyreva et al. organize and relate users' key updates in a binary tree [3,22]. Briefly speaking, each node of the tree is assigned some key material and each user is assigned to a leaf node in the tree. Upon registration, the key authority computes and provides the user with a set of distinct private keys (corresponding to its identity) based on the key material for each node in the path from the leaf node corresponding to that user to the root node. To be able to decrypt a ciphertext associated with time t, the user needs just one key update (corresponding to t) computed on the key material associated to any of the nodes on the path from the leaf node of the user to the root node. Thus, when no user is revoked, the key authority publishes just the key update computed on the key material of the root node. When a subset of the users is revoked, the key authority first finds the minimal set of nodes in the tree which contains an ancestor (or, the node itself) among all the leaf nodes corresponding to non-revoked users. The key authority then distributes the key updates for only this set. This way, every update of the revocation list only requires the key authority to perform logarithmic work in the maximal number of users and linear in the number of revoked users."
    },
    {
      "heading": "A. Previous Non-Interactive RIBE Constructions",
      "text": "Although an adaptive-ID secure IBE scheme [30] (which is resilient even against an adversary that is allowed to adaptively select an identity as the attack target based on the responses to the adversary's queries in a security game) has been in existence for some years, constructing an RIBE scheme with equivalent security guarantee is non-trivial. This is evident from the first RIBE scheme proposed by Boldyreva et al. [5]. Although it is intriguing that their RIBE scheme was constructed from the FIBE scheme of [28] and made clever use of the binary tree technique, the scheme was only proven in the selective-ID model, which is, unfortunately, a rather weak model. This is because the adversary is required to set the challenge identity and time at the beginning of a security game before receiving the relevant public parameters. Nevertheless, Libert and Vergnaud [21] eventually proposed an adaptive-ID secure RIBE scheme using similar key revocation techniques as with [5], and thus solved the problem left open by Boldyreva et al. However, instead of building on FIBE, Libert and Vergnaud adopted a variant [20] of the Waters IBE scheme [30], which is based on partitioning techniques and has a drawback in having public parameters that comprise O(λ) group elements for security parameter λ. Consequently, the Libert and Vergnaud RIBE scheme inherits a similar limitation. Clearly, it is desirable that a scheme has small or constant-size public parameters, secret keys, and ciphertexts, if it were to be deployed in real world applications."
    },
    {
      "heading": "B. RIBE from Dual System Encryption",
      "text": "Moving beyond proving security through the partitioning techniques, Waters proposed the dual system encryption methodology [31], which has been a powerful tool to obtain full security for various classes of functional encryption (FE) [9], such as IBE [31,17,16], inner product encryption (IPE) [18], and attribute-based encryption (ABE) [18,25]. Although there already exist some schemes that achieve full security using the dual system encryption technique, (for example, the HIBE scheme of [17] has been proven to be fully secure by applying this technique to the HIBE scheme of [7]), however, these fully secure schemes typically require relatively large parameters and/or constructed only in the composite order bilinear groups. Thus, in general, the dual system encryption methodology does not always provide generic transformation from selective security to adaptive security without suffering from the mentioned limitations. In our work, we initially tried to apply the dual system encryption technique to the selective-ID RIBE scheme of [5], however this results an analogous construction and proof to the ABE scheme of [25]. Furthermore, as we illustrate below, such an approach does not enjoy constant-size public parameters and keys. To see this, we specifically consider the binary-tree key update approach [5,21] in the setting similar to key-policy ABE. 1 As before, a ciphertext in the RIBE scheme is associated with two attributes: identity id i and time period t j . The ciphertext can be decrypted by a user if and only if the user possesses both the private key for identity id i and the key update for time t j on some node in the tree. Since the private keys and key updates associated with a specific node are not given to the users simultaneously, collusion among some (non-revoked) users on some 1 The case for ciphertext-policy ABE setting is similar. attributes (i.e. time attribute) is possible. Hence from the view of ABE, all users can be regarded as \"sharing\" the same key (or private component) associated with access structure of the form on each node in the tree for some integers n and m, but each user is given only some parts of the key for this access structure. That is, the parts of the key that the user gets correspond to access structure this node is in the path from the leaf node associated with id i to the root node; while the key updates corresponding to (t 1 ∨ • • • ∨ t m ) are given to all users (not necessarily at the same time). Clearly, we require that the private keys are collusion-resistant on different nodes. Moreover, supporting a large universe attribute space is required and can be used to deal with exponential identity spaces in RIBE. We observe that, however, the adaptively secure ABE schemes of [25] cannot be used directly for our purpose because the resulting RIBE somewhat unexpectedly has private keys and ciphertexts with sizes that grow linearly in the maximal number of users and the size of time space (even though they are polynomial in the security parameter). It turns out that constructing a fully secure RIBE scheme with constant-size public parameters and keys requires additional work."
    },
    {
      "heading": "C. Our Contributions",
      "text": "In this paper, we investigate how to instantiate the Waters dual system encryption methodology with revocable IBE schemes. Particularly, we construct two efficient non-interactive RIBE schemes that are proven to be adaptively secure under the Symmetric External Diffie-Hellman (SXDH) and the Decisional Linear (DLIN) assumptions, respectively. Our schemes improve the previous work by achieving adaptive security with constant-size public parameters. Moreover, our schemes are anonymous, namely, preserving the privacy of ciphertext recipients and encryption times. We note that previous RIBE schemes do not consider the anonymity property, an advantage inherited from using the dual pairing vector spaces (DPVS) [23,24] to achieve orthogonality and entropy-hiding in prime-order groups. Our constructions also make use of the key revocation techniques of [5,21], namely, we employ binary-tree data structure to achieve key update with logarithmic complexity in the maximal number of users for the key authority. We give a summary of comparisons between existing and our RIBE schemes in Table I. Here, we use PP to denote public parameters, MK to denote master key, SK to denote private key, KU to denote key update, CT to denote ciphertext, and # pairing to denote the number of pairing computation for decryption. The sizes are in terms of group elements and λ denotes the security parameter. TABLE I COMPARISONS BETWEEN EXISTING AND OUR RIBE SCHEMES. BGK [5] LV [21] Ours size of PP 5 O(λ) 19 55 size of MK 1 1 19 55 size of SK 2 3 6 9 size of KU 2 3 6 9 size of CT 4 5 6 9 # pairings 4 3 12 18 security selective adaptive adaptive adaptive anonymity No No Yes Yes assumption DBDH mDBDH SXDH DLIN We compare our schemes against Boldyreva et al.'s scheme [5], which is under the Decision Bilinear Diffie-Hellman (DBDH) assumption, and Libert and Vergnaud's scheme [21], which is under the modified DBDH (mDBDH) assumption. Overall, our schemes are anonymous, adaptively secure, and have constant-size public parameters, at the expense of bigger (but still seems acceptable) sizes in terms of the master key, private key, and key update."
    },
    {
      "heading": "D. Our Approach",
      "text": "In RIBE, different from the standard security game for IBE, the adversary is allowed to query parts of the challenge identities and time periods. Thus, to overcome the problem of increasing sizes of public parameters in the maximal number of users and sizes of the time space as analyzed in the ABE setting, our security proof makes use of two types of nominally semi-functional pairs, while all the previous works based on the dual system encryption methodology, such as [17,16,18,25], require only a single type of nominally semi-functional pair. Moreover, prior to the start of the game, we execute a preliminary game to \"locate\" the positions of the challenge identities and times. We then transform all the private keys and key updates associated with the non-challenge identities and times, respectively, into nominally semi-functional (we denote by Type I) one by one. We transform the challenge private keys and key updates (or simply keys) into nominally semi-functional (we denote by Type II) node by node at the last step. Note that the distribution of nominally semi-functional pairs of Type I for challenge identities and times can be detected by the adversary that they are different from the distribution of the semi-functional keys and ciphertexts. Moreover, nominally semi-functional pairs of Type II can be only generated for the last remaining keys; in other words, all the other keys must have been already semi-functional. This is why the preliminary game is needed. We also introduce some statistical indistinguishability arguments in our proof to show that the distributions of nominally semi-functional pair of both Types I & II remain the same as the distributions of semi-functional keys and ciphertexts from the adversary's view. Finally, we arrive at a security game that only requires to generate semi-functional keys and ciphertexts while security can be proved directly."
    },
    {
      "heading": "A. Dual Pairing Vector Spaces",
      "text": "Our constructions are based on dual pairing vector spaces proposed by Okamoto and Takashima [23,24]. In this paper, we concentrate on the asymmetric version [26]. Particularly, we give a brief description on how to generate random dual orthonormal bases. See [23,24] for a full definition of dual pairing vector spaces. Definition 1 (Asymmetric bilinear pairing groups). Asymmetric bilinear pairing groups (q, G 1 , G 2 , G T , g 1 , g 2 , e) are a tuple of a prime q, cyclic (multiplicative) groups G 1 , G 2 and G T of order q, g 1 and a polynomial-time computable nondegenerate bilinear pairing e : G 1 × G 2 → G T i.e., e(g s 1 , g t 2 ) = e(g 1 , g 2 ) st and e(g 1 , g 2 ) = 1. In addition to individual elements of G 1 or G 2 , we will also consider \"vectors\" of group elements. For v = (v 1 , . . . , v n ) ∈ Z n q and g β ∈ G β , we write g v β to denote a n-tuple of elements of G β for β = 1, 2: For any a ∈ Z q and v, w ∈ Z n q , we have: Then we define Here, the dot product is taken modulo q. Dual Pairing Vector Spaces. For a fixed (constant) dimension n, we choose two random bases B := (b 1 , . . . , b n ) and B * := (b * 1 , . . . , b * n ) of Z n q , subject to the constraint that they are \"dual orthonormal\", meaning that b i • b * j = 0 (mod q) whenever i = j, and for all i, where ψ is a random element of Z q . We denote the above algorithm, which generates the dual orthonormal bases, as Dual(•). Then for generators g 1 ∈ G 1 and g 2 ∈ G 2 , we have whenever i = j, where 1 here denotes the identity element in G T ."
    },
    {
      "heading": "B. Complexity Assumptions",
      "text": "To define the SXDH assumption, we first define DDH problems in G 1 and G 2 . Definition 2 (DDH1: Decisional Diffie-Hellman Assumption in G 1 ). Given a group generator G, we define the following distribution: . We assume that for any PPT algorithm A (with output in {0, 1}), is negligible in the security parameter λ. The dual of the Decisional Diffie-Hellman assumption in G 1 is Decisional Diffie-Hellman assumption in G 2 (denoted as DDH2), which is identical to Definitions 2 with the roles of G 1 and G 2 reversed. We say that:"
    },
    {
      "heading": "Definition 3. The Symmetric External Diffie-Hellman assumption holds if DDH problems are intractable in both",
      "text": "The following SXDH-based Subspace assumptions is from [11], which we will use in our security proof. Definition 4 (DS1: Decisional Subspace Assumption in G 1 ). Given a group generator G(•), define the following distribution: where K, N are fixed positive integers that satisfy 2K ≤ N . We assume that for any PPT algorithm A (with output in {0, 1}), is negligible in the security parameter λ."
    },
    {
      "heading": "Lemma 1.",
      "text": "If the DDH assumption in G 1 holds, then the Subspace assumption in G 1 stated in Definition 4 also holds. More precisely, for any adversary A against the Subspace assumption in G 1 , there exist probabilistic algorithms B whose running times are essentially the same as that of A, such that The dual of the Subspace assumption in G 1 is Subspace assumption in G 2 (denoted as DS2), which is identical to Definitions 4 with the roles of G 1 and G 2 reversed. Similarly, the Subspace assumption holds in G 2 if the DDH assumption in G 2 holds. We define the DLIN problem in symmetric bilinear pairing groups (namely The DLIN-based Subspace assumptions could be found in [16,25]. Definition 5 (DLIN: Decisional Linear Assumption). Given a group generator G, we define the following distribution: We assume that for any PPT algorithm A (with output in {0, 1}), ] is negligible in the security parameter λ."
    },
    {
      "heading": "III. REVOCABLE IBE",
      "text": "We first recall the definition of RIBE and its security from [5] and then define an appropriate security model for our constructions."
    },
    {
      "heading": "Definition 6. An Identity-Based Encryption with efficient revocation or simply Revocable IBE (RIBE) scheme has",
      "text": "seven PPT algorithms Setup, PriKeyGen, KeyUpd, DecKeyGen, Enc, Dec, and KeyRev with associated message space M, identity space I and time space T . We assume that the size of T is polynomial in the security parameter."
    },
    {
      "heading": "Each algorithm is run by either one of three types of parties-key authority, sender or receiver. Key authority maintains a revocation list RL and state ST. In what follows, an algorithm is called stateful if it updates RL or",
      "text": "ST. We treat time as discrete as opposed to continuous. • Setup(1 λ , N max ) takes as input a security parameter λ and a maximal number of users N max . It outputs public parameters PP, a master key MK, a revocation list RL (initially empty), and a state ST. (This is run by the key authority.) • PriKeyGen(PP, MK, id, ST) takes as input the public parameters PP, the master key MK, an identity id ∈ I, and the state ST. It outputs a private key SK id and an updated state ST. (This is stateful and run by the key authority.) • KeyUpd(PP, MK, t, RL, ST) takes as input the public parameters PP, the master key MK, a key update time t ∈ T , the revocation list RL, and the state ST. It outputs a key update KU t . (This is run by the key authority.) • DecKeyGen(SK id , KU t ) takes as input a private key SK id and key update KU t . It outputs a decryption key DK id,t or a special symbol ⊥ indicating that id was revoked. (This is deterministic and run by the receiver.) • Enc(PP, id, t, m) takes as input the public parameters PP, an identity id ∈ I, an encryption time t ∈ T , and a message m ∈ M. It outputs a ciphertext CT id,t . (This is run by the sender.) • Dec(PP, DK id,t , CT id,t ) takes as input the public parameters PP, a decryption key DK id,t , and a ciphertext CT id,t . It outputs a message m ∈ M. (This is deterministic and run by the receiver.) • KeyRev(id, t, RL, ST) takes as input an identity to be revoked id ∈ I, a revocation time t ∈ T , the revocation list RL, and the state ST. It outputs an updated revocation list RL. (This is stateful and run by the key authority.) The consistency condition requires that for all λ ∈ N and polynomials (in λ) N max , all PP and MK output by setup algorithm Setup, all m ∈ M, id ∈ I, t ∈ T and all possible valid states ST and revocation lists RL, if identity id was not revoked before or, at time t then the following experiment returns 1 except for a negligible probability: If Dec(PP, DK id,t , CT id,t ) = m then return 1 else return 0. Boldyreva et al. formalized and defined the selective-ID security for RIBE. Their definition captures not only the standard notion of selective-ID security but also takes into account key revocation. The following definition extends the security property expressed in [5] to the adaptive-ID and anonymous setting. • Setup: It is run to generate public parameters PP, a master key MK, a revocation list RL (initially empty), and a state ST. Then PP is given to A. • Query: A may adaptively make a polynomial number of queries of the following oracles (the oracles share state): -The private key generation oracle PriKeyGen(•) takes as input an identity id and runs PriKeyGen(PP, MK, id, ST) to return a private key SK id . -The key update generation oracle KeyUpd(•) takes as input time t and runs KeyUpd(PP, MK, t, RL, ST) to return a key update KU t . -The revocation oracle KeyRev(•, •) takes as input an identity id and time t and runs KeyRev(id, t, RL, ST) to update RL. • Challenge: A outputs the two challenge pair (id ). • Guess: The adversary may continue to make queries of the oracles as in Query phase and outputs a bit β ′ , and succeeds if β ′ = β. The following restrictions must always hold: 1) KeyUpd(•) and KeyRev(•, •) can be queried on time which is greater than or equal to the time of all previous queries, i.e., the adversary is allowed to query only in non-decreasing order of time. Also, the oracle KeyRev(•, •) cannot be queried at time t if KeyUpd(•) was queried on t. 2) For β = 0, 1, if PriKeyGen(•) was queried on identity id (β) then KeyRev(•, •) must be queried on (id * (β) , t) for some t ≤ t * (β) , i.e., identity id * (β) must be in RL when KeyUpd(•) is queried at time t * (β) . For β = 0, 1 let W β be the event that the adversary outputs 1 in Experiment β and define"
    },
    {
      "heading": "Definition 7. An RIBE scheme is adaptive-ID secure and anonymous if for all PPT adversaries A the function",
      "text": "Remark: The security notion of non-anonymous RIBE is defined as above with restriction that id * (0) = id * (1) and t * (0) = t * (1) . On the other hand, if the adversary A outputs (id * (0) , id * (0) ) and (id * (1) , t * (1) ) before the Setup phase, it is selective-ID security."
    },
    {
      "heading": "IV. CONSTRUCTION FROM SXDH",
      "text": "In this section, we present our first construction of RIBE and its proof of security under the SXDH assumption."
    },
    {
      "heading": "A. The Binary-tree Data Structure",
      "text": "Key revocation in our scheme relies on binary-tree data structure, as with [3,22,5,21]. We denote the binary-tree by BT and its root node by root. If ν is a leaf node then Path(ν) denotes the set of nodes on the path from ν to root (both ν and root inclusive). If θ is a non-leaf node then θ ℓ , θ r denote the left and right child of θ, respectively. We assume that all nodes in the tree are uniquely encoded as strings, and the tree is defined by all of its node descriptions. Each user is assigned to a leaf node ν. Upon registration, the key authority provides the user with a set of distinct private keys for each node in Path(ν). At time t, the key authority uses an algorithm called KUNodes to determine the minimal set Y of nodes in BT such that none of the nodes in RL with corresponding time ≤ t (users revoked on or before t) have any ancestor (or, themselves) in the set Y, and all other leaf nodes (corresponding to non-revoked users) have exactly one ancestor (or, themselves) in the set. The KUNodes algorithm takes as input a binary tree BT, a revocation list RL and a time t, and can be formally specified as follows: The KUNodes algorithm marks all the ancestors of revoked nodes as revoked and outputs all the non-revoked children of revoked nodes. The key authority then publishes a key update for all nodes of Y. A user assigned to leaf ν is then able to form an effective decryption key for time t if the set Y contains a node in Path(ν). By doing so, every update of the revocation list RL only requires the key authority to perform logarithmic work in the maximal number of users and linear in the number of revoked users."
    },
    {
      "heading": "B. Our Scheme",
      "text": "We now specify our RIBE scheme. We sometimes provide some intuition or remark at the end of an algorithm and this is marked by the symbol \"//\". • Setup(λ, N max ) On input a security parameter λ, and a maximal number N max of users, and generate a bilinear pairing G := (q, G 1 , G 2 , G T , g 1 , g 2 , e) for sufficiently large prime order q. Next perform the following steps: 1) Let RL be an empty set and BT be a binary-tree with at least N max leaf nodes, set ST = BT. 3) Output RL, ST, the public parameters and the master key MK MK := α, g 2 . • PriKeyGen(PP, MK, id, RL, ST) On input the public parameters PP, the master key MK, an identity id, the revocation list RL, and the state ST, it picks an unassigned leaf node v from BT and stores id in that node. It then performs the following steps: 1) For any θ ∈ Path(v), if α θ,1 , α θ,2 are undefined, then pick α θ,1 ← R Z q , set α θ,2 = αα θ,1 , and store them in node θ 2 . Pick r θ,1 ← R Z q and compute K id,θ := g . 2) Output SK id := {(θ, K id,θ )} θ∈Path(v) , ST. //The algorithm computes the id-component of the decryption key for all the nodes on the path from the leaf node (corresponding to id) to root. • KeyUpd(PP, MK, t, RL, ST) On input the public parameters PP, the master key MK, a time t, the revocation list RL, and the state ST, it performs the following steps: , and store them in node θ. Pick r θ,2 ← R Z q and compute 2) Output KU t := {(θ, K t,θ )} θ∈KUNodes(BT,RL,t) . //The algorithm first finds a minimal set of nodes which contains an ancestor (or, the node itself) of all the non-revoked nodes. Then it computes the t-component of the decryption key for all the nodes in that set. • DecKeyGen(SK id , KU t ) On input a private secret key SK id := {(i, K id,i )} i∈I , KU t := {(j, K t,j )} j∈J for some set of nodes I, J, it runs the following steps: 1) ∀(i, K id,i ) ∈ SK id , (j, K t,j ) ∈ KU t , if ∃(i, j) s.t. i = j then DK id,t ← (K id,i , K t,j ); else (if SK id and KU t do not have any node in common) DK id,t ← ⊥. 2) Output DK id,t . • Enc(PP, id, t, m) On input the public parameters PP, an identity id, a time t ∈ Z n q , and a message m, pick z ← R Z q and forms the ciphertext as . • Dec(PP, DK id,t , CT id,t ) On input the public parameters PP, a decryption key DK id,t := (K id,θ , K t,θ ), and a ciphertext CT id,t := (C, C 0 ), it computes the message as • KeyRev(id, t, RL, ST) On input an identity id, a time t, the revocation list RL, and the state ST, the algorithm adds (id, t) to RL for all nodes ν associated with identity id and returns RL. This ends the description of our scheme. 2 To avoid having to store α θ,1 , α θ,2 for each node, the authority can derive them from a pseudo-random function of using a shorter seed and re-compute them when necessary. Correctness: Observe that e(C 0 , K id,θ ) = e(g z(d1+idd2+td3) 1 , g Similarly, e(C 0 , K t,θ ) = e(g 1 , g 2 ) α θ,2 zd1•d * 1 . The message is recovered as:"
    },
    {
      "heading": "C. Proof of Security",
      "text": "Statistical Indistinguishability Lemmas: We require the following two lemmas, which are derived from [26], for our security proofs. Lemma 2. For p ∈ Z q , let For all (x, v) ∈ C p , for all (z, w) ∈ C p , and A ← R Z n×n q (A is invertible with overwhelming probability), , for all (z, w 1 , w 2 ) ∈ C p1,p2 , and A ← R Z n×n q (A is invertible with overwhelming probability), . The following theorem shows that our RIBE scheme is indeed adaptively secure and anonymous. Theorem 1. The RIBE scheme is adaptively secure and anonymous under the SXDH assumption. More precisely, for any adversary A against the RIBE scheme, there exist probabilistic algorithms B 0 , {B κ1,κ2 } κ1=1,...,qn 1 ,κ2=1,...,⌈log Nmax⌉ , {B κ1,κ2 } κ1=qn 1 +1,...,qn 1 +qn 2 +1,κ2=1,...,Nmax , {B qn 1 +qn 2 +1,κ2 } κ2=1,...,4Nmax whose running times are essentially the same as that of A, such that Bq n 1 +qn 2 +1,κ 2 (λ) + 6(q n1 ⌈log N max ⌉ + q n2 N max ) + 32N max + 6 q where q n1 , q n2 ≥ 4 are the maximum number of A's private key and key update queries respectively. Proof: We adopt the dual system encryption methodology by Waters [31] to prove the security of our RIBE scheme. We use the concepts of semi-functional ciphertexts and semi-functional keys in our proof and provide algorithms that generate them. Particularly, we define two types of semi-functional keys: semi-functional private keys (for identity) and semi-functional key updates (for time). We note that the algorithms (we specify below) are only provided for definitional purposes, and are not part of the RIBE system. In particular, they do not need to be efficiently computable from the public parameters and the master key."
    },
    {
      "heading": "PriKeyGenSF",
      "text": "The algorithm picks r θ,1 , ν θ,4,1 , ν θ,5,1 , ν θ,6,1 randomly from Z q and forms a semi-functional private key for node θ as . (1)"
    },
    {
      "heading": "KeyUpdSF",
      "text": "The algorithm picks r θ,2 , ν θ,4,2 , ν θ,5,2 , ν θ,6,2 randomly from Z q and forms a semi-functional updated key for node θ as t,θ := g (α θ,2 +r θ,2 t)d * 1 -r θ,2 d * 3 +[ν θ,4,2 d * 4 +ν θ,5,2 d * 5 +ν θ,6,2 d * 6 ] 2 . ( EncryptSF The algorithm picks z, χ 4 , χ 5 , χ 6 randomly from Z q and forms a semi-functional ciphertext as We call a private key or key update semi-functional if all its parts are semi-functional, which are denoted as We observe that a normal ciphertext CT id,t can be decrypted by a semi-functional key pair (K are orthogonal to all of the vectors in exponent of C 0 , and hence have no effect on decryption. Similarly, decryption of a semi-functional ciphertext CT (SF) id,t by a normal key pair (K id,θ , K t,θ ) on some node θ will also succeed because d 4 , d 5 , d 6 are orthogonal to all of the vectors in the exponent of the key. When both the ciphertext and key pair on some node are semi-functional, the result of e(C will have an additional term, namely e(g 1 , g 2 ) Decryption will then fail unless 6 i=4 (ν θ,i,1 + ν θ,i,2 )χ i ψ ≡ 0 mod q. If this modular equation holds, we say that the private key, key update and ciphertext pair is nominally semi-functional. In our security proof, there are two types of nominally semi-functional pairs: Nominally semi-functional pair of Type I Nominally semi-functional pair of Type II , Note that nominally semi-functional pair of Type I is used to transform the non-challenge private key and key update queries into semi-functional ones while Type II is for the challenge private key and key update queries. Assume that a probabilistic polynomial-time adversary A makes at most q n1 private key queries id 1 , . . . , id qn 1 and q n2 key update queries t 1 , . . . , t qn 2 . Since there are many types of adversaries according to whether the challenges id * (0) , id * (1) t * (0) , t * (1) being queried and the restriction of queries, in order to simplify and unify reduction, we add four dumb queries id qn 1 +1 , id qn 1 +2 , t qn 2 +1 , t qn 2 +2 (the keys for these queries will not be given to A), which makes the challenge identities id * (0) , id * (1) and times t * (0) , t * (1) be included in the q n1 + 2 private key queries and the the q n2 + 2 key update queries. For any adversary, we use values ϕ 1 , ϕ 2 (0 < ϕ 1 < ϕ 2 < q n1 + 2) to indicate the positions of id * (0) , id * (1) being queried, namely either the ϕ 1 -th or ϕ 2 -th query is id * (0) and the other is id * (1) . Similarly, we use values ϕ 3 , ϕ 4 (0 < ϕ 3 < ϕ 4 < q n2 + 2) to indicate the positions of t * (0) , t * (1) being queried. Our proof of security consists of the following sequence of games between the adversary A and challengers. • Game Real : is the real security game. • Game Real ′ : is a preliminary game, which is the same as Game Real except that the challenger picks 2) before setup, and the game is aborted if φ i = ϕ i for any i ∈ [4]. //Guess the positions of the challenge identities id * (0) , id * (1) and times t * (0) , t * (1) . If the guess is incorrect then the game aborts. Re-write • Game 0 : is the same as Game Real ′ except that the challenge ciphertext is semi-functional. • Game κ1,κ2 : for κ 1 from 1 to q n1 , for κ 2 from 0 to ⌈log N max ⌉, Game κ1,κ2 is the same as Game 0 except that the first κ 1 -1 private keys and the first κ 2 components of the κ 1 -th private key for Γ 1 are semi-functional and the remaining keys are normal. //Transform all private keys into semi-functional ones (one by one and node by node) except the φ 1 -th and φ 2 -th private queries. Namely, the private keys for the challenge identities id * (0) , id * (1) (if queried) are still normal. Note that the number of nodes associated with a private key is ⌈log N max ⌉. Moreover Game 1,0 and Game 0 , Game κ1,⌈log Nmax⌉ and Game κ1+1,0 are identical. • Game κ1,κ2 : for κ 1 from q n1 + 1 to q n2 , for κ 2 from 0 to N max , Game κ1,κ2 is the same as Game qn 1 ,⌈log Nmax⌉ (namely all private keys for Γ 1 are semi-functional) except that the first κ 1q n1 -1 key updates and the first κ 2 components of the (κ 1q n1 )-th key update for Γ 2 are semi-functional and the remaining key updates are normal. //Transform all key updates into semi-functional ones (one by one and node by node) except the φ 3 -th and φ 4 -th key update queries. Namely, the key updates for the challenge times t * (0) , t * (1) (if queried) are still normal. Note that a key update for a time updates at most N max nodes. Moreover, Game qn 1 ,⌈log Nmax⌉ and Game qn 1 +1,0 , Game κ1,Nmax and Game κ1+1,0 are identical. • Game qn 1 +qn 2 +1,κ2 : for κ 2 from 0 to 4N max , Game qn 1 +qn 2 +1,κ2 is the same as Game qn 1 +qn 2 ,Nmax (namely all private keys for Γ 1 and key updates for Γ 2 are semi-functional) except that the φ 1 , φ 2 -th private keys, the φ 3 , φ 4 -th key updates for the first κ 2 nodes are semi-functional and the remaining keys are normal. //Transform the ϕ 1 , ϕ 2 -th private key and the ϕ 3 , ϕ 4 -th key update queries into semi-functional ones (node by node). Note that there are at most 2 ⌈log Nmax⌉ (≤ 4N max ) nodes in the binary tree. Moreover, Game qn 1 +qn 2 ,Nmax and Game qn 1 +qn 2 +1,0 are identical, namely all keys are semi-functional in Game qn 1 +qn 2 +1,4Nmax . • Game F inal : is the same as Game qn 1 +qn 2 +1,4Nmax , except that the challenge ciphertext is a semi-functional encryption of a random message in G T and under a random identity in Z q a random time in Z q . We denote the challenge ciphertext in Game F inal as CT (R) id (R) ,t (R) . We prove the following lemmas to show the above games are indistinguishable. The advantage gap between Game Real and Game 0 is bounded by the advantage of the Subspace assumption in G 1 . Additionally, we require a statistical indistinguishability argument to show that the distribution of the challenge ciphertext remains the same from the adversary's view. Similarly, the advantage gap between any two consecutive games of Game 1,1 to Game qn 1 +qn 2 +1,4Nmax is bounded by the advantage of Subspace assumption in G 2 . Finally, we statistically transform Game qn 1 +qn 2 +1,4Nmax to Game F inal in one step, i.e., we show the joint distributions of parameters in these two games are equivalent from the adversary's view."
    },
    {
      "heading": "Lemma 4. For any adversary A, Adv Game",
      "text": "Proof: Since φ 1 , φ 2 , φ 3 , φ 4 are uniformly and independently generated, which are hidden from the adversary A's view. The game is non-aborted with probability 4 (q n1 + 2)(q n1 + 1)(q n2 + 2)(q n2 + 1) . Thus, Lemma 5. Suppose that there exists an adversary A where |Adv Then there exists an algorithm B 0 such that Adv DS1 B0 (λ) = ǫ + 2 q , with K = 3 and N = 6. Proof: B 0 is given along with T 1 , T 2 , T 3 . We require that B 0 decides whether T 1 , T 2 , T 3 are distributed as g τ1b1 B 0 simulates Game Real ′ or Game 0 with A, depending on the distribution of T 1 , T 2 , T 3 . To compute the public parameters and master key, B 0 chooses a random invertible matrix A ∈ Z 3×3 q (A is invertible with overwhelming probability if it is uniformly picked) and implicitly sets dual orthonormal bases D, D * to: We note that D, D * are properly distributed, and reveal no information about A. Moreover, B 0 cannot generate 2 , g 2 , but these will not be needed for creating normal private keys and key updates. B 0 chooses random value α ∈ Z q and computes g α T := e(g 1 , g 2 ) αd1•d * 1 . It then gives A the public parameters The master key is known to B 0 , which allows B 0 to respond to all of A's queries by calling the normal private keys, key updates, and key revocation algorithms. ). B 0 chooses a random bit β ∈ {0, 1} and encrypts m * (β) under (id * (β) , t * (β) ) as follows: where B 0 has implicitly set z := τ 1 . It gives the ciphertext (C, C 0 ) to A. , then this is a properly distributed normal encryption of m * (β) . In this case, B 0 has properly simulated Game Real ′ . If T 1 , T 2 , T 3 are equal to g τ1b1+τ2b4 1 , g τ1b2+τ2b5 1 , g τ1b3+τ2b6 1 instead, then the ciphertext element C 0 has an additional term of in its exponent. The coefficients here in the basis b 4 , b 5 , b 6 form the vector (τ 2 , id * (β) τ 2 , t * (β) τ 2 ). To compute the coefficients in the basis d 4 , d 5 , d 6 , we multiply the matrix A -1 by the transpose of this vector, obtaining Since A is random (everything else given to A has been distributed independently of A), these coefficients are uniformly random except with probability 2/q (namely, the cases τ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) defined in Equation 3 is the zero vector ) from Lemma 2. Therefore, in this case, B 0 has properly simulated Game 0 . This allows B 0 to leverage A's advantage ǫ between Game Real ′ and Game 0 to achieve an advantage ǫ + 2 q against the Subspace assumption in G 1 , namely Adv DS1 B0 (λ) = ǫ + 2 q . Lemma 6. For κ 1 from 1 to q n1 , for κ 2 from 0 to ⌈log N max ⌉, suppose that there exists an adversary A where Then there exists an algorithm B κ1,κ2 such that Adv DS2 Bκ 1 ,κ 2 (λ) = ǫ + 6 q , with K = 3 and N = 6. Proof: B κ1,κ2 is given along with T 1 , T 2 , T 3 . We require that B κ1,κ2 decides whether T 1 , T 2 , T 3 are distributed as g B κ1,κ2 simulates Game κ1,κ2 or Game κ1,κ2-1 with A, depending on the distribution of T 1 , T 2 , T 3 . To compute the public parameters and master key, B κ1,κ2 chooses a random matrix A ∈ Z 3×3 q (with all but negligible probability, A is invertible). We then implicitly set dual orthonormal bases D, D * to: We note that D, D * are properly distributed, and reveal no information about A. B κ1,κ2 chooses random value α ∈ Z q and compute g α T := e(g 1 , g 2 ) αd1•d * 1 . B can gives A the public parameters The master key is known to B κ1,κ2 , which allows B κ1,κ2 to respond to all of A's private key and key update queries by calling the normal key generation algorithm. Since B κ1,κ2 also knows g 2 , and g 2 , it can easily produce semi-functional keys. To answer the key queries that A makes, B κ1,κ2 runs the semi-functional private key and key update generation algorithm to produce semi-functional keys and gives these to A. To answer the κ 2 -th component of the κ 1 -th private key for id ′ κ1 , B κ1,κ2 responds with: This implicitly sets r θ, , then this is a properly distributed normal private key. Otherwise, if T 1 , T 2 , T 3 are equal to g , then this is a semi-functional key, whose exponent vector includes as its component in the span of b * 4 , b * 5 , b * 6 . To respond to the remaining key queries, B κ1,κ2 simply runs the normal key generation algorithm. At some point, A sends B κ1,κ2 two pairs (id ). B 0 chooses a random bit β ∈ {0, 1} and encrypts m * (β) under (id * (β) , t * (β) ) as follows: 2 where B κ1,κ2 has implicitly set z := µ 1 . The \"semi-functional part\" of the exponent vector here is: We observe that if id * (β) = id ′ κ1 (which is impossible), then vectors 4 and 5 would be orthogonal, resulting in a nominally semi-functional ciphertext and key pair (B κ1,κ2 can also use T 1 , T 2 , T 3 to generate private key part for Using the change of basis matrix A, we obtain the new coefficients (in vector form) as: Since the distribution of everything given to A except for the κ 2 -th component of the κ 1 -th private key K id ′ κ 1 ,θ and the challenge ciphertext (C, C 0 ) is independent of the random matrix A and id * (β) = id ′ κ1 , we can conclude that these coefficients are uniformly except with probability 4/q (namely, the cases µ 2 or τ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) or (ν θ,4,1 , ν θ,5,1 , ν θ,6,1 ) defined in Equations 3 and 1 is the zero vector) from Lemma 2. Thus, B κ1,κ2 has properly simulated Game κ1,κ2 in this case. , then the coefficients of the vector 5 are uniformly except with probability 2/q (namely, the cases µ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) defined in Equations 3 is the zero vector) from Lemma 2. Thus, B κ1,κ2 has properly simulated Game κ1,κ2-1 in this case. In summary, B κ1,κ2 has properly simulated either Game κ1,κ2-1 or Game κ1,κ2 for A, depending on the distribution of T 1 , T 2 , T 3 . It can therefore leverage A's advantage ǫ between these games to obtain an advantage ǫ + 6 q against the Subspace assumption in G 2 , namely Adv DS2 Bκ (λ) = ǫ + 6 q . Lemma 7. For κ 1 from q n1 +1 to q n1 +q n2 , for κ 2 from 0 to N max , suppose that there exists an adversary A where Then there exists an algorithm B κ1,κ2 such that Adv DS2 Bκ 1 ,κ 2 (λ) = ǫ + 6 q , with K = 3 and N = 6. Proof: B κ1,κ2 is given along with T 1 , T 2 , T 3 . We require that B κ1,κ2 decides whether T 1 , T 2 , T 3 are distributed as g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2 or g τ1b * 1 +τ2b * 4 2 , g τ1b * 2 +τ2b * 5 2 , g τ1b * 3 +τ2b * 6 2 . B κ1,κ2 simulates Game κ1,κ2 or Game κ1,κ2-1 with A, depending on the distribution of T 1 , T 2 , T 3 . To compute the public parameters and master key, B κ1,κ2 chooses a random matrix A ∈ Z 3×3 q (with all but negligible probability, A is invertible). We then implicitly set dual orthonormal bases D, D * to: We note that D, D * are properly distributed, and reveal no information about A. B κ1,κ2 chooses random value α ∈ Z q and compute g α T := e(g 1 , g 2 ) αd1•d * 1 . B can gives A the public parameters The master key is known to B κ1,κ2 , which allows B κ1,κ2 to respond to all of A's private key and key update queries by calling the normal key generation algorithm. Since B κ1,κ2 also knows g 2 , g 2 , and g 2 , it can easily produce semi-functional keys. To answer the key queries that A makes, B κ1,κ2 runs the semi-functional private key and key update generation algorithm to produce semi-functional keys and gives these to A. To answer the κ 2 -th component of the κ 1 -th private key for id ′ κ1 , B κ1,κ2 responds with: This implicitly sets r θ,1 := τ 1 . If T 1 , T 2 , T 3 are equal to g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2 , then this is a properly distributed normal private key. Otherwise, if T 1 , T 2 , T 3 are equal to g τ1b * 1 +τ2b * 4 2 , g τ1b * 2 +τ2b * 5 2 , g τ1b * 3 +τ2b * 6 2 , then this is a semi-functional key, whose exponent vector includes id ′ κ1 τ 2 b * 4τ 2 b * 5 (6) as its component in the span of b * 4 , b * 5 , b * 6 . To respond to the remaining key queries, B κ1,κ2 simply runs the normal key generation algorithm. At some point, A sends B κ1,κ2 two pairs (id * (0) , t * (0) , m * (0) ) and (id * (1) , t * (1) , m * (1) ). B 0 chooses a random bit β ∈ {0, 1} and encrypts m * (β) under (id * (β) , t * (β) ) as follows: where B κ1,κ2 has implicitly set z := µ 1 . The \"semi-functional part\" of the exponent vector here is: We observe that if id * (β) = id ′ κ1 (which is impossible), then vectors 6 and 7 would be orthogonal, resulting in a nominally semi-functional ciphertext and key pair (B κ1,κ2 can also use T 1 , T 2 , T 3 to generate private key part for t * (β) ) of Type I. It gives the ciphertext (C, C 0 ) to A. We now argue that since id * (β) = id ′ κ1 , in A's view the vectors 6 and 7 are distributed as random vectors in the spans of d * 4 , d * 5 , d * 6 and d 4 , d 5 , d 6 respectively. To see this, we take the coefficients of vectors 6 and 7 in terms of the bases b * 4 , b * 5 , b * 6 and b 4 , b 5 , b 6 respectively and translate them into coefficients in terms of the bas"
    },
    {
      "heading": "VI. CONCLUSIONS",
      "text": "In this paper, we presented two efficient RIBE schemes under the SXDH and the DLIN assumptions, respectively, which overcome the existing problem of increasing sizes of public parameters. In comparison with the existing schemes of [5,21], our RIBE schemes are adaptively secure, anonymous and have constant-size public parameters, although they have larger sizes of keys and ciphertexts. Our RIBE schemes can be extended very naturally to obtain revocable IPE schemes with weakly attribute-hiding [24,26]. Also our techniques can be applied to a more generally setting, for example, the ABE schemes of [26] to obtain adaptively secure revocable ABE schemes."
    }
  ]
}