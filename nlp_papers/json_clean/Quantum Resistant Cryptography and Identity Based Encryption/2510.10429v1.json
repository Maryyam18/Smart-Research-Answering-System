{
  "paperid": "2510.10429v1",
  "title": "QUANTUM-RESISTANT CRYPTOGRAPHY VIA UNIVERSAL GR ÖBNER BASES",
  "authors": [
    "Da",
    "And",
    "Stewart",
    "Bardet",
    "Faugére",
    "Salvy",
    "Barkee",
    "Can",
    "Ecks",
    "Moriarty",
    "Ree",
    "Barkee",
    "Ceria",
    "Moriarty",
    "Visconti",
    "Bell-Colley",
    "Bernstein",
    "Caboara",
    "Caruso",
    "Traverso",
    "Couvreur",
    "Mora",
    "Tillch",
    "Cox",
    "Little",
    "O'shea",
    "Cox",
    "Little",
    "Schenck",
    "Cummings",
    "Silva",
    "Rajchgot",
    "Van Tuyl",
    "Silva",
    "Naguit",
    "Rajchgot",
    "Loera",
    "Hemmecke",
    "Tauzera",
    "Yoshidab",
    "Loera",
    "Sturmfels",
    "Thomas",
    "Dubé",
    "Eisenbud",
    "Fukuda",
    "Jensen",
    "Thomas",
    "Galetto",
    "Hofscheier",
    "Keiper",
    "Kohne",
    "Paczka",
    "Van Tuyl",
    "Jensen",
    "Jensen",
    "Lou",
    "Liu",
    "Mehta",
    "Ali",
    "Nachman",
    "Stackpole",
    "Stamatiou",
    "Tatakis",
    "Sturmfels",
    "Tatakis",
    "Thoma",
    "Theobald",
    "Villarreal",
    "Willsch",
    "Hanussek",
    "Hoever",
    "Willsch",
    "Jin",
    "Raedt",
    "Michielsen",
    "Willsch",
    "Willsch",
    "Jin",
    "Raedt",
    "Michielsen"
  ],
  "year": 2025,
  "abstract": "In this article, we explore the use of universal Gröbner bases in public-key cryptography by proposing a key establishment protocol that is resistant to quantum attacks. By utilizing a universal Gröbner basis U I of a polynomial ideal I as a private key, this protocol leverages the computational disparity between generating the universal Gröbner basis needed for decryption compared with the single Gröbner basis used for encryption. The security of the system lies in the difficulty of directly computing the Gröbner fan of I required to construct U I . We provide an analysis of the security of the protocol and the complexity of its various parameters. Additionally, we provide efficient ways to recursively generate U I for toric ideals of graphs with techniques which are also of independent interest to the study of these ideals.",
  "sections": [
    {
      "heading": "Introduction",
      "text": "Cryptographic systems often rely on the computational difficulty of solving particular mathematical problems. Quantum computing is a rapidly growing industry [22] with reports of capable quantum systems being available by as soon as 2030, making postquantum cryptography especially relevant while also threatening the security of traditional cryptographic methods [28]. For example, the commonly used RSA cryptosystem, which relies on the difficulty of factoring the product of two (secret) large prime numbers [20], would no longer remain secure using Shor's algorithm on a quantum computer [29]. As the vulnerabilities facing cryptographic systems becomes a reality, it is necessary to explore other approaches and techniques that might prove more useful in resisting quantum attacks. One promising area of exploration is with primitives that utilize algebraic or combinatorial constructions, especially in the context of lattice-based cryptography. Many algebraic constructions utilize computational aspects of ideals in polynomial rings [6,7], making Gröbner bases a natural component in their implementation [15]. Gröbner bases are specific generators of a polynomial ideal that allow many algebro-geometric properties to be computed efficiently from an associated monomial ideal. Past attempts to use Gröbner bases in public-key cryptography have failed, such as with Barkee cryptosystems [2,3]. The main obstacle to these approaches is that a single Gröbner basis is generally too easy to compute to realistically be used to secure a system. A universal Gröbner basis on the other hand is difficult to compute, and involves the computation of high-dimensional lattice structures like the Gröbner fan and state polytope of a polynomial ideal. Our approach is to have one party use a universal Gröbner basis to produce a private list of keys while also having a public mechanism for another party to generate one key from that list. Let A and B be two parties who have not previously communicated to share a common encryption key. To establish the protocol P, Party A starts with an ideal I ⊂ K[x 1 , . . . , x n ], a universal Gröbner basis U I of I, and some generating set R I of I. Then R I , K, and the number of variables is made public, together with information about the encryption scheme needed to create the ciphertext, including two hash functions η and τ . The protocol P can be defined without the use of τ , in which case we set τ = ∅. Now Party B can send an encrypted message to A using the information publicly provided by A. Party B starts by choosing a random monomial order < B of K[x 1 , . . . , x n ] and then computes the initial ideal in < B ⟨R I ⟩. Both < B and the initial ideal are kept private. By Dickson's lemma, there is a unique minimal generating set of in < B ⟨R I ⟩, and based on a public hash function η provided by A, Party B converts this set into a binary sequence which will serve as the encryption key K B . Using the predetermined encryption scheme E provided, B encrypts the message into a ciphertext. If τ = ∅, then only this ciphertext is sent back to A. Otherwise, τ (K B ) is also sent back to A. The protocol can be described using the following schematic: First suppose that τ = ∅. If an attacker were to intercept the ciphertext, they wouldn't know what parameters B chose to produce the ciphertext, so a brute-force attack would be intractable. For instance, with RSA public-key cryptography, an attacker at least knows the product m = pq (which is public) and could try to find a brute-force factorization of m. With our setup, if an RSA encryption algorithm E were used to create a ciphertext, m would remain hidden, so an attacker wouldn't even know what number to attempt to factor. This added security comes at a cost. Since Party A will also not know which key Party B chose, the only option is to try all possible keys to decrypt the message. However, A has the universal Gröbner basis U I , and therefore possesses the list of all possible initial ideals of I, and hence has the list of all possible encryption keys that B could have generated. The list that Party A needs to exhaustively search to decrypt the message is reasonable compared to the intractable list that an attacker would need to try. The system also relies on U I being extremely difficult to compute directly without prior knowledge of any symmetries used to construct I. On the other hand, if τ ̸ = ∅, then A could decrypt the message without iterating through the list of keys since the image of each key under τ would already be known and could be compared with the value τ (K B ) provided by B. However, this reduces the overall security of the system since an attacker intercepting the message would also have knowledge of τ (K B ), and could try attacking τ instead of computing U I directly. We summarize the analysis of the protocol P presented in this article in the following theorem. Theorem. Let P = (n, K, U I , R I , < B , η, E, τ ) be a protocol as in Definition 3.1. Then the following statements about the complexity and security of the cryptosystem hold: • Party A can (privately) construct U I in polynomial time by using Theorem 5.12. Given U I , the set R I can be computed in linear time by Theorem 4.5. • Party B can send a message to A by computing a single Gröbner basis for I, the complexity of which is summarized in Theorem 4.6. • The amount of time that A requires to decrypt the ciphertext when τ = ∅ is summarized in Proposition 4.9. • An attacker without any trapdoor knowledge about how I was constructed would need to compute the Gröbner fan of I directly, which is NP-hard with complexity described in Theorem 4.1. • By Theorem 4.3, if lattice-based primitives secured by the Shortest Vector Problem (SVP) are quantum-resistant, then so is the protocol P when τ = ∅. A more detailed discussion of the steps involved to initialize the protocol P is presented in Section 3. We then consider practical complexity and security issues in Section 4 and subsequently describe how to efficiently construct U I in Section 5 using the toric ideal I G of a graph G. This ideal can be generated by binomials corresponding to primitive closed even walks of G, which incidentally also define a universal Gröbner basis of I G . Using four graph operations, one can recursively generate large graphs for which U I is computable and contains enough primitive closed even walks to ensure the security of P. It is worth noting that the graph constructions presented in Section 5, together with their effect on U I , are of independent importance to combinatorial algebraists [4,21,25,27]. For instance, previous research in this area has revealed connections with algebraic statistics [13], commutative-algebraic techniques [10,17], and network complexity [11]. In the final section of this article, we will discuss weaknesses and practical concerns regarding the protocol P. We also identify areas for potential future research. Acknowledgments. We thank Sarah Arpin for many helpful conversations and references on post-quantum cryptography. Da Silva's research is supported by NSF LEAPS-MPS Grant 2532757."
    },
    {
      "heading": "Preliminaries",
      "text": "In this paper, K will denote any field. In this section, we will provide a very brief overview of Gröbner bases, Gröbner fans and state polytopes. There is a considerable amount of theory involved with these topics, so we provide only what is necessary to understand the subsequent sections, and refer the reader to [8,15,24] for further details."
    },
    {
      "heading": "Gröbner bases.",
      "text": "Gröbner theory provides a way to associate a monomial ideal in < (I) to an ideal I ⊂ R = K[x 1 , . . . , x n ]. This is done in such a way that many algebrogeometric properties of I can be determined from in < (I), especially since monomial ideals are generally easier to study. A monomial order < on R is a total order on the monic monomials of R such that u ≤ v ⇒ wu ≤ wv and 1 ≤ w for any monomial w ∈ R. Given α = (α 1 , α 2 , . . . , α n ) ∈ Z n ≥0 , we will use the notation With a monomial order < on R and a polynomial f ∈ R, we can order all terms of f and define the initial term of f as the monomial in < (f ) = cx α , c ∈ K, which is greatest term of f with respect to <. Definition 2.1. Let < be a monomial order on R and let I ⊆ R be an ideal. The initial ideal of I, denoted by in < (I), is the monomial ideal in R defined by Unfortunately, the initial terms of a generating set of I do not generally constitute a generating set of in < (I). This leads us to the definition of a Gröbner basis. Definition 2.2. Given an ideal I ⊆ R, a set G = {g 1 , . . . , g t } ⊂ I is a Gröbner basis for I if I = ⟨g 1 , . . . , g t ⟩ and in < (I) = ⟨in(g 1 ), . . . , in(g t )⟩. A universal Gröbner basis U I for an ideal I is a generating set for I which is a Gröbner basis for I with respect to any monomial order on R. which implies that G is a Gröbner basis for I with respect to < 1 . If however we used the lexicographic monomial ordering < 2 defined by d > a > b > c > e > f > g, we would get in < 2 (I) = ⟨ag, bdf, dg⟩. Therefore, for < 2 , G is not a Gröbner basis for I. To extend G to a Gröbner basis of I with respect to < 2 , we would need to include the polynomial which is found by applying Buchberger's algorithm. This involves computing the Spolynomials between pairs of generators, finding the remainder after polynomial division by G, and extending G by adjoining any non-zero remainders. This process is repeated until all remainders are 0. For specifics about the algorithm, refer to [8]. □ Although Buchberger's algorithm provides a method for constructing a Gröbner basis for any given I ⊆ R with respect to some given monomial order <, modern techniques have become more sophisticated and differ from the S-polynomial computation above [1]. A fundamental result in the theory of monomial ideals is Dickson's Lemma which states that every monomial ideal has a unique minimal monomial generating set. If some fixed monomial order of R is also given, then every monomial ideal of R will have a unique minimal ordered generating set. Lemma 2.4. Given a monomial order < on R = K[x 1 , . . . , x n ] and a monomial ideal M ⊆ R, there exists a unique minimal monomial ordered generating set of M . We will be applying hash functions to sets of monomial generators, so having a unique way to write a given list of monomials is necessary. In defining the cryptosystem presented in the next section, we will also discuss sets of minimal monomial ideal generators which have bounded exponents, so we conclude this section with the following definition. Definition 2.5. We say that a set of monomials {x α 1 , . . . , x αr } ⊂ R = K[x 1 , . . . , x n ] is minimal if it is the unique minimal monomial generating set of the ideal ⟨x α 1 , . . . , x αr ⟩. Then define M k to be the set there is a formal combinatorial structure for enumerating all possible initial ideals of I. We first need to define what it means for two monomial orders to be equivalent, which is best done in the more general setting of weight orders. Definition 2.6. Given a polynomial ring R = K[x 1 , . . . , x n ] and weight vector w = (w 1 , . . . , w n ) ∈ R n , we can define a weight order < w on R by Remark 2.7. For a fixed I and monomial order < on R, there exists a weight w ∈ R n such that in < (I) = in <w (I). In fact, every monomial order is a weight order, but not every weight order is a monomial order. In particular, in <w (•) does not necessarily yield a unique initial monomial term for every choice of w. As an example, let f = x 2 y+x 10 -y 2 ∈ K[x, y] and w = (2, 10). Then in <w (f ) = x 10 -y 2 . Given an ideal I, we can define an equivalence relation ∼ on R n as w 1 ∼ w 2 if and only if in <w 1 (I) = in <w 2 (I). If the initial ideal is a monomial ideal, then the collection of weight vectors in that equivalence class define a maximal cone in R n and the union of these cones is called the Gröbner fan of I, denoted by GF an(I). We will refer to a maximal cone in GF an(I) as a Gröbner region (or Gröbner cone), and denote it by GR < (I). Here, GR < (I) has a representative weight order < and corresponds to a distinct monomial initial ideal of I together with a marked reduced Gröbner basis G < for I. The union of these reduced Gröbner bases defines a universal Gröbner basis of I. See [24] for more information about Gröbner fans, and for proofs of these facts. The Gröbner fan is the normal fan of a polytope [24, Theorem 2.5] called the state polytope of I, and is denoted by State(I). See [9] for more information on correspondence between normal fans and convex polytopes. With this structure, we now turn to the question of how to compute a Gröbner fan of an ideal I. Our protocol uses keys which are defined by initial ideals of I, so each Gröbner region of GF an(I) defines a distinct key that can be used for encryption. Indeed, if an attacker with no knowledge about how I or U I were constructed wanted to compute U I directly from I, they would need to first compute the Gröbner fan of I, and then take a union of all Gröbner basis representatives for the cones in the fan. In [24, Section 7], Sturmfels proposed an algorithm for computing GF an(I), which was later implemented with the Gfan package [19] of Macaulay2. An analysis of the complexity of the algorithm was considered in [16]. In this algorithm, there are three main steps that are iterated at each vertex of State(I) (i.e. at each vertex of the graph of the polytope State(I)). We refer the reader to the aforementioned sources for the technical details of the algorithm, and only provide a very brief summary of the nature of each step below. In the algorithm, we start with one known Gröbner region of the fan (e.g. by directly computing a Gröbner basis with respect to some order). We then travel from one maximal cone to a neighboring maximal cone while also computing a Gröbner basis representative for the new cone by a mutation of the Gröbner basis for the current one. (1) Each fan can be viewed as the normal fan to a dual object called a state polytope State(I). The graph (V, E) of the Gröbner fan is the 1-skeleton of State(I). Each vertex in the polytope corresponds to a cone in GF an(I). Computing normal vectors to facets for this polytope requires time denoted by T facets . (2) Starting at a vertex, we choose a sequence of admissible \"shoot\" edges in State(I) until all vertices have been reached (using a reverse search algorithm). Selecting these admissible search edges requires time denoted by T shoot . (3) With an admissible edge chosen, there exists an operation to change the marked Gröbner basis for one vertex to a marked Gröbner basis for another vertex. This is called a \"flip\" procedure and is the most time consuming step to complete. The time for this procedure is denoted by T flip . Remark 2.9. We will later compare the complexity of computing GF an(I) with other lattice-based primitives. Since the construction of GF an(I) involves cones in R n , we can always choose a weight vector w in each cone with only integer entries. This allows us to view GF an(I) and State(I) as lattice constructions by intersecting with Z n ."
    },
    {
      "heading": "A quantum-resistant key establishment protocol",
      "text": "In this section we will introduce a public encryption protocol that uses Gröbner bases for symmetric key establishment. The main idea is to leverage the difficulty in computing a universal Gröbner basis of a polynomial ideal compared to the computational time needed to compute a single Gröbner basis. We start by providing an example which illustrates the spirit of the algorithm, and in the subsequent section, we formally describe the protocol parameters and implementation. Experts who wish to only consider the formal description of the protocol rather than a particular small-scale implementation may skip to Section 3.2. 3.1. An illustrative example. Let A and B be two parties who wish to securely communicate but have not previously communicated to share a common key. In this example, B would like to send an encrypted message to A using information publicly provided by A. Specific (simple) choices of protocol parameters have been chosen for this example. Suppose that A has an ideal I for which a universal Gröbner basis U I is known. For this example, suppose that is an ideal, where K is any field and a, . . . , g are indeterminates of the polynomial ring. This list of generators is kept private and provides Party A with a fast way to compute initial ideals of I (see Section 2.2 for a background on Gröbner fans). A second list of minimal generators R I is also computed for I. For instance, A may choose It is worth noting that ace -bdf = a(ce -dg) + d(ag -bf ), so these generators still define the ideal I, but do not always form a Gröbner basis of it, depending on the monomial order. Party A then makes R I , K, and the number of variables public, together with information about the encryption scheme. Suppose that B would like to send A a secure message. B proceeds to produce an encryption key using that public information that A has provided. They do this by randomly selecting some monomial order < B of K[a, . . . , g], and then proceeds to compute in < B ⟨R I ⟩. Both < B and the initial ideal are kept private. There is a unique minimal generating set for this monomial ideal by Lemma 2.4, and based on a public hash function η provided by A, converts this monomial ideal into an encryption key. For this example, At this point, B would apply η to {bf, ce}. As an overly simplified method for generating an encryption key for this example, let us concatenate the exponent vectors of each minimal monomial generator (using a predefined order from the function provided by A). Therefore, B's private encryption key is K B = 01000100010100 which is used to encrypt a message using whatever encryption scheme E Party A has made public. For instance, the encryption scheme may involve using K B to generate two large primes from a hash function attached to E and encrypt a message using the RSA encryption scheme (without making the product of the two primes public -even to A). In the first version of the protocol, only this ciphertext is sent to A. With U I , A will have the list of all possible initial ideals of I, and therefore will have a list of all possible encryption keys that B could have generated. For this example, those keys are: Party A then tries each key (by a brute-force search) until the message is decrypted. Using some symmetric encryption algorithm E instead of an asymmetric one would reduce the computational time for Party A. In an alternate version of the protocol, a hash function τ is also made public that is used to map K B to some binary sequence. Then, together with the ciphertext, Party B also sends τ (K B ). Party A, having all possible values of τ applied to each key, would then know which K B was chosen, and could decrypt the message immediately. This comes at the cost of reduced security for P. We will now summarize each step of the protocol and briefly highlight security issues which are elaborated on in Section 4: (1) Party A is assumed to have a universal Gröbner basis U I for some ideal I ⊂ K[x 1 . . . , x n ] and some trimmed generating set R I . This trimmed list is made public, together with a list of conventions needed for B to establish an initialization vector. A method for A to quickly find examples of I and U I can be found in Section 5. The complexity of computing R I can be found in Theorem 4.5. (2) If B wants to send a message to A, then a monomial order < B needs to be chosen, and the initial ideal in < B ⟨R I ⟩ needs to be computed. This can be done relatively quickly, as described in Theorem 4.6. By Lemma 2.4, there exists a unique minimal generating set of in < B ⟨R I ⟩. B uses this unique generating set to produce an encryption key using a function η provided by A. The message is then encrypted using the encryption scheme E (also publicly provided by A). (3) If τ is not provided, then Party B only sends the ciphertext to A, keeping all other parameters private. If an attacker intercepts the message, they would not know which encryption key was used to create the message, and reducing the list of possible keys to a manageable list would require knowledge of U I . An analysis of the complexity of doing this and the general security of the system can be found in Section 4.1. If τ is provided, then Party B would also send τ (K B ) together with the ciphertext. ( 4) Since A has a list of all possible initial ideals of I (which defines a Gröbner fansee Section 2.2), they also have a list of all possible encryption keys. The message can then be decrypted by trying each one (in the case that τ is not provided). The time complexity for this is described in Section 4.2. Variations that help cut down A's decryption time are also discussed there. In the case when τ is provided, Party A could decrypt the ciphertext without iterating over all keys. This protocol relies on the fact that it is both time consuming to enumerate all potential encryption keys and to directly try and generate a universal Gröbner basis for I. Therefore, an attacker would need to spend an unreasonable amount of time and resources to decrypt the message, unless they already had a universal Gröbner basis for I. If this is the case, then how is it possible for A to even initialize the system? Using a combinatorial approach, we will show how to efficiently generate examples with symmetries that are kept private but for which U I is easy to compute."
    },
    {
      "heading": "Protocol Parameters.",
      "text": "As seen in the previous section, there are a number of parameters which can be chosen when setting up this cryptosystem. We provide the theoretical framework for this protocol and leave choices of specific parameters unspecified, recognizing that there may be practical implementation concerns that may require flexibility. Definition 3.1. Let P = (n, K, U I , R I , < B , η, E, τ ) be a tuple of parameters defined by: • η : M → {0, 1} s is a hash function on sets of monomials whose domain contains M k (see Definition 2.5) to binary strings of fixed length s. • E is an encryption algorithm with an encryption key K and plaintext X as input, and whose output is a ciphertext E(K, X). • τ is either a hash function on binary sequences {0, 1} s , or is set to ∅ if not being utilized. Let A and B be two parties who wish to securely communicate but have not previously communicated to share a common key. For a protocol defined with τ ̸ = ∅, the value τ (K B ) is also sent: (IV) Decryption: Since A has a universal Gröbner basis U I , they possess all possible initial ideals in < (I), and hence possess all possible encryption keys K I . If τ = ∅, then for each κ ∈ K I , A can compute E -1 (κ, E(K B , X B )) until the message is decrypted by brute force (choosing E to be a symmetric encryption algorithm will reduce this computational time). For a protocol defined with τ ̸ = ∅, Party A also has the list τ (K I ), and hence knows which K B was used to produce τ (K B ), and can therefore immediately compute Remark 3.2. When τ = ∅ and Party A needs to iterate over all encryption keys, there is a question of how they will know when the ciphertext has been correctly decrypted. Besides being a readable message, one method is to require the message to contain some embedded marker defined from E. With this language, there are infinitely many cryptosystems that can be initialized, depending on the parameters of P. We will discuss the security of this system and how to compute each component in Section 4. For now, we show that even if a breach were to occur where U I were made public, the cryptosystem still provides a reasonable amount of security. In particular, the number of operations needed to conduct a brute-force attack of a system where U I is public is O(m r ). Proof. Any potential initial ideal of I can be read off from U I by picking one term from each f ∈ U I . There are at most m such terms for each f , leaving at most m r many possibilities. The remaining operations of converting each list of monomials to an encryption key via η, and decrypting the message using E -1 is some constant multiple of m r (for bounded key and message sizes). □ Remark 3.4. Note that each potential list of monomials from the proof of Proposition 3.3 may not produce a valid initial ideal since there may not exist a monomial order of K[x 1 , . . . , x n ] which yields that particular list of monomials (for example, there is no monomial order which picks x 1 x 2 as an initial term of ). We also saw this in Section 3.1 where there were a priori 2 3 possible lists of monomials, but only 5 defined actual keys. In another extreme, suppose that U I remains private and an attacker wanted to generate all potential encryption keys for a system P without computing a universal Gröbner basis for I. They would need to generate all encryption keys using η associated to M k . With the assumption that the allowed exponent vectors have entries strictly smaller than k, the number of possible encryption keys is a doubly exponential in n. Even in the square-free case where k = 2, a brute-force attack would be unwieldy. In particular, the number of operations needed to conduct a brute-force attack of a system Proof. There are exactly k n monomials in K[x 1 , . . . , x n ] whose exponent vector entries are bounded above by k. A minimal generating set of a monomial ideal is a subset of this list of monomials, so the number of possible subsets is 2 k n . Different choices of a subset may result in the same monomial ideal, but each subset results in one case that needs to be checked. The complexity bound follows similarly to the proof of Proposition 3.3. □ Remark 3.6. An attacker could also try to compute all possible initial ideals of I by enumerating all monomial orders on K[x 1 , . . . , x n ] and computing a Gröbner basis directly for each one. Using only the lexicographic orders shows that this approach has at least n! cases to check (there are also other monomial orders which are not equivalent to a lexicographic order). This, together with the amount of time needed to perform one Gröbner basis computation would make this approach untenable."
    },
    {
      "heading": "Security Analysis",
      "text": "The security of the protocol in the last section depends on the fact that it is generally difficult to compute the universal Gröbner basis for an ideal. Much work has been done to describe procedures for this computation (for example, see [16,24]), and there exist programs to compute such a basis. However, even for small ideals, the computational complexity can be a barrier to finding an explicit list. For example, let Det t,m,n denote the ideal in the polynomial ring in mn variables generated by the t × t minors of an m × n generic matrix. For Det 3,4,4 alone, there are over 160,000 possible initial ideals [16], so a brute-force universal Gröbner basis construction would require over 160,000 individual (albeit simplified) Gröbner basis computations. This section is dedicated to showing that an attacker with no prior knowledge of how U I was constructed would require an unreasonable amount of time to compute U I . In Section 5, we contrastingly show that Party A can construct U I with relative ease if I is chosen with some symmetries. In this section, we will also show that Party B does not require much time to encrypt a message, and that the required time scales well with any additional complexity that A adds to the system P. The algorithm proposed in [16] is a practical implementation of the theoretical algorithm proven in [24, Section 7]. It involves three main steps that are iterated at each vertex of State(I) (i.e. on the graph of the polytope State(I)). These steps are technical, and are only briefly outlined in Section 2.2. The complexity of performing these steps was analyzed in [16] and is highlighted in the next theorem. It ultimately shows that an attacker would require an inordinate amount of resources to compute the Gröbner fan directly, assuming I is sufficiently complex. which can be written as where r(G) is the number of non-leading terms in the marked reduced Gröbner basis G, and T lp is the time complexity related to finding an interior point to a cone. The first two terms are bounded by a polynomial in the size of the output. The computational complexity of the third term is NP-hard. Proof. The complexity description and bound for the first two terms can be found in [16,Theorem 5.1]. The statement about the third term can be found in [18, Section 5], using a result from tropical geometry. More specifically, a tropical variety is a union of Gröbner regions, making it a subfan of a Gröbner fan. In [26,Section 3], several decision problems related to tropical varieties (which could be solved given a Gröbner fan [26,Remark 3.4]) are shown to be NP-hard. □ Example 4.2. Let Det t,m,n denote the ideal in K[x 11 , . . . , x mn ] generated by the t×t minors of the matrix:     x 11 x 12 . . . x 1n x 21 x 22 . . . x 2n . . . . . . . . . . . . x m1 x m2 . . . x mn     . Using the Gfan software package [19] of Macaulay2, the authors in [16] were able to show that on a standard 2.4 GHz Pentium processor at the time (i.e. 2005), Det 3,4,4 has 163, 032 many Gröbner regions in its Gröbner fan, and hence 163, 032 possible initial ideals. Note that Det 3,4,4 is an ideal that initially is only generated by 16 polynomials in 16 variables. Without the use of the symmetries of Det 3,4,4 , the full computation took approximately 14 hours. Using the symmetries of Det 3,4,4 , the computation time for the full-dimensional cones took only 7 minutes. While a modern computer could do this considerably faster, the number of computations remains unchanged, so scaling m and n would produce similar results. □ In light of the recent threats that quantum computers pose to traditional public-key cryptosystems, it becomes increasingly important to develop new techniques to secure data that can resist attacks from a quantum computer. Post-quantum cryptography is a relatively new field, but there are six main classes of algorithms which are considered to be resistant to quantum attacks [5]. Therefore, to show that our protocol P is quantumresistant, it suffices to demonstrate that it belongs to one of these categories. Since State(I) has vertices in Z n [24, Chapter 2], it can be viewed as a convex polytope in the standard integer lattice Z n . Computing GF an(I) directly is NP-hard by Theorem 4.1, and would generally require millions of simplified Gröbner basis calculations, in addition to polytope computations (like finding normal vectors to the facets, a Gröbner walk through the graph of State(I), etc.). Therefore, these structures would be considered lattice-based primitives. Lattice-based cryptography is one of the previously mentioned approaches considered resistant against quantum attacks [5]. To prove the security of P, we will need to show that computing GF an(I) is at least as difficult as a lattice-based problem which is considered quantum-resistant. Additionally, if τ is used, then it needs to be chosen to be quantum-resistant too. Theorem 4.3. Assume that lattice-based primitives secured by the Shortest Vector Problem (SVP) are quantum-resistant. If τ ̸ = ∅, then also assume that τ is quantum-resistant. Then a protocol P for which |U I | is sufficiently large is quantum-resistant. Proof. We need to demonstrate that computing a Gröbner fan is as difficult as solving a certain SVP. To do this, we will show that when properly rephrased, knowing U I will provide a solution to a certain SVP. Recall that GF an(I) is a union of cones, called Gröbner regions, and in the interior of each cone GR < (I), there is at least one integer lattice point x ∈ GR < (I) ∩ Z n such that |x| ≤ |y| for all y ∈ int(GR < (I) ∩ Z n ) where | • | is the usual Euclidean norm on R n . Consider the following question: Among all Gröbner regions GR < (I) ⊂ GF an(I), which one has an interior integer lattice point x ∈ GR < (I) ∩ Z n which is closest to the origin? Suppose that GF an(I) is known. Then the normal vectors to facets of State(I) have been computed, and therefore lattice generators for each rational polyhedral cone GR < (I) ∩ Z n are known. For simplicial cones, given integer vectors v 1 , . . . , v n that generate the cone GR < (I) ∩ Z n , the interior points have the form c 1 v 1 + . . . + c n v n with c i > 0 and c i ∈ Z. The interior lattice point with the closest distance is precisely v 1 + . . . + v n (recall that the cones computed in the algorithm are contained in the positive orthant [16,Definition 2.8]). The non-simplicial case can be computed using integer linear programming techniques for rational convex polytopes, which runs in polynomial time for a fixed dimension [12]. In particular, GF an(I) has more information than what is needed to answer the question posed in the last paragraph, and the question can be answered in polynomial time. On the other hand, given GF an(I), we could take the collection of all appropriately scaled lattice vectors generating all Gröbner regions, and select some minimal generating set C from this collection. Note that the shortest vector that answers the above question is a rational combination of some of these generators. By scaling, we can assume that the rational combination yields an integer combination. The (now scaled) vectors in C generate a lattice, and we can ask what the shortest vector is in that lattice, which is a specific independent SVP. The solution to this SVP is exactly equal to the vector computed in the previous paragraph, showing that computing GF an(I) is at least as difficult as an SVP. Finally, when τ ̸ = ∅, an attacker could try to compute τ -1 (τ (K B )) directly, circumventing the security that GF an(I) provides, so τ needs to be a hash function which is resistant to quantum attacks. □ Remark 4.4. There are additional ways in which computing GF an(I) emulates the spirit of other lattice-based problems used in post-quantum security. For example, given a vertex v ∈ Z n of State(I), as a face of the polytope, is characterized by the inequality w • v > w • u for all other u ∈ State(I), where w is the weight order associated to the vertex v. There is another vertex v ′ of State(I) which has the furthest distance from v, and is precisely the point of State(I) which minimizes the functional f (P ) = w • P over State(I). Many algebraic problems haven't been studied in the context of post-quantum cryptography, so many of the established lattice-based problems that have been formulated do not immediately translate to algebraic settings. Further research is needed to establish independent algebraic or combinatorial problems which are considered quantum resistant."
    },
    {
      "heading": "4.2.",
      "text": "Other complexities associated with P. We will start with the complexity of the one-time computation of R I by Party A. There are numerous ways to trim the ideal I, given that U I is already known. One possibility is to choose some monomial order < of K[x 1 , . . . , x n ] and compute a Gröbner basis for I using U I . This also generates the ideal I, and generally involves far fewer than |U I | many generators. Theorem 4.5. Let U I be a universal Gröbner basis for an ideal I ⊂ R = K[x 1 , . . . , x n ] and < some monomial order on R. Then a Gröbner basis for I with respect to < is one possible choice of R I . Furthermore, if |U I | = N , then R I can be computed with O(N ) many operations. Proof. Since U I is a universal Gröbner basis, selecting Gröbner generators of I for a fixed < is a simple procedure which involves marking the initial terms of each of the N many elements of U I , and then eliminating redundancies and any elements whose initial terms are not needed to generate in < (I). □ Next we shift to the complexity of Party B finding a Gröbner basis of I. In not having access to U I , B will need to compute a Gröbner basis directly. The next theorem provides the complexity of this computation. Theorem 4.6. [1, Proposition 1] Let (f 1 , . . . , f m ) be a system of homogeneous polynomials in K[x 1 , . . . , x n ] with K an arbitrary field. The number of operations in K required to compute a Gröbner basis of the ideal I generated by (f 1 , . . . , f m ) for a graded monomial ordering up to degree D is bounded by where ω is the exponent of matrix multiplication over K. Recall that the exponent of matrix multiplication is a constant ω, depending on n, which is used to bound the complexity of matrix multiplication of n × n matrices. Suppose that Party A has already chosen a preset number of variables, so that n is fixed, as well as the number of elements in a generating set (which is m). If we allow the degrees of the f i 's to vary, then we are allowing the degree of the polynomials used in the Gröbner basis computation to vary, and thus the maximum degree of the Gröbner basis elements (i.e. the variable D) may also vary. Then, as a function of D, which is a polynomial of degree n -1 in D. Therefore, Even if A changes the complexity of a protocol P based on the degree of the generators considered (e.g. changes D to D + 1), it only affects B's Gröbner basis computation polynomially. Corollary 4.7. With the same notation as Theorem 4.6, let n and m be fixed positive integers. Then the number of operations in K required to compute a Gröbner basis of the ideal I is polynomial in D. More precisely, it is bounded by O(D ω(n-1)+1 ), as D → ∞ Remark 4.8. By a theorem of Dubé, the maximum degree D of polynomials appearing in a Gröbner basis is bounded by (d 2 + 2d) 2 n-1 where d is the maximum degree of the polynomials in {f 1 , . . . , f m } (see [14]). Note that this bound grows very large even for small n and d, but in our case, Party B is not computing a random Gröbner basis for a random ideal. On the contrary, the maximum degree of an element in U I is an upper bound for the D that Party B would encounter. On the other hand, since ω is dependent on n, the complexity of computing a Gröbner basis is doubly exponential in n. This complexity assumes the worst case however. It is expected that only a mild increase in the complexity will result from adding new generators with a similar structure to the current f i (for instance, adding binomial generators). In summary, Theorem 4.6 tells us that: • An increase in the maximum degree of the generators f 1 , . . . , f m results in a polynomial increase in time for B. • An increase in the number of generators m for fixed D and n also results in a polynomial increase in time for B (with complexity O(m)). • An increase in n could result in a doubly exponential jump in the worst case for Party B's computation time [18,Section 5], so care in selecting I should be taken. We conclude this section with a brief statement about the maximum time needed for Party A to decrypt a message when τ = ∅. Proposition 4.9. Let P = (n, K, U I , R I , < B , η, E, τ ). Suppose that N is the number of Gröbner regions in the Gröbner fan GF an(I), and let C(E) be the maximum amount of time needed to decrypt a ciphertext (of bounded length) using E. If τ = ∅, then the maximum amount of time needed to decrypt a message (of bounded length) sent using P is N • C(E). Example 4.10. Let us continue with Example 4.2 when τ = ∅. We will let E be the RSA encryption/decryption scheme. Suppose that the decryption time using E is approximately C(E) ∼ 0.00055 seconds on a standard laptop. For this example, Party A would have to check at most N = 163, 032 keys, taking at most 90 seconds to decrypt the message. Having partial information from Party B in the message about the key K B would reduce this time significantly and may be needed to bring down the decryption time to a more reasonable number, for practical purposes. It is worth noting that in this example, Party B would only take about 0.3 seconds to compute a single Gröbner basis for a fixed order < B (found by dividing the 14 hours needed to compute the Gröbner fan by the number of Gröbner regions). □ Remark 4.11. When τ = ∅, the protocol P offers greater security since no information about K B is sent publicly, but this comes at a cost to Party A who now needs to iterate through all possible encryption keys. Choosing a symmetric E can help reduce this time. On the other hand, if τ ̸ = ∅, then Party A can decrypt a ciphertext very quickly, at the cost of information about K B being public using τ . In this case, the security of the system is also dependent on the security of τ ."
    },
    {
      "heading": "Effective Initialization of U I",
      "text": "In the last section, we saw that the problem of an attacker trying to compute U I directly is intractable if the set is sufficiently large, leading one to wonder how it is possible for Party A to even initialize the system P. Here we will introduce a way to easily compute examples of U I using toric ideals of graphs. The knowledge of which graph was used in the construction would provide a trapdoor to an attacker computing U I , so it is imperative that this information be kept private. The content of this section is also of independent interest to combinatorial algebraists, especially those working with toric ideals of graphs and geometric vertex decomposition (see [13] for example)."
    },
    {
      "heading": "5.1.",
      "text": "The toric ideal of a graph. Let G = (V (G), E(G)) be a finite simple graph where V (G) = {v 1 , . . . , v n } is the set of vertices of G, and E(G) = {e 1 , . . . , e r } is the set of edges of G with e i = {v i j , v i k } an unordered pair of vertices which we call the endpoints of e i . Given G, we can associate an ideal I G to it. Let K[E(G)] = K[e 1 , . . . , e r ] and K[V (G)] = K[v 1 , . . . , v n ] be two polynomial rings over K with the edges and vertices viewed as indeterminates, respectively. Then consider the K-algebra homomorphism, defined on the indeterminates e i by φ G (e i ) = v i j v i k where e i = {v i j , v i k } for all i ∈ {1, . . . , r}. The kernel of the map φ G will be denoted by I G and is called the toric ideal of the graph G. There is a convenient graph-theoretic description of the elements of I G . First, recall that a walk of length k in a graph G is an alternating sequence of vertices and edges where e i j = {v i j-1 , v i j } for j = 1, . . . , k. We say that the walk is even if k is even, and closed In general, all binomials associated to closed even walks of G are in I G . It turns out that these binomials generate I G . Theorem 5.1. [27, Proposition 10.1.5] Let G be a finite simple graph. Then the toric ideal I G of G is generated by the set of binomials There are generally infinitely many closed even walks of a graph G. To achieve a finite generating set, we consider only primitive closed even walks. By taking I = I G for some G, we would automatically have a convenient description for U I = U(I G ). Even with this description, computing U(I G ) directly can be computationally difficult. In fact, the number of elements of U(I G ) can grow very quickly. For instance, U(I K 8 ) has over 40,000 elements [13]. A description of how to compute this set can be found in [24,Section 7]. A graph-theoretic characterization of primitive closed even walks of a graph can be found in [25]. 5.2. Generating large graphs. In this section, we will show that it is possible to generate graphs for which U(I G ) is recursively computable, and for which |U(I G )| is sufficiently large to ensure the security of the protocol P. Furthermore, this can be done in polynomial time, depending on the number of constructive steps detailed below. We are going to introduce three operations for this purpose."
    },
    {
      "heading": "5.2.1.",
      "text": "Gluing along a vertex. Given a graph G, we can glue a disjoint graph H to G along a vertex by selecting some v G ∈ V (G) and v H ∈ V (H) and identifying the two vertices. More specifically, we define a new graph, denoted G ⋆ v G ,v H H (or simply G ⋆ H when v G and v H are understood), constructed as a disjoint union of the two graphs modulo the relation where In general, computing U(I G⋆H ) can be difficult given U(I G ) and U(I H ) since new primitive closed even walks could be formed using odd cycles of G and H being linked through v G = v H . Furthermore, these odd cycles are not explicitly recorded in the list of primitive closed even walks, so we can't expect to compute the new list using the previous two lists alone. However, there is a special case where this operation works well. We start with an illustrative example. We can check that the set of primitive closed even walks for the resulting graph is the union of both lists U(I G⋆H ) = {ce -df, acf -bgh, ac 2 e -bdgh, adf 2 -begh, im -no, jl -ok, ikm -jln}. In fact, we would have arrived at the same result if we chose any other pair of vertices to identify. □ In general, U(I G⋆H ) contains the union of U(I G ) and U(I H ). When H is a bipartite graph however (i.e. contains no odd-length cycles), we get the reverse containment too. The next proposition is motivated by [21, Section 2.0.3]. Proposition 5.5. Let G and B be finite simple graphs such that B is bipartite and For the other direction, note that by [25] (and rephrased in [11,Theorem 1.7]), a primitive closed even walk is either an even cycle, or contains at least two odd cycles. If G ⋆ B has a primitive closed even walk Γ involving odd cycles, then these odd cycles must be in G since B is bipartite. If Γ includes an edge of B, then the walk must pass through v B = v G at least twice (in order to start and end in G). The edges between the first instance of v B and the second instance will define an even cycle Γ B of B, which is not possible by [17,Lemma 2.2 (ii)]. Similarly, if there is some even cycle of G⋆B that is not contained in G or B exclusively, then we can write it as v i 1 , e i 1 , v i 2 , e i 2 , . . . , e i k , v i k+1 where all e i and v i are distinct except for v i 1 = v i k+1 . If the cycle uses edges in B, then v B would appear twice in the list, unless v i 1 = v i k+1 = v B , which would mean that all of the edges are either entirely in G or entirely in B, a contradiction. □ 5.2.2. Star contractions and subdivisions. Next, we will consider a graph operation called a star contraction. Its use in the context of toric ideals of graphs was first introduced in [21]."
    },
    {
      "heading": "□",
      "text": "To simplify notation, we will define the ring homomorphism on generators by e → 1 if e ∈ N E (v), and e → e otherwise. To avoid any issues with defining primitive walks for multigraphs (like in the previous example), we will restrict to the case when the star contraction results in a simple graph. Lemma 5.8. [21, Theorem 3.10] Let G be a finite simple graph. Suppose that v ∈ V (G) is such that G v is a simple graph. Then These results allow us to produce new graphs through star contractions while still having control over the enumeration of primitive closed even walks. Note that even though the containment in Lemma 5.8 is generally proper, the set π v (U(I G )) still defines a universal Gröbner basis of I Gv (although not a reduced basis). This operation can also be undone to produce larger graphs, a process called a star subdivision, generally discussed in [4] for toric ideals of graphs. We will show that in the special case when the subdivision is done along a vertex of degree 2, the list of primitive closed even walks has an explicit description. To do this, consider a graph with the following structure: An important feature of such a graph is that the star contraction along the vertex v incident to x ′ and y ′ results in another degree 2 vertex (which we also call v by an abuse of notation). In this case, we will say that G is the (unique) star subdivision of G v along v. More generally, there are usually multiple star subdivisions of a graph (see [4, Definition 3.0.3]) if the degree of v is greater than two. To demonstrate the effect on the list of primitive closed even walks after the star subdivision, consider the following map on polynomial rings, ψ v : K[e, x, y] → K[e, x, y, x ′ , y ′ ] defined by x → xx ′ , y → yy ′ , and f → f for f ∈ e = E(G) \\ {x, x ′ , y, y ′ }. Notice that if m 1 x -m 2 y is a closed even walk of G v (where m 1 , m 2 are monomials with support in e), then ψ v (m 1 x -m 2 y) = m 1 xx ′ -m 2 yy ′ is a closed even walk of G. The next result shows that the same is true for primitive walks. Proposition 5.9. Let G be a finite simple graph and suppose that v ∈ V (G) has degree 2 in G and degree 2 in the star contraction G v . Let the edges incident to v be labeled as above. Then Proof. First note that for Γ ∈ I G and γ ∈ I Gv : so it suffices to prove the first equality to show that the second claim is also true. By the structure of primitive closed even walks (see [25]), any primitive closed even walk of G that passes through v must also pass through the edges x, y, x ′ and y ′ . Furthermore, it would either pass through all 4 edges exactly once or twice. Therefore, all binomials in U(I G ) which correspond to a primitive walk passing through v must be of the form: where m 1 and m 2 are monomials with support in e = E(G) \\ {x, x ′ , y, y ′ }. Let Γ = m 1 xx ′ -m 2 yy ′ be a primitive closed even walk of G. Assume that π v (Γ) = m 1 x-m 2 y is not primitive in G v . Then there would be some other binomial γ = m 3 -m 4 ∈ I Gv such that m 3 |m 1 x and m 4 |m 2 y. If the support of m 3 and m 4 does not include x or y, then γ is unaffected by the star subdivision of G v and corresponds to a closed even walk of both G and G v , contradicting that Γ is primitive. The only other case is when x|m 3 and y|m 4 (since γ passing through v must also pass through both x and y). In this case, ψ v (γ) = m 3 x ′ -m 4 y ′ defines a closed even walk of G such that m 3 x ′ |m 1 xx ′ and m 4 y ′ |m 2 yy ′ , also contradicting the fact that Γ is primitive. The case Γ = m 1 (xx ′ ) 2 -m 2 (yy ′ ) 2 is similar. Since walks that do not pass through v are unaffected by the star contraction, we have shown that π v (U(I G )) ⊆ U(I Gv ). Together with Lemma 5.8, we have shown that U(I G ) = ψ v (U(I Gv )), as required. □ .2.3. Gluing even cycles. Finally, we can obtain new graphs for which we can recursively generate the list of primitive closed even walks using cycle gluing. We can do this similarly to the vertex gluing defined earlier, except that we identify two edges instead of two vertices. More specifically, given disjoint graphs G and H, and edges e G ∈ E(G) and e H ∈ E(H), we can produce a new graph of the form G ⊔ H e G ∼ e H which we denote by G * e G ,e H H (or simply G * H when e G and e H have already been specified). The use of cycle gluing in the context of toric ideals of graphs and geometric vertex decomposition was introduced in [10, Theorem 3.11]. In the proof of that result, the structure of U(I G * H ) was described, which we demonstrate in the next example. The \"extended\" walks from the example are formed by taking any walk through the edge used for gluing and extending the walk to traverse the even cycle. We make this more precise as follows. Let G be a finite simple graph with e G ∈ E(G), and C 2k be some disjoint cycle with e C ∈ E(C 2k ). We will glue G to C 2k along e It is not difficult to see that both of these define primitive closed even walks contained in U(I G * C 2k ). Proof. We will abuse notation and write G and C 2k for the subgraphs of G * C 2k used to construct the gluing. Suppose that some edge of C 2k appears in a primitive closed even walk Γ of G * C 2k . Then Γ is either an even cycle or a primitive walk containing at least two odd cycles [11,Theorem 1.7]. In the first case, we follow the argument of the proof of Theorem 3.11 in [10] to conclude that the even cycle is either C 2k itself, is an even cycle of G, or has the form γ where γ is an even cycle of G which passes through e. If Γ includes at least two odd cycles and is not exclusively in G, then it must be of the form γ for some primitive walk γ of G which passes through e. Indeed, if there is a walk Γ that includes the edges of C 2k , then it must pass through the endpoints of e, so let γ be the walk where the sequence of edges of C 2k \\ e in Γ are replaced by e. Let u 2 e -v 2 be the binomial of C 2k in G * C 2k , where u 2 , v 2 are monomials with support in E(C 2k \\ e). There are now two cases to consider: Case 1: If e appears exactly once in the walk γ so that γ = u 1 e -v 1 (where u 1 , v 1 are monomials with support in E(G \\ e)), then the proof of Theorem 3.11 in [10] shows that γ = u 1 v 2 -v 1 u 2 . To show that it is primitive, observe that any u 3 -v 3 ∈ I G * C 2k which doesn't pass through e will either use all variables in E(C 2k \\ e), or will not use any of the variables of the cycle. Assume that u 3 |u 1 v 2 and v 3 |v 1 u 2 . Then we can write u 3 = c 3 g 3 and v 3 = c 4 g 4 where c 3 |v 2 , c 4 |u 2 , g 3 |u 1 and g 4 |v 1 . Then either γ is not primitive because of g 3 e -g 4 , or the binomial for C 2k is not primitive because of c 4 e -c 3 , which is a contradiction. Case 2: If e appears twice in γ, then we can write γ = u 1 e 2 -v 1 . As above, we can show that γ = u 1 v 2 2 -v 1 u 2 2 , by tracing out γ in the following way. Let e = {a, b}. Start at vertex a, and trace out the portion of γ that start at a, stays in G \\ e, and returns to vertex a. Then cross through all edges in C 2k \\ e to get to vertex b. Then trace out the portion of γ that starts at vertex b and stays in G \\ e, returning to vertex b. Finally, cross the edges of C 2k \\ e again to get back to a. Note that the intermediate vertices in a primitive walk can only be visited twice (since every cut vertex only belongs to two blocks by [25,Theorem 2.2]). We can show that γ is primitive using a similar argument as above. □ 5.2.4. Main Theorem. Using the previously mentioned operations, we are now ready to show that arbitrarily large universal Gröbner bases can be produced in polynomial time. Starting with a small graph where U(I G ) can be computed directly, and through random applications of each operation, a sufficiently large (and asymmetric) graph H with computable U(I H ) can be constructed to secure the system P. By asymmetric, we mean that repetitive iterations of the same operation should be avoided (such as simply gluing on a 4-cycle successively). Theorem 5.12. Let G be a finite simple graph such that U(I G ) is known. Then by using one of the following operations (1) Gluing a disjoint bipartite graph to G along some v ∈ V (G) (as in Section 5. Proof. For the first three operations, the explicit method in which U(I G ′ ) is obtained from the U (I G ) is described in Propositions 5.5 and 5.11 and also Proposition 5.9. Here we would produce a larger list U(I G ′ ) given U(I G ) for the first two operations, while the third operation would maintain the cardinality of the sets but increase the degree. The fourth operation maintains the same cardinality, although the new list of closed even walks may not all be primitive (this is still okay in the context of Gröbner bases since we are simply adding generators which may be unnecessary for the Gröbner computation). If |U (I G )| = N , then the first operation simply merges two sets, which is done in linear time. The second operation requires at most N + 1 new elements to be added to the list of prim"
    },
    {
      "heading": "Conclusions and Alternate Protocols",
      "text": "We conclude with some brief observations about the use of universal Gröbner bases for securing data. The protocol P is just one possible vision of how universal Gröbner bases could be used in cryptography. We hope that this article will spur interest in other possible uses of the construction of U I proposed in Section 5, especially by those better versed with the practical issues concerning cryptographic implementations. We offer several remarks on alternate approaches: • Choosing K to be a finite field would increase the difficulty of the Gröbner computations and would likely improve the security of P. • When τ = ∅, one shortfall of the system is the amount of time that Party A needs to decrypt the message. This may make the τ = ∅ protocol useful for blockchain applications where rewards are used to incentivize the completion of brute-force verifications. • Symmetric Diffie-Hellman type initializations of P may be possible by Party A providing a common monomial ideal, followed by A and B each choosing their own initial ideals and combining it with this common ideal. Sending such \"combined\" ideals (using unions, intersections, etc.) may reveal too much information about degree bounds of generators in the choices of A and B. Masking the choices using hash functions would yield a similar security to the τ ̸ = ∅ case. • Party B only sending partial information about K B would reduce the number of keys that A needs to check, offering a middle ground between the τ = ∅ and τ ̸ = ∅ initializations of P. Choosing E to be a symmetric encryption algorithm would also reduce A's decryption time, since such schemes are usually less computationally intensive compared to their asymmetric counterparts. As a final note, universal Gröbner bases for toric ideals have been better studied and are generally faster to compute. Using some U I associated to the toric ideal of a graph may introduce a weakness to the system if chosen poorly. Generally, the complexity of computing universal Gröbner bases for a toric ideal of a graph still remains exponential in the number of edges [23,Section 4]. An alternate approach is to build a large enough U I using the techniques in Section 5, and then add one (carefully selected) non-toric generator to the list, followed by a recomputation of a universal Gröbner basis for the new list. If an attacker does not know the graph G, then the toric universal Gröbner basis algorithms from [9,24] would be difficult to implement. Furthermore, even if G were known, choosing it large enough would make those computations difficult."
    }
  ]
}