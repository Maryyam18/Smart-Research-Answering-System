{
  "paperid": "2307.02411v1",
  "title": "AN APPROACH TO REMOVE KEY ESCROW PROBLEM IN ID-BASED ENCRYPTION FROM PAIRING",
  "authors": [
    "Dean",
    "Katti",
    "Verma",
    "Haidri",
    "Kumar",
    "Anand",
    "Kumar",
    "Kunal Bhaskar",
    "Kashif Nawaz",
    "Ravi",
    "Soni",
    "Prasad",
    "Gupta",
    "Anand",
    "Tarun",
    "Gupta",
    "Kumar",
    "Lynn",
    "Forouzan",
    "Cao",
    "Zhang",
    "Diffie",
    "Hellman",
    "Shamir",
    "Enge",
    "Bonehandm",
    "Franklin",
    "Boyen",
    "Waters",
    "Boldyreva",
    "Goyal",
    "Kumar",
    "Boneh",
    "Boneh",
    "Boyen",
    "Goh",
    "Li",
    "Menezes",
    "Van Oorshot",
    "Vanstone",
    "Kenneth",
    "Paterson",
    "Price",
    "Rivest",
    "Shamir",
    "Adleman",
    "Maurer",
    "Yacobi",
    "Shor",
    "Abelson",
    "Anderson",
    "Bellovin",
    "Benalob",
    "Blaze",
    "Diffie",
    "Gilmore",
    "Neumann",
    "Rivest",
    "Schiller",
    "Schneier",
    "Desmedt",
    "Quisquater",
    "Girault",
    "Tanaka",
    "Sakai",
    "Ohgishi",
    "Kasahara",
    "Boneh",
    "Ding",
    "Tsudik",
    "Wong",
    "Harn",
    "Lin",
    "Gray",
    "Sheedy",
    "Cha",
    "Cheon",
    "Guillou",
    "Quisquater",
    "Feige",
    "Fiat",
    "Shamir",
    "Cheng",
    "Comley",
    "Vasiu",
    "Bo",
    "Wenping",
    "Yumin",
    "Horwitz",
    "Lynn",
    "Cocks",
    "Elgamal",
    "Baek",
    "Newmarch",
    "Safavi-Naini",
    "Susilo",
    "Gentry",
    "Kumar",
    "Katti",
    "Saxena",
    "Gentry",
    "Silverberg",
    "Shamir",
    "Peterson",
    "Lynn",
    "Malone-Lee",
    "Joseph",
    "Gentry",
    "Al-Riyami",
    "Paterson",
    "Sherman",
    "Chow",
    "Tseng",
    "Canetti",
    "Halevi",
    "Katz",
    "Gammell",
    "Smart",
    "Fujisaki",
    "Okamoto",
    "Shamir",
    "Koblitz",
    "Miller",
    "Preneel",
    "Bellare",
    "Rogaway",
    "Sakai",
    "Kasahara",
    "Cooper",
    "Dzambasow",
    "Hesse",
    "Joseph",
    "Nicholas",
    "Boneh",
    "Boyen",
    "Micali",
    "Micali",
    "Shamir",
    "Cao",
    "Gura",
    "Patel",
    "Wander",
    "Eberle",
    "Shantz"
  ],
  "year": 2024,
  "abstract": "Delhi, for his excellent guidance, caring, patience, and encouragement.He has been an inspiration to a great teacher and me. I would like to be very grateful towards him for providing me with an excellent atmosphere for doing research.Completing this dissertation without his valuable support and patience would have been impossible.Secondly, I would like to thank Prof. P.C. Saxena (Emeritus), School of Computer and System Science, Jawaharlal Nehru University, New Delhi, who let me experience the research of freshwater mussels in the field and practical issues beyond the textbooks, patiently corrected my writing and motivationally supported my research.Thirdly, I would like to thank my lab mates for their fruitful support and encouragement thought-out my M. Tech dissertation. Thanks to",
  "sections": [
    {
      "heading": "",
      "text": "Table 2. 1 RSA Key length of Some Organization ..................................................... Table 2. 2 RSA and ECC key Sizes ............................................................................ Table 3. 1 Level of trust to PKG ................................................................................. Table 3. 2 Comparison of Computation Cost of variant of Public Key encryption which avoids key escrow problem .................................................................................... Table 3. 3 Comparison of public information and trust level to PKG of different scheme............................................................................................................................... Table 5. 1 Comparison of Computation Cost of proposed scheme with existing scheme ........................................................................................................................................... Table 5. 2 Comparison of public information and trust level to PKG of proposed scheme with existing scheme ............................................................................................ Figure 2. Rational points on line over elliptic curve. ................................................. 13 Figure 3. Public Key Cryptography. ...........................................................................22 Figure 3. Identity-based encryption ........................................................................... 24 Figure 3. Key Escrow Problem in Identity-based encryption .................................... 31 Figure 3. Hierarchy of Private Key Generators ..........................................................34 Figure 4. Steps for Private Key Issue .........................................................................41 LIST OF FIGURES viii ğ‘€ Message C Ciphertext ğ‘ ğ‘› Set of integers Mod n (G ï€¬ +) Algebraic group with respect to the set G and the binary operation (G , +, Ã—) Cyclic Group with respective to the set G and two binary operation G Group (G ï€¬ +) ïˆ Subgroup of Group G R Ring (R , +, Ã—) F Field (F , +, Ã—) +, and Ã— Binary operations ğºğ¹(ğ‘) Finite field of order prime ğ‘ ğ»(ğ‘¤) Hash function with bit sequence ğ‘¤ as input ğ‘†ğ‘–ğ‘”ğ‘›(ğ‘€) Signature on message ğ‘€ ğ‘’: ğº 1 Ã— ğº 2 -> ğº ğ‘‡ Bilinear map from the group ğº 1 and ğº 2 and ğº ğ‘‡ x âŠ• y Bitwise XOR operation between string ğ‘¥ and ğ‘¦ â”´ Invalid output ğ¸ğ‘›ğ‘ ğ‘˜ (ğ‘€) Symmetric encryption of the message ğ‘€ under session key ğ‘˜ ğ·ğ‘’ğ‘ ğ‘˜ (ğ¶) Symmetric decryption of the ciphertext ğ¶ under session key ğ‘˜"
    },
    {
      "heading": "LIST OF SYMBOLS AND NOTATIONS",
      "text": "Concatenation of bit strings x and y {0,1} ğ‘› Binary bit sequence of length n {0,1} * Binary bit sequence of variable length ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘Ÿ User's generated private key ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘¢ğ‘ User's generated public key ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘Ÿ PKG's generated private key ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘¢ğ‘ PKG's generated public key ğ‘ğ‘˜ğ‘ƒğ‘œ ğ‘ƒğ‘Ÿ PKPO's generated private key ğ‘ğ‘˜ğ‘ğ‘œ ğ‘ƒğ‘¢ğ‘ PKPO's generated public key ğ· ğ¼ğ· Decryption key for the user with identity ID. ğ‘˜ Security parameter ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘  Publicly published parameters adv Advantage for the adversary to win the game. Ğ„ Negligible function ğ¶ğ‘’ğ‘Ÿğ‘¡ ğ¼ğ· Certificate issued by PKG to the user whose identity ID CA Certification Authority ğ´ğ‘‘ğ‘£ ğ¼ Type I IND-CPA adversary ğ´ğ‘‘ğ‘£ ğ¼ğ¼ Type II IND-CPA adversary ID User's Identity IBE Identity based encryption IBS Identity based encryption PKG private Key Generation HIBE Hierarchical IBE DLP Discrete Logarithm problem DDHP Decision Diffie-Hellman problem BDHP Bilinear Diffie-Hellman problem CDHP Computational Diffie-Hellman problem GDHP Gap Diffie-Hellman problem PKI Public key infrastructures IND-CPA Indistinguisablity chosen ciphertext attack IND-CCA Indistinguisablity chosen palintext attack ECC Elliptic Curve Cryptography RSA Rivest Shamir Adleman Algorithm DKG Distributed key Generation SSN Social Security Number ANO-IBE Anonymous Identity-Based Encryption ANO-CCA Anonymous chosen ciphertext attack LIST OF ABBREVATIONS xi CL-PKC Certificate-less Public Key Cryptosystem CB-PKC Certificate-based Public Key Cryptosystem SCS Self Certified Scheme V-IBE Variant of Identity based encryption M-IBE Modified Identity based encryption free from key escrow problem PKPO Private Key Privacy organization KeyGen Key Generation ROM Random Oracle Model BasicM-IBE Proposed Basic model of Identity-based encryption free from key escrow problems, secure against IND-CPA attack FullM-IBE Proposed Full model of Identity-based encryption free from Key Escrow Problems secure against IND-CCA attack. One of the significant challenges in cryptography is the key distribution over a public network. It is essential to securely distribute keys to ensure the confidentiality, integrity, and authenticity of messages transmitted over a network [4,16,35]. If keys are compromised or intercepted by attackers, the entire communication system can be compromised. This is why various encryption schemes have been developed to securely distribute keys, including identity-based cryptosystem (IBC), which uses an individual's identity, such as an email address, as a public key. IBC is a promising approach to publickey cryptography that simplifies key management and distribution [7,18,21,23,24,29,41,43]. However, its adoption is still limited due to the key escrow problem and the need for further research to address its security and privacy implications. At the same time, the key escrow problem is also a concern in cryptography that arises when a trusted third party holds a copy of a user's private key. This can occur when a government or other entity requires backdoor access to encrypted data or communication for law enforcement or national security purposes. The key escrow problem is controversial because it poses a significant risk to the privacy and security of individuals and organizations who rely on encryption to protect sensitive information. If the trusted third party is compromised or forced to disclose the private key, unauthorized parties can"
    },
    {
      "heading": "Introduction",
      "text": "Chapter and certificate-less cryptography [31,39], where the user generates their own public and private keys without the involvement of a trusted third-party Certificate Authority. Despite efforts to address the key escrow problem, it remains a controversial issue in cryptography and information security. There is an ongoing debate about the trade-offs between privacy and national security and the role trusted third parties should play in securing encrypted data and communication."
    },
    {
      "heading": "Problem Statements",
      "text": "In modern cryptographic algorithms [4,5], the user generates his key pair using public and private keys. The public key is publically available to everyone in the network and is used to encrypt the message. Alternate to the public key, the private key keeps as a secret to him and is used to decrypt the message. The PKI manages each user's public key along with his identity. No one other than the user can ever decrypt the message. So, the user has guaranteed to obtain his secret information in communication. At the same time, the user can also use encryption to encrypt criminal activity. So we can say that there are two main problems with public key encryption. The first one requires PKI to manage the certification certifying that the public key is the claimed user with an identity ID. And the second is a malicious user can encrypt criminal information. An ID-based encryption scheme [5,7,18] tackles the first problem to solve the certificate management problem in PKC. Instead of using the public key, it uses the user's identity as the public key. Therefore, there is no need for a certificate to certify that the public key is the real public key of the user with identity ID. A trusted third authority called Private Key Generator generates the private key corresponding to the identity ID; one copy is sent to the user, and the other is stored in its storage. In future, PKG may decrypt the doubtful message encrypted by the user over public communication. Thus, the second issue with PKC can be solved by monitoring the PKG's suspicious message with the help of a copy of the user's private key stored in its storage. Malicious PKG may also decrypt the encrypted message as PKG generates the user's private key. Thus, with advantages over the public key encryption system, IDbased encryption suffers from two issues: 1) key escrow problem and 2) secure key issuing between the PKG and the user. These issues motivate the need for an efficient model to avoid such problems. Several approaches have been proposed to remove the key escrow problem [22,31,39,44,45,46,47], either by secure key issuing or user-chosen information. Nevertheless, the advantages come with some drawbacks. Each approach comes with new disadvantages. However, every scheme solved the key escrow problem differently. But it has become a new issue in the crypto world. These schemes discussed above show that each scheme gives full control over its private key. Indeed, giving full control over the private key to the user is also a disadvantage. User Privacy has induced two new penalties; PKG or government has no control over the user's private key, and they take no action against the user's unlawful message. Today, one hot topic in cryptography is balancing control of the Private Key for both the user and the PKG. Thus, the user has a right to privacy on their lawful message, and Government has the right to monitor the unlawful message of the user."
    },
    {
      "heading": "Recent Solutions",
      "text": "In the previous section, we have seen the limitations of PKE and IBE. Here, we discussed the existing solution of the key escrow problem in IBE and the existing solution of PKC."
    },
    {
      "heading": "Existing Solutions to key escrow Problem",
      "text": "Several kinds of researchers on ID-based encryption schemes have proposed avoiding key escrow problems. Boneh-Franklin [7] uses the technique of threshold cryptography [50] to distribute the master key to multiple PKG instead of one, discussed in chapter 4. Due to the massive infrastructure for managing multiple PKG, this scheme did not work so efficiently. At the same time, the HIBE scheme [9,12] attempts to solve the issue, but the problem remains the same extensive infrastructure to manage the multiple PKG. In 2003, Gentry [45] introduced certificate-based Public Key encryption, but it needs a certificate authority to certify the user's identity and manage those certificates. To tackle this issue, certificate-less public key encryption [46] was introduced, which provides implicit authentication to the public key with user-chosen information. A new variant of IBE [31] was proposed, which uses a combination of the key issue by PKG and some information chosen by the user as a private key. However, the most unattractive property of all solutions is each scheme is proposed to tackle the problem of key escrow with different techniques. Each scheme is supposed to have an advantage over others. By removing the key escrow problem in the existing scheme, PKG has no control over the private key in each scheme. Thus, the user may get the chance to use it privately in some criminal activity since there is no authority to monitor the user's communication."
    },
    {
      "heading": "Existing solution to key escrow",
      "text": "In 1993, the U. S. government declared an escrow encryption standard [51]. This scheme is based on the tamper-resistant hardware encryption device called the Clipper chip. This chip has two properties [64]: 1. SKIPJACK algorithm provides secret encryption. 2. Provide a \"backdoor\" for law enforcement to monitor unlawful commutation. Since then, key escrow has been less attractive because the issue with this scheme is how to balance these two properties in a single approach. As we saw in ID-based encryption, the user's private key completely depends on the trusted third party. In 1995, Shamir [63] indicated: \"Nowadays, even if the escrowed agent is reliable, In future, other dishonest agencies may replace it; these dishonest agencies will likely decrypt escrowed key of all users suddenly and monitor user's communication for their stake.\" Many approaches explore the problem. Shamir [40] introduced partial key escrow approaches, Micali and Ney [53] put forward a shared random function and key escrow scheme, and another improved scheme [32] which is more advantageous than the previous one."
    },
    {
      "heading": "Motivation",
      "text": "To remove the key escrow problem from ID-based encryption, several schemes have been discussed in Chapter 3. HIBE [9,12] and threshold key issuing [7] need extra storage and computation time infrastructure. So it consumes a lot of machine cycles and is slower than other existing schemes. Certificate-based encryption [45] has the disadvantage of key revocation of the certificate. Thus, it requires a large amount of storage for the certificate and computational time for verifying those certificates. Therefore, this scheme lost the advantage of identity-based encryption. Like certificatebased encryption, Certificate-less encryption [46] uses user-chosen information but only has implicit authentication with the public key. The sender will never ensure the receiver's public key is original until communication succeeds. In contrast to an existing scheme, VIBE [31] used the user-chosen secret information and combined his confidential information and partial private generated by PKG to encrypt the message. As a result, the encryption algorithm becomes more complex. Thus, there will be a need to construct identity-based encryption, a partial key escrow problem, and monitor unlawful communication."
    },
    {
      "heading": "Objective of thesis",
      "text": "The primary objective of this thesis is to develop an efficient democratic model for identity-based cryptosystems that strikes a balance between government monitoring and user privacy. Specifically, we propose a straightforward model for transforming traditional identity-based encryption into a democratic scheme [62] that preserves the rights of both the government and the people. 1. Government rights to monitor: In the democratic model, the government can monitor communications through a \"backdoor\" mechanism, which enables authorized agencies to intercept suspicious messages and detect criminal activities. At the same time, the user's right to privacy is protected, ensuring that their personal information remains confidential and secure."
    },
    {
      "heading": "Structure of thesis",
      "text": "The structure of this thesis is organized as follows: Chapter 2 gives the mathematical background required to comprehend the proposed cryptographic model. It begins by defining fundamental mathematical concepts such as modular arithmetic, algebraic groups, finite fields, and number-theoretic assumptions. The chapter further elaborates on the concept of elliptic curves and their significance in cryptography. The chapter also introduces the notion of cryptographic hash functions and random oracles, which are essential for understanding one-way hash functions. Chapter 6 concludes this thesis with a summary of earlier research results and our current solution's limitations. Finally, we conclude the thesis by highlighting that might be the subject of future work."
    },
    {
      "heading": "Mathematical Backgrounds",
      "text": "This chapter briefly covers the mathematical background to understand cryptographic algorithms presented in the later section. This chapter represents the fundamental of cryptography concepts. Note that this chapter only covers the cryptographic fundamentals required to understand the remainder of the thesis. Definitions and theorems are always provided without t proof. For a more in-depth discussion on algebraic topics in this chapter, the reader is referred to [14]. More information on elliptic curves, Diffie-Hellman assumptions, and pairing-based cryptography can be found in [1]."
    },
    {
      "heading": "Mathematics of Cryptography",
      "text": "In this chapter, we will be ready to understand the mathematics description by discussing the various mathematical tools and properties of cryptography. Some useful functions like field, ring, group, bilinear pairing, and the elliptic curve will be discussed here."
    },
    {
      "heading": "Modular Arithmetic",
      "text": "For any given positive integer ğ‘ and any nonnegative integer ğ‘¥, if we divide ğ‘ by ğ‘›, then we get an integer quotient ğ‘ and an integer remainder ğ‘Ÿ that satisfies the following equation: Where ğ‘› is the largest integer less than or equal to ğ‘›, the remainder ğ‘Ÿ is also known as residue or ğ‘¥ mod ğ‘›. The integer ğ‘› is known as the modulus (Mod). Two 2 Chapter integers ğ‘¥ and ğ‘¦ are said to be congruent Mod ğ‘›; if ğ‘¥(ğ‘€ğ‘œğ‘‘ğ‘›) = ğ‘¦(ğ‘€ğ‘œğ‘‘ğ‘›), which can be written as ğ‘¥ = ğ‘¦(ğ‘€ğ‘œğ‘‘ğ‘›). Properties of modular arithmetic 1. [ğ‘¥(ğ‘€ğ‘œğ‘‘ğ‘›) + ğ‘¦(ğ‘€ğ‘œğ‘‘ğ‘›)]ğ‘€ğ‘œğ‘‘ğ‘› = (ğ‘¥ + ğ‘¦)ğ‘€ğ‘œğ‘‘ğ‘› 2. [ğ‘¥(ğ‘€ğ‘œğ‘‘ğ‘›) -ğ‘¦(ğ‘€ğ‘œğ‘‘ğ‘›)]ğ‘€ğ‘œğ‘‘ğ‘› = (ğ‘¥ -ğ‘¦)ğ‘€ğ‘œğ‘‘ğ‘› 3. [ğ‘¥(ğ‘€ğ‘œğ‘‘ğ‘›) * ğ‘¦(ğ‘€ğ‘œğ‘‘ğ‘›)]ğ‘€ğ‘œğ‘‘ğ‘› = (ğ‘¥ * ğ‘¦)ğ‘€ğ‘œğ‘‘ğ‘› Set of Residues (ğ‘ ğ‘› ): In modular arithmetic, the residue of an integer ğ‘ modulo ğ‘› is the remainder obtained when ğ‘ is divided by ğ‘›. For example, the residue of 17 modulo 5 is 2, because 17 divided by 5 leaves a remainder of 2. Additive Inverse: Suppose ğ‘¥ and ğ‘¦ are two numbers in ğ‘ ğ‘› , it is called the additive inverse of one another if ğ‘¥ + ğ‘¦ = 0(ğ‘€ğ‘œğ‘‘ğ‘›). For example: In ğ‘ 13 , 6 is the additive inverse of 7. Multiplicative Inverse: Two numbers ğ‘¥ and ğ‘¦ are multiplicative inverse to each other if ğ‘¥ * ğ‘¦ = 1(ğ‘€ğ‘œğ‘‘ğ‘›); for example, in ğ‘ 13 , the multiplicative inverse of 6 is 11. The integer ğ‘¥ in ğ‘ ğ‘› has a multiplicative inverse that exists only if gcd(ğ‘¥, ğ‘›) = 1. Some more sets: â€¢ ğ‘ ğ‘› * : It is the subset of ğ‘ ğ‘› , and contains only those integers for which multiplicative inverse exists. In ğ‘ ğ‘› , each member contains additive inverse, but only a few contain multiplicative inverse. For example, ğ‘ 6 = {0,1,2,3,4,5} and ğ‘ 6 * = {1,5}. â€¢ ğ‘ ğ‘ : It is similar to ğ‘ ğ‘ where ğ‘› is the prime number ğ‘. ğ‘ ğ‘ contains all integers between 0 to ğ‘ -1 . Each element that belongs to ğ‘ ğ‘ has an additive inverse, and all components have a multiplicative inverse excluding 0. For example: ğ‘ 13 = {0,1,2,3,4,5,6, 7, 8, 9, 10, 11, 12}. â€¢ ğ‘ ğ‘ * : It is similar to ğ‘ ğ‘› * , where n is the prime number p and the subset of ğ‘ ğ‘ . In ğ‘ ğ‘ , only some elements have a multiplicative inverse, but in ğ‘ ğ‘ * all members have multiplicative inverse excluding 0. ğ‘ ğ‘ * contain all integers from 1 to ğ‘ -1 . For example ğ‘ 13 * = {1,2,3,4,5,6, 7, 8, 9, 10, 11, 12}."
    },
    {
      "heading": "Mathematics of Symmetric Key Cryptography",
      "text": "The requirements of cryptography are the sets of integers and different operations performed on those sets. The operations applied to the elements of the combination of the different sets are called an algebraic structure. This section will briefly discuss three common algebraic structures: groups, rings, and fields. â€¢ Group: A group is the set of an element that contains the operation of binary + and satisfies four functions. The properties are as follows: 1. Closure: If ğ‘¥ and ğ‘¦ are the elements of ğº, then ğ‘§ = ğ‘¥ + ğ‘¦ is also the element of ğº, meaning if we apply any operation to any group element, the result will also belong to a group ğº. 2. Associativity: If ğ‘¥, ğ‘¦ and ğ‘§ are the elements of the group ğº, then 3. Existence of identity element: For all x in a group, ğº there exists an identity element 'ğ‘’' such that Existence of inverse: For each x in a group, ğº there exists an element 'ğ‘’' such that An Abelian group consists of a set of elements and a binary operation that satisfies the commutative, associative, and distributive properties. 5. Commutativity: If ğ‘¥ and ğ‘¦ belong to a group, ğº then ğ‘¥ + ğ‘¦ = ğ‘¦ + ğ‘¥. â€¢ Finite Group: A group, ğº is called finite if it contains a finite number of elements; otherwise, it is called an infinite group. â€¢ Order of Group: The number of unique elements present in the group is known as the group's order. If the number of an element is finite, then it is called finite order; otherwise infinite order. â€¢ Subgroup: A subset ğ» is called the subgroup of a group ğº if ğ» it is a group concerning the operation on ğº. In other words, if ğº =< ğ‘¥, +> is a group and ğ» =< ğ‘¦, +> is a group under the same operation, and ğ‘¦ is a non-empty subset of ğ‘¥, then ğ» is called a subgroup of ğº. This definition yields: 1. If ğ‘¥ and ğ‘¦ are the members of both groups, then ğ‘§ = ğ‘¥ + ğ‘¦ is also the member of both groups. 2. The same identity element exists for both. 3. If ğ‘¥ belongs to both groups, then the inverse of ğ‘¥ also belongs to both groups. 4. Each group is itself a subgroup. â€¢ Cyclic Subgroup: A subgroup is said to be cyclic if the power of an element of the group can generate it. â€¢ Cyclic Group: It is the group that contains its own Cyclic Subgroup. The Component that can generate a cyclic subgroup can also produce the whole group itself; that component is called the generator of the group. If ğ‘” is a generator, then the elements in the finite cyclic group can be written as â€¢ Field: A field ğ¹ =< {. . }, +, Ã— > is a type of commutative ring in which the second operation satisfies all five properties defined for the first operation, except that the identity of the first operation has no inverse. â€¢ Finite Fields: A field with a finite number of an element is called a finite field. Galois demonstrated that the field has a finite number of the component that must be ğ‘ ğ‘˜ , where ğ‘ is a prime number and ğ‘˜ area is a positive integer. A Galois field, ğºğ¹(ğ‘ ğ‘› ), is a finite field with ğ‘ ğ‘› elements. While ğ‘› = 1, we have ğºğ¹(ğ‘) field."
    },
    {
      "heading": "Elliptic-Curve Cryptosystem",
      "text": "The properties and functions of elliptic curves have been studied in mathematics for 150 years. In 1985 Victor Miller [56] and Neal Koblitz [55] suggested an elliptic curve as a mathematical tool in cryptography known as the elliptic-curve cryptosystem."
    },
    {
      "heading": "Definition of Elliptic Curve",
      "text": "An Elliptic-curve over a finite field is a smooth non-singular cubic projective curve of genus one defined over ğ‘˜ with distinguished ğ‘˜ rational points. By, non-singular means all three roots of EC must be distinct. Over any field ğ¹, an irreducible projective curve is a compact manifold that is topological as a sphere with handles."
    },
    {
      "heading": "The general form of the Elliptic Curve",
      "text": "The following equation can define any elliptic curve: Where ğ‘¥ is not a continuous point that is chosen from a particular field ğºğ¹(ğ‘ƒ) or ğºğ¹(2 ğ‘˜ ), figure 2.1 shows the elliptic curve [8] of the equation ğ‘¦ 2 = ğ‘¥ 3 -ğ‘¥ + 1. Let ğ¸ be an elliptic curve over ğ¹ defined by the Weierstrass equation as follow: ğ‘¦ 2 + a 1 xy + a 3 y = ğ‘¥ 3 + a 2 ğ‘¥ 2 + a 4 ğ‘¥ + ğ‘ 5 If P is a rational point on elliptic curve ğ¸ and ğ‘™ is a line through ğ‘ƒ with a rational slope, it is not necessarily true that ğ‘™ intersects ğ¸ in another rational point. However, if ğ‘ƒ and ğ‘„ are two rational points on the elliptic curve ğ¸, then the line ğ‘ƒğ‘„ intersects ğ¸ in a third rational point ğ‘…. This permits us to generate many new rational points from old ones. And also permits us to define a group operation on ğ¸(ğ‘˜) for any elliptic curve defined over any field ğ‘˜.  should be zero [17]. Here, zero is a point at infinity. The evaluation of ğ‘ƒ + ğ‘„ = ğ‘… is purely algebraic. The coordinates of R are rational functions of the coordinates of ğ‘ƒ and ğ‘„, and can be computed over any field. By adding a point to itself repeatedly, we can compute ğ‘›ğ‘ƒ = ğ‘ƒ + ğ‘ƒ + â‹¯ + ğ‘ƒ for any positive ğ‘›. We also define 0ğ‘ƒ = 0and (-ğ‘›)ğ‘ƒ = -ğ‘›ğ‘ƒ. Thus, we can perform scalar multiplication by any integer ğ‘›."
    },
    {
      "heading": "Why Elliptic Curve Cryptography?",
      "text": "Elliptic curve cryptography (ECC) is a modern public-key technique based on elliptic curve theory. It has gained popularity recently due to its robustness, speed, and efficiency. One of the main advantages of using ECC is the ability to create smaller and faster keys than traditional methods, such as RSA. ECC generates a pair of keys using an elliptic curve equation, a mathematical formula describing a curve on a plane. The keys consist of public and private keys used for encryption and decryption, respectively. The security of the keys is based on the difficulty of solving a mathematical problem related to the elliptic curve equation. Compared to RSA, which requires a 1024-bit key for a certain level of security, ECC can provide an equivalent level with only a 164-bit key. ECC is much more efficient in computation power and battery resource usage, making it particularly well-suited for mobile applications. Moreover, the key size of ECC doubles every ten years, which means that traditional methods cannot be used due to the large key size required for maintaining security. ECC offers a practical solution to this problem by allowing for smaller key sizes without compromising security. Table 2.1 shows some currently used RSA key lengths by some organizations. If the key size increase, it increases security, but it causes a severe problem. Decryption will be eight times slower if we double the RSA key length. Table 2.1 gives the RSA key length of some organizations, and Table 2.2 gives the security level of ECC and RSA. Ciphertext size also becomes large. The encryption speed is also infected with a large key length, which is slower by a factor of 4. Table 3.2 gives the security level of the ECC and RSA scheme. Tables 2.1 and 2.2 clearly show that ECC takes less key length than RSAit is more efficient. Application of ECC: ECC has a wide range of applications in various fields, from secure communication to cryptocurrency and IoT devices. Its efficiency, scalability, and strong security guarantees make it an ideal choice for modern cryptography applications."
    },
    {
      "heading": "Cryptographic Hash Function",
      "text": "A cryptographic hash function [57] is a function that takes a variable-length string as an input and gives a Fixed-length string, i.e. message digest. ğ»: {0,1} * â†’ {0,1} ğ‘˜ where, ğ‘˜ is the length of a message digest. Let's take a function ğ‘“(ğ‘¥) = ğ‘¦ that maps ğ‘¥ to the image ğ‘¦. ğ‘¥ is called a pre-image of ğ‘¦. The output is called hash value or message digests. Here we use ğ‘¦ = ğ»(ğ‘¥), which denotes applying the hash function into variable-length message ğ‘¥ and gives fixed length digest ğ‘¦. The hash function should follow some characteristics: 1. ğ‘¥ should be variable length, and ğ‘¦ is fixed length. 2. For given ğ‘¥, it's easy to compute ğ‘¦, but vice versa should be very tough, which means the hash function should be the one-way function. 3. Two messages don't have the same message digest. Hash functions are helpful in a wide range of practical applications. For example, hash functions act as one-way functions in password databases to lighten the sensitivity of the stored content. Besides, hash functions are also valuable tools for data authentication and integrity checking."
    },
    {
      "heading": "Random Oracle model",
      "text": "The Random Oracle model (ROM) was introduced in 1993 by Bellare and Rogaway [58]. A Random Oracle is a theoretical black box that gives a uniformly Randomly chosen result from its output domain for each unique query. A Random Oracle is deterministic, i.e. given a particular input, it will always produce the same output. The behaviour of this model is given as follows: 1. When any new message comes, Oracle creates a fixed size of the digest for that message and saves the message and digest in the Oracle record. 2. When any message exists, and digest exists for that message, then Oracle puts the message digest on their record. 3. The digest for any new information is independently chosen from the previous digest. In an ideal model, hash functions can be considered random oracles. The hash function output will look like perfect random bit sequences if the hash function is ideal. Therefore, hash functions are often examined as Random Oracles in security proofs. Such security proofs are called proven secure in ROM. The next step of these security proofs is replacing the Random Oracle access with the computation of an appropriately chosen (hash) function [58]. Algorithms that are not requiring such a system in their security proof are said to be proven secure in the standard model."
    },
    {
      "heading": "Pigeonhole principle",
      "text": "The Pigeonhole principle is a fundamental concept in mathematics that states that if there are more objects than containers to put them in, then at least one container must contain more than one object. In other words, if n+1 or more objects are placed into n containers, then at least one container must contain more than one object. The principle is often used to prove various theorems in combinatorics, number theory, and other fields of mathematics. It can be applied in various contexts, such as counting problems, graph theory, and probability theory."
    },
    {
      "heading": "Pairing-Based Cryptography",
      "text": "The main idea of pairing-based cryptography [1,3] is to map between two essential groups. It allows a new scheme based on reducing one problem to another, which means reducing the hard problem from one group to the problem more accessible than the first one in another group."
    },
    {
      "heading": "Bilinear Maps",
      "text": "Bilinear Map [6] allows mapping between different groups. Let ğº 1 be the cyclic additive group with generator p. The bilinear map is also called pairing because it allows a pair of elements from ğº 1 and ğº 2 to another group ğº ğ‘‡ . Suppose ğº 1 , ğº 2 , and ğº ğ‘‡ are cyclic groups with large prime order ğ‘. Generally, ğº 1 , and ğº 2 are the additive group, and ğº ğ‘‡ is the multiplicative group. A bilinear pairing is described as ğ‘’: ğº 1 Ã— ğº 2 â†’ ğº ğ‘‡ that satisfy the bilinear property: ğ‘’(ğ‘¥ğ‘ƒ, ğ‘¦ğ‘„) = ğ‘’(ğ‘ƒ, ğ‘„) ğ‘¥ğ‘¦ ğ‘“ğ‘œğ‘Ÿ ğ‘ğ‘™ğ‘™ ğ‘ƒ âˆˆ ğº 1 , ğ‘„ âˆˆ ğº 2 ğ‘ğ‘›ğ‘‘ ğ‘ğ‘™ğ‘™ ğ‘¥, ğ‘¦ âˆˆ ğ‘ ğ‘ It means if ğ‘ƒ is the generator of ğº 1 and ğ‘ƒ is the generator of ğº 2 , then ğ‘’(ğ‘ƒ, ğ‘„) is the generator of ğº ğ‘‡ . The mapping is computable if some algorithm can efficiently compute ğ‘’(ğ‘ƒ, ğ‘„) for ğ‘ƒ, ğ‘„ âˆˆ G 1 . If ğº 1 = ğº 2 pairing is called symmetric otherwise, pairing is known as asymmetric. If ğº 1 = ğº 2 = ğº ğ‘‡ , pairing is called a self-bilinear map. 2.4.2 Bilinear pairing Suppose ğº 1 is a cyclic additive group, ğº 2 is a cyclic multiplicative group of the same order ğ‘, and ğ‘ƒ is a generator of ğ‘ ğ‘ . A bilinear pairing is a map ğ‘’: ğº 1 Ã— ğº 2 â†’ ğº ğ‘‡ that satisfies the following properties: 1. Bilinearity: For every ğ‘ƒ, ğ‘„, ğ‘… âˆˆ G 1 , ğ‘’(ğ‘ƒ, ğ‘„ + ğ‘…) = ğ‘’(ğ‘ƒ, ğ‘„)ğ‘’(ğ‘ƒ, ğ‘…) ğ‘’(ğ‘ƒ + ğ‘„, ğ‘…) = ğ‘’(ğ‘ƒ, ğ‘…)ğ‘’(ğ‘„, ğ‘…) for any ğ‘¥, ğ‘¦ âˆˆ ğ‘ ğ‘ ğ‘’(ğ‘¥ğ‘ƒ, ğ‘¦ğ‘„) = ğ‘’(ğ‘ƒ, ğ‘„) ğ‘¥ğ‘¦ = ğ‘’(ğ‘¥ğ‘¦ğ‘ƒ, ğ‘„) 2. Non-Degeneracy: If everything maps to identity, then it is undesirable; if ğ‘ƒ is a generator of ğº 1 , then ğ‘’(ğ‘ƒ, ğ‘ƒ) is a generator of ğº ğ‘‡ , that means if there exists ğ‘ƒ âˆˆ ğº 1 such that ğ‘’(ğ‘ƒ, ğ‘ƒ) â‰  1, where 1 is the identity element of ğº ğ‘‡ . 3. Computability: An algorithm must efficiently compute ğ‘’(ğ‘ƒ, ğ‘„) for every ğ‘ƒ, ğ‘„ âˆˆ ğº 1 . Here, ğº 1 and ğº 2 are as an additive notation and ğº ğ‘‡ with a multiplicative notation. In general, ğº 1 and ğº 2 are the groups of points on an elliptic curve, and ğº ğ‘‡ will denote the multiplicative subgroup of the finite field. Map ğ‘’ will be Tate pairing or Weil pairing on an elliptic curve over a finite field."
    },
    {
      "heading": "Mathematical problem",
      "text": "Now, we are ready to describe some mathematical problems. 1. Discrete Logarithm (DLP) problem: Given two random integers ğ‘ƒ âˆˆ ğº 1 and ğ‘ƒ âˆˆ ğº 2 , compute an integer ğ‘¥, such that ğ‘„ = ğ‘¥ğ‘ƒ, where ğ‘¥ âˆˆ ğ‘ ğ‘ . The security of these algorithms relies on the assumption that the DLP is hard to solve."
    },
    {
      "heading": "Bilinear Diffie-Hellman (BDH) problem:",
      "text": "Given ğ‘¥, ğ‘¦, ğ‘§ âˆˆ ğ‘ ğ‘ , and < ğ‘ƒ, ğ‘¥ğ‘ƒ, ğ‘¦ğ‘ƒ, ğ‘§ğ‘ƒ > compute ğ‘’(ğ‘ƒ, ğ‘ƒ) ğ‘¥ğ‘¦ğ‘§ âˆˆ ğº ğ‘‡ . The security of these algorithms relies on the assumption that the BDH is hard to solve. 3. Computational Diffie-Hellman (CDH) problem: Given ğ‘¥, ğ‘¦ âˆˆ ğ‘ ğ‘ and < ğ‘ƒ, ğ‘¥ğ‘ƒ, ğ‘¦ğ‘ƒ > , compute ğ‘¥ğ‘¦ğ‘ƒ . The security of these algorithms relies on the assumption that the CDH is hard to solve."
    },
    {
      "heading": "Decision Diffie-Hellman (DDH) problem [11]:",
      "text": "Given ğ‘¥, ğ‘¦, ğ‘§ âˆˆ ğ‘ ğ‘ , and < ğ‘ƒ, ğ‘¥ğ‘ƒ, ğ‘¦ğ‘ƒ, ğ‘§ğ‘ƒ > check whether ğ‘§ = ğ‘¥ğ‘¦ğ‘€ğ‘œğ‘‘ğ‘. The security of these algorithms relies on the assumption that the DDH is hard to solve."
    },
    {
      "heading": "Gap Diffie-Hellman (GDH) problem:",
      "text": "A group of problems where DDHP is easy while CDHP is hard. The security of the proposed model discussed in this dissertation is based on the GDH problem."
    },
    {
      "heading": "Security Gaols",
      "text": "This section defines primary security goals and their notation applied throughout the remaining part of the dissertation. 1. Confidentiality: This concept ensures that only authorized individuals or entities can access sensitive information. It is essential to keep the information confidential to prevent unauthorized disclosure, misuse, or information theft. 2. Integrity: This concept ensures that information is not altered, tampered with, or destroyed without authorization. Integrity ensures data remains accurate, consistent, and trustworthy throughout its lifecycle. 3. Authentication: This concept ensures that individuals or entities claiming to be who they are have been authenticated and are authorized to access the information. Authentication can be achieved through various means, such as passwords, biometrics, or digital certificates."
    },
    {
      "heading": "Authenticity:",
      "text": "This concept ensures that the information received is from the claimed entity and has not been tampered with or modified in transit. Authenticity is important to prevent data tampering, impersonation, or fraud."
    },
    {
      "heading": "Non-repudiation:",
      "text": "This concept ensures that the sender of a message cannot deny sending the message once it has been sent. Non-repudiation assures that the information received is authentic and has not been modified during transit. It is essential for legal and regulatory compliance."
    },
    {
      "heading": "Summary",
      "text": "This chapter provided an overview of the basic mathematical concepts required to understand the cryptographic model described in Chapter 3. The chapter began with an introduction to modular arithmetic, algebraic structures, groups, rings, and fields, which"
    },
    {
      "heading": "Cryptographic Building Blocks",
      "text": "This chapter provides an overview of the essential cryptography components employed in  3 Chapter Consequently, a receiver decrypts/verifies the encrypted/ signed message with his Private Key. One of the good things about this cryptosystem is that the private key must not be transmitted or revealed to anyone. Thus, security increased. It gives the facility a digital signature so the user can never deny its existence. From a security point of view, PKI believed in trusting the user's key rather than theirs. Suppose Eve has made the PKI, who ensures that his Public Key is identified as Alice's Public Key. So, Eve can modify all of Alice's communication as he has Alice's Public Key corresponding to Alice's Private"
    },
    {
      "heading": "Public Key Cryptosystem",
      "text": "Key. Thus, the Public Key system is required depending on the infrastructure that authenticates whether key pairs belong to claimed user. In the real world, this can be achieved with the help of the certificate authority."
    },
    {
      "heading": "Certification Authority",
      "text": "In a Public Key Infrastructure (PKI), a Certificate Authority (CA) is a trusted entity that issues digital certificates to entities (such as individuals, organizations, or devices) to verify their identity. A digital certificate is an electronic document containing a public key, the identity of the entity to which the certificate is issued, and other information such as the CA's digital signature, which validates the certificate's authenticity [60]. A CA acts as a trusted third party that verifies the identity of entities and issues digital certificates that attest to their identity. The CA's digital signature on the certificate ensures that the certificate is authentic and has not been tampered with. When a user wants to establish a secure communication channel with another entity, they can use the digital certificate to verify that entity's identity and encrypt and authenticate their communication. In a PKI, there can be one or more CAs that issue digital certificates. A hierarchical structure is often used in which a root CA issues certificates to intermediate CAs, which issue certificates to end entities. This structure allows for scalability and the ability to delegate certificate issuance to different organizations. A CA's role in a PKI is critical, as the trustworthiness of the entire system depends on the trustworthiness of the CA. Therefore, CAs are subject to strict security and operational requirements, including the use of secure cryptographic algorithms, regular audits, and secure storage of private keys."
    },
    {
      "heading": "Identity-based Cryptosystem",
      "text": "The concept of identity-based encryption first introduces by Adi Shamir [5], co-inventor of the RSA system, in 1984. It uses the user identity as a Public Key instead of the digital signature for encryption and signature verification. User identity can be anything they can uniquely identify, such as email-id, phone number, SSN, etc. Shamir's innovation was to eliminate the need for generating and managing the users' certificates. This feature reduces the complexity of the cryptosystem. This makes it more efficient to provide cryptography for novice users. Shamir's scheme [5] is based on the integer factorization of RSA. This scheme is built only for signature and verification. It becomes an open challenge for all researchers. Since then, many ID-based encryption schemes [22,31,39,44,45,46,47] have been introduced. In 2001, Boneh and Franklin [7] were the first to propose an identity-based encryption scheme based on bilinear pairing. Moreover after, Lynn [42] and cocks [34] were also two of several Identity-based encryption schemes."
    },
    {
      "heading": "Definition",
      "text": "This scheme consists of four algorithms (Setup, Extract, Encrypt, and Decrypt) as shown in figure 1.2 and runs as follows: â€¢ Setup: On input of a security parameter ğ‘˜, outputs a master secret ğ‘šğ‘ ğ‘˜ ğ‘ƒğ‘Ÿ and public parameters ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ . â€¢ Extract: Takes public parameters ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ , the master secret ğ‘šğ‘ ğ‘˜ ğ‘ƒğ‘Ÿ , and an ğ¼ğ· as input and returns the private key ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘Ÿ corresponding to ğ¼ğ·. â€¢ Encryption: Returns the encryption ğ¶ of the plaintext message ğ‘€ on the input of the public parameters ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ , ğ¼ğ·, and the arbitrary length message ğ‘€. â€¢ Decryption: Decrypts the Ciphertext ğ¶, back to the plaintext message ğ‘€ on the input of the private key, ğ· ğ¼ğ· corresponding to the receiving identity ID. 3.2.2 IBE vs PKC Public Key Cryptography (PKC) and Identity-Based Encryption (IBE) are two cryptographic systems used for secure internet communication. The main difference between the two lies in their approach to generating and verifying key pairs [15]. PKC and IBE differ in their approach to generating and verifying key pairs. PKC relies on users developing their key pairs and verifying public keys through digital certificates. At the same time, IBE uses identity information to derive public keys and relies on a trusted authority to generate and distribute private keys. Advantage: When compared to the traditional PKC, IBC has the following benefits: â€¢ System complexity: PKI systems are complex infrastructure due to the support of revocation lists and hierarchical organization of CA. On the other hand, the IBE scheme has only one PKG that serves to understand fully the IBE scheme that lightens complex infrastructure requirements. â€¢ User Friendly: Users with no knowledge of cryptographic primitives no longer have to make aware of the decision on the key length of their key. The Public Key in an IBE scheme is formulated to be transparent to users without knowledge of cryptography. Thus, on average, for any user, it is easy to memorize the username or e-mail address rather than authenticating the Public Key. â€¢ Certificate Management: In traditional PKI, there is a large number of users who get certifications from a trusted authority. As shown in the previous section, we have seen that it is challenging for management and distribute the user's certificate. While this could be avoided in the IBE scheme with the help of PKG, which generates the user's Private Key, using their unique identification entity, on user request. Disadvantage: When compared to the traditional PKC cryptosystem, the IBC has the following disadvantages: â€¢ Single point failure: Every user's Private Key is generated by the PKG in the system, consequently suffering the single point of failure. A new user can no longer get their Private Key if PKG disconnects the communication due to many extraction requests. â€¢ Key escrow: The PKG extracted and stored the user's private key. A malicious PKG can use this information to tap on the insecure channel between two users. The inherent property in ID-based encryption that Private Keys have to share with PKG is called key escrow [20]. On the contrary, traditional PKI only authenticates private and public keys; it does not have key escrow. â€¢ Public Key revocation: The generic IBE scheme does not support the revocation of Public Keys. Although, if the recipient is hasty towards his private key's privacy, his Private Key can get compromised. Indeed, several researchers have worked on the same issue [10,25]. It requires an extra infrastructure that makes the generic IBE system more complex. The main disadvantage of revoking of receiver key is that he can no longer receive an encrypted message. Thus, the practical solution to this problem in [7] is to append the expiration date along with the Public Key so that Public Key will have no use after the expiration date. Similarly, traditional PKI publishes revocation lists for a solution to the same issue, but this list makes PKI more complex."
    },
    {
      "heading": "Application of Identity-based encryption",
      "text": "Apart from Data encryption, digital signature, and key management, several other practical applications exist. Boneh and Franklin [7] show some applications: â€¢ Public Key Revocation: In an IBE scheme, it is easy to make key expiration by encrypting the message using the Public Key \"receiver-ID||current-time\". Unlike PKC, the receiver will query the PKG to obtain the new Private Key instead of getting new certificates eve time. Thus, the IBE scheme is a very efficient and powerful way of implementing ephemeral Public Keys. This proposal can also help send messages in the future since the receiver cannot decrypt the message until he obtains the Private Key for the date specified by the sender from the PKG. â€¢ Managing user credential: encrypt the message using the Public Key \"receiver-ID||current-time||Clearance-level\" so that the receiver can decrypt the message only if he has given Clearance. Consequently, PKG grants and revokes the user credential. â€¢ Delegation of the Private Key: Suppose a manager acts as a Private Key Generator in a company and has several assistants responsible for different jobs. The manager gives his assistants the Private Key corresponding to their responsibilities. So, according to his responsibility, each assistant can decrypt the message but cannot decrypt the message to another assistant because the manager has his master key so that he can decrypt all messages. â€¢ Forward secure encryption: In a forward-secure encryption scheme [49], each time the receiver's Private Key regularly evolves so that the Private Key of a particular period is compromised, every message encrypted in the past will be secure. chosen plaintext attacks, where an adversary can manipulate the plaintexts to learn about the encryption key or other sensitive information. More formally, an IBE system is IBE-IND-CPA secure if, for every adversary with an advantage Adv in winning the IBE-IND-CPA game illustrated in Game 1; there exists a negligible function Ñ” such that ğ´ğ‘‘ğ‘£ â‰¤ Ñ”. Aim: An adversary is challenged to check the IND-CPA security of an IBE scheme by a game. Output: This IBE-IND-CPA Game helps to define the concept of IND-CPA security for IBE schemes. 1. The challenger runs < ğ‘šğ‘ ğ‘˜ ğ‘ƒğ‘Ÿ , ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘  > < -ğ‘†ğ‘’ğ‘¡ğ‘¢ğ‘(1 ğ‘˜ ) and returns ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘  to the adversary. 2. The adversary can start querying an Oracle ğ‘‚ ğ‘’ğ‘¥ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘¡ (ğ¼ğ· ğ‘– ) that returns a private key ğ· ğ¼ğ· < -ğ¸ğ‘¥ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘¡(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ , ğ‘šğ‘ ğ‘˜ ğ‘ğ‘Ÿ , ğ¼ğ· ğ‘– ) corresponding to an adversarydefined identity ğ¼ğ· ğ‘– . 3. The adversary picks two equal-length plaintext messages ğ‘€ 0 and ğ‘€ 1 and an identity ğ¼ğ· ğ¶â„ğ‘ğ‘™ . The adversary honestly passes < ğ‘€ 0 , ğ‘€ 1 , ğ¼ğ· ğ¶â„ğ‘ğ‘™ > to the challenger. 4. The challenger picks a Random bit ğ‘ and executes ğ¶ < -ğ¸ğ‘›ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ , ğ‘€ ğ‘ , ğ¼ğ· ğ‘â„ğ‘ğ‘™ ). The challenger gives C to the adversary. 5. The adversary continues querying the Oracle ğ‘‚ ğ‘’ğ‘¥ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘¡ (ğ¼ğ· ğ‘– ) adaptively. To formally define IND-CCA, we again consider a game between an adversary and a challenger. The adversary is given access to a decryption oracle and can make a polynomial number of queries to this oracle. The challenger selects a random key pair and encrypts a random message, except for a challenge ciphertext. The adversary's goal is to correctly guess the bit that was used to randomly determine the encryption key, which is concealed in the challenge ciphertext. The adversary can submit ciphertexts to the decryption oracle to obtain the corresponding plaintexts. A secure encryption scheme is said to satisfy IND-CCA if the adversary's success probability in this game is negligibly close to 0.5. This means the adversary cannot distinguish between the encryption of the two possible messages, even when given access to a decryption oracle that allows them to obtain plaintexts for any ciphertext except the challenge ciphertext. IND-CCA is a stronger notion of security than IND-CPA and is typically required in applications where the adversary can obtain the decryption of ciphertexts of their choice. Examples of such applications include digital signatures and hybrid encryption schemes. In the non-adaptive case, steps 6 and 7 from Game 2 are prohibited. More precisely, an IBE scheme that satisfies Game 2 is considered IND-CCA2 secure. to the adversary."
    },
    {
      "heading": "The adversary can start querying an",
      "text": "Oracle ğ‘‚ ğ‘’ğ‘¥ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘¡ (ğ¼ğ· ğ‘– ) that returns a private key ğ· ğ¼ğ· < -ğ¸ğ‘¥ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘¡(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ , ğ‘šğ‘ ğ‘˜ ğ‘ğ‘Ÿ , ğ¼ğ· ğ‘– ) corresponding to an adversarydefined identity ğ¼ğ· ğ‘– . 3. The adversary can start querying another Oracle ğ‘‚ ğ·ğ‘’ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡ (ğ· ğ¼ğ·ğ‘– , ğ¶ ğ‘— ) that returns a plaintext ğ‘€ ğ‘— < -ğ·ğ‘’ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡(ğ· ğ¼ğ·ğ‘– , ğ¶ ğ‘— ) corresponding to an adversary-defined Ciphertext ğ¶ ğ‘— and identity ğ¼ğ· ğ‘– . 4. The adversary picks two equal-length plaintext messages ğ‘€ 0 and ğ‘€ 1 and an identity ğ¼ğ· ğ¶â„ğ‘ğ‘™ . The adversary honestly passes < ğ‘€ 0 , ğ‘€ 1 , ğ¼ğ· ğ¶â„ğ‘ğ‘™ > to the challenger. 5. The challenger picks a Random bit ğ‘ and executes ğ¶ < -ğ¸ğ‘›ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ , ğ‘€ ğ‘ , ğ¼ğ· ğ‘â„ğ‘ğ‘™ ). The challenger gives C to the adversary. 6. The adversary continues querying the Oracle ğ‘‚ ğ‘’ğ‘¥ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘¡ (ğ¼ğ· ğ‘– ) adaptively. 7. The adversary continues querying the Oracle ğ‘‚ ğ‘‘ğ‘’ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡ (ğ· ğ¼ğ·ğ‘– , ğ¶ ğ‘— ) adaptively. or step 7, the adversary also loses the game."
    },
    {
      "heading": "Key escrow",
      "text": "As we have seen, the user's identity (ID) is directly used as the Public Key, and the corresponding Private Key is generated by the PKG and stored in it. Therefore, an unusual property is inherent in the proposed IBE scheme. This property is called \"key  The trusted authority (PKG) is the one who never has pre-enrolled and wants to share a secret over an authenticated physical medium between all users joined to the same network. That means if two users or confidential channels. They may set up the required channel if both users trust this authority. However, what does \"trust\" mean here? What parameters are there which define how much possible for a user to trust the authority? The Girault proposed in the scheme [22] defines the levels of trust in PKG into three categories. As shown in Table 2.1, level 1 refers to those PKG who can easily compute a user's private key to impersonate any user without being detected, e.g. IBE. Level 2 refers to PKG, which cannot compute a user's private key but still can impersonate the user by generating fraud certificates, e.g. certificates signature scheme. That is why it requires level 3, in which PKG cannot find computer users' private keys and cannot impersonate any user without being recognized. Level 3 is the most advantageous one. The certificate-based scheme is the one which achieved Level 3. By the logic behind the PKC, the Private Key is secret to the user and the Public Key, publicly distributed over the network, need not be protected for confidentiality. It will make them subjected to several active attacks (such as the substitution of a \"false\" Public Key for a \"true\" one in a PKI directory). That is why, with the key pair and user's identity (ID), it is required to have the user's attribute (G), which guarantees that ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘Ÿ is the original Public Key of the user."
    },
    {
      "heading": "Related work",
      "text": "This section includes the literature on approaches to solving the key escrow problem in Public Key encryption."
    },
    {
      "heading": "Threshold Key Issuing",
      "text": "Threshold Key Issuing (TKI) allows multiple parties to jointly generate and distribute a secret key without one party having full knowledge [7]. The idea behind TKI is to split the secret key into multiple shares, such that a certain number of shares are required to reconstruct the key. This number is known as the threshold and is typically chosen such that it is less than the total number of shares but greater than or equal to half of the shares. The shares are distributed to the participating parties, and any subset of parties with the threshold number of shares can reconstruct the secret key [62]. TKI can be implemented using various mathematical techniques, such as Shamir's Secret Sharing or Polynomial Secret Sharing. These techniques involve generating a polynomial over a finite field, with the secret key as the constant coefficient [54]. The polynomial is then evaluated at different points to obtain the shares distributed to the parties. TKI has several advantages over traditional key distribution methods, such as eliminating the need for a trusted third party to generate and distribute the key and improving the security of the key by distributing it among multiple parties. TKI is commonly used in applications that require high levels of security, such as in financial transactions, military communication, and secure multi-party computation."
    },
    {
      "heading": "Certificate-Based Cryptosystem",
      "text": "A Certificate-Based Cryptosystem (CBC) is a public key cryptography scheme in which the identity of a user is verified by a trusted third-party certificate authority (CA) using digital certificates [44,45]. In a CBC, each user is assigned a public key by the CA, which is included in a digital certificate digitally signed by the CA. The digital certificate contains the user's identity, public key, and CA's digital signature. To send a message to another user, the sender encrypts the message using the recipient's public key, obtained from the recipient's digital certificate. The recipient can then decrypt the message using their private key, which is kept secret."
    },
    {
      "heading": "Certificate-Less Public Key Cryptosystem",
      "text": "Certificate-less Cryptosystems (CLC) are public key cryptography that addresses the key escrow problem by eliminating the need for digital certificates and trusted third-party Certificate Authorities (CAs) [46]. In CLC, users generate their own public and private keys without the involvement of a CA. The public key is derived from the user's identity information, such as an email address or a username, and a secure hash function. The user generates the private key using a random number generator or another secure process. The user's identity information and their public key are then distributed to other users who wish to communicate with them. By eliminating the need for digital certificates and trusted third-party CAs, CLC removes the possibility that a government or other entity may force a trusted third party to divulge a user's private key. Additionally, since the user generates the private key, there is no risk of a third-party holding a copy of the key. However, there are some limitations to CLC. One of the main limitations is the difficulty of key distribution since the public key must be distributed through other secure channels, such as email or in-person exchange. Additionally, since there is no centralized authority to verify identities, there is a risk of spoofing or impersonation. Despite these limitations, CLC is becoming an increasingly popular option for secure communication and data sharing in situations where traditional certificate-based systems may not be feasible or desirable, such as in peer-to-peer networks or in situations where there is a lack of trust in centralized authorities."
    },
    {
      "heading": "Hierarchical Identity-Based Cryptosystem",
      "text": "Horwitz and Lynn [33] suggested a hierarchy of PKGs in identity-based encryption. First, they introduce the 2 Level hierarchical IBE, where total collusion resistance is obtained at the first level and partial collusion resistance at the second Level. So, it has only limited resistance to user collusion. In scheme [39], Gentry and Silverberg extend the Boneh and Franklin scheme [7] to construct the fully flexible Hierarchical ID-based encryption scheme. PKGs generate Private Keys only for the users immediately below them in the hierarchy, as shown in figure 3.4. Threshold key issue ID Level 1 CB-PKC ID, ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘¢ğ‘ Level 3 CL-PKC ID, ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘¢ğ‘ , C Level 2 HIBE ğ¼ğ· ğ‘– Level 1"
    },
    {
      "heading": "Summary",
      "text": "This chapter summarises the fundamental building blocks of cryptography after presenting the basic mathematics in chapter 2. The first section of the chapter introduces public key encryption and its advantages and disadvantages, particularly in managing user certificates. The second section focuses on the thesis's main topic, identity-based encryption. It defines the basic concept of identity-based encryption and compares it with Public Key Infrastructure (PKI). It also discusses the applications, advantages, disadvantages, and security definition of identity-based encryption. The key escrow problem is introduced in the following section, along with a detailed discussion of some related literature on the subject. Finally, the chapter compares the existing schemes for solving the key escrow problem."
    },
    {
      "heading": "Secure Key Issue",
      "text": "This chapter expertly designs an ID-based encryption scheme that serves as a fair balance between the users and government agencies. Here, \"Fair balance\" means the user has the right to privacy, and the government can monitor the user's criminal activity over secure communication. In the first section (section 4.1), we define some existing solutions regarding the key escrow problem that will be useful for describing the given proposed model. Section 4.2 describes the proposed scheme by defining cryptographic goals based on the earlier threat model. In the following section, we design decisions on achieving these objectives and how this impacts our model. Section 4.2 concludes with a concrete proposal in the form of an algorithm and an evaluation section motivating why our cryptographic design goals were successfully met. In the next section (section 4.3), we define the security model for our scheme, which includes IND-CCA Type I and Type II attacks. The mathematical implementation of our model is applied in section 4.4."
    },
    {
      "heading": "Models of existing solution",
      "text": "We already discuss several approaches [22,31,39,44,45,46,47,48] that avoid the Key escrow problem inherited in the generic IBE scheme [5] in section 3.4. The most common work on Identity-based encryption to avoid key escrow problems is introduced by the Boneh-Franklin [7] using the threshold cryptography technique [50]. But it requires a large amount of infrastructure and more computational cost to implement such a scheme. Likewise, the same drawbacks exist with the hierarchal IBE [9,12], where the tuple of identities identifies the public key user from roots to him. Certification-based 4 Chapter encryption [45] does not preserve the identity-based encryption property. The public key revocation is additionally a significant disadvantage. However, the public key revocation is not a big issue; it can be removed by managing the key revocation list. That becomes a new problem and may require a high volume of space to store the certificates and computational time to verify those certificates. To solve the problem of managing revocation list, certificate-less encryption [46] was introduced. Indeed, this public key encryption variant solves many problems: key escrow problem, public key revocation, management of certificates, etc. it provides only implicit authentication to the public key. That means the sender will never know whether the given public key is the original public key of the recipient."
    },
    {
      "heading": "Security Goals",
      "text": "The standard general goals stated that the proposed scheme should be user-friendly and efficient. In addition to these generals' goals, it is also to define some cryptographic goals. A well-made encryption scheme should be able to achieve the following cryptographic goals: â€¢ Authenticity: The recipient has reasonable assurance that the claimed sender sends the message. â€¢ Confidentiality: The message is protected from disclosure by unauthorized persons. â€¢ Integrity: The message is protected from being modified by unauthorized users."
    },
    {
      "heading": "â€¢",
      "text": "No key escrow: The user's private keys are only disclosed to the owner of the claimed identity. No other user should be able to retrieve the private key. â€¢ Key validation: Each user in the system should be able to verify the correctness of their private key. â€¢ Limited key validity: The user's private key should not be valid for a limited period."
    },
    {
      "heading": "Authenticity:",
      "text": "Authenticity can be achieved by depending on authenticated encryption scheme. The authentication mechanism still depends on the security guarantees of the IBE scheme. Since a trusted third party, known as a private key generator, verifies the user's unique identifier corresponding to their public key. Accordingly, such an IBE confirms that a message encrypted with a public identifier can only be seen by the corresponding private key. If the authentication mechanism is insufficient, thus anyone could use it to impersonate the user. Our proposal is based on the Boneh-Franklin IBE scheme. Therefore, the scheme achieves authenticity."
    },
    {
      "heading": "Confidentiality:",
      "text": "Confidentiality can be achieved by applying an encryption scheme before sending a message. Identity-based encryption (IBE) can reach confidentiality and the general design goals of usability and applicability. During the design of our scheme, we can consider having several IBE schemes: Boneh and Franklin IBE [7], Sakai and Kasahara IBE [59] and Gentry IBE [37]. For the convenience of the desirable issue, we use the Boneh-Franklin IBE scheme as the encryption scheme."
    },
    {
      "heading": "Integrity:",
      "text": "Similar to authenticity, integrity can also be achieved depending on the security guarantees of the IBE scheme. If the scheme is sufficiently authenticated, no one can impersonate the user. As discussed in our proposal, our proposed scheme is derived from the Boneh-Franklin scheme. No Key Escrow: The IBE scheme inherently implies a property known as key escrow, which is undesired in the most practical system. To bypass the key escrow problem, multiple PKG was implemented as a distributed key generation system for IBE and several other schemes discussed in Section 3.4. To avoid the key escrow problem, we have proposed a scheme that will be discussed in section 4.2.4. Definition 4.4: (Private Key Privacy Organization) A single key privacy agency is a Non-Government Organization who has works between the user and PKG (Government agency) for the sake of users. PKPO is introduced to provide the privacy service to the private key by providing their signature in a confused manner. mapping, ğ» 1 : {0,1} * â†’ ğº * , ğ» 2 : ğ¹ * â†’ {0,1} ğ‘™ , ğ» 3 : {0,1} ğ‘› Ã— {0,1} ğ‘› â†’ ğ‘ ğ‘ , ğ» 4 : {0,1} ğ‘› â†’ {0,1} ğ‘› , and ğ» 5 : ğº 2 â†’ ğ‘ ğ‘ are five hash functions, where ğ‘™ denotes the length of a message. The PKG randomly chooses a master key ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘Ÿ âˆˆ ïšq and generate his public key ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘¢ğ‘ = ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘Ÿ. ğ‘ƒ . And then, KPA randomly chooses a key ğ‘ğ‘˜ğ‘ğ‘œ ğ‘ƒğ‘Ÿ âˆˆ Z q and create his public key ğ‘ğ‘˜ğ‘ğ‘œ ğ‘ƒğ‘¢ğ‘ = ğ‘ğ‘˜ğ‘ğ‘œ ğ‘ƒğ‘Ÿ. ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘¢ğ‘ . Now, publicly distribute the parameter < ğº, ğ¹, ğ» 1 , ğ» 2 , ğ» 3 , ğ» 4 , ğ» 5 , ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘¢ğ‘ , ğ‘ğ‘˜ğ‘ğ‘œ ğ‘ƒğ‘¢ğ‘ >. 2. Key Extract: As shown in figure 4.1, three entities (user, PKG, and PKPO) are participating in issuing a private key. This process includes the following three stages: â–ª Partial Key Supply: The user chooses ğ‘¢ğ‘ ğ‘˜ğ‘” ğ‘ƒğ‘Ÿ âˆˆ Z q and generate his public key ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘¢ğ‘ = ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘Ÿ ğ‘ƒ and request PKG to provide a partial private key by giving ğ‘¢ğ‘ ğ‘˜ğ‘” ğ‘ƒğ‘¢ğ‘ and ID as follows: â–ª Check the identification of users â–ª Compute the public key of a user as ğ‘„ ğ¼ğ· = ğ» 1 (ğ¼ğ·, ğ‘ƒ 0 , ğ‘ƒ 1 ) â–ª Compute Partial private key ğ‘„ ğ‘ğ‘˜ğ‘” = ğ‘ğ‘˜ğ‘” ğ‘ğ‘Ÿ ğ‘„ ğ¼ğ· ğ» 5 (ğ‘’(ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘Ÿ ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘¢ğ‘ , ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘¢ğ‘ )) ğ‘‡ ğ‘ğ‘˜ğ‘” = pkg Pr Q pkg â–ª Moreover, it sends it to the user â–ª Key Securing: The user requests PKPO to provide key privacy service by sending ID, ğ‘¢ğ‘ ğ‘˜ ğ‘ƒğ‘¢ğ‘ , ğ‘‡ ğ‘ğ‘˜ğ‘” and ğ‘„ ğ‘ğ‘˜ğ‘” â–ª Check ğ‘’( ğ‘‡ ğ‘ğ‘˜ğ‘” , ğ‘ƒ) == ğ‘’(Q pkg , pkg Pub ) â–ª Compute Q pkpo = pkpo Pr Q pkg H 5 (e(pkpo Pr usk Pub , pkg Pub )) ğ‘‡ ğ‘ğ‘˜ğ‘ğ‘œ = pkpo Pr Q pkpo . â–ª Send ğ‘‡ ğ‘ğ‘˜ğ‘ğ‘œ and Q pkpo to the user. â–ª Key Fetching: The user retrieves his private key ğ· ğ¼ğ· = ğ‘„ ğ‘ğ‘˜ğ‘ğ‘œ H 5 (e(pkg Pub, pkg Pub ) usk Pr ). H 5 (e(pkpo Pub, pkpo Pub ) usk Pr ) ğ· ğ¼ğ· = pkg Pr . pkpo Pr ğ‘„ ğ¼ğ· The user can check the correctness of his private key by e(QID, pkg Pub ) ?= e(DID, P)."
    },
    {
      "heading": "Security Model",
      "text": "Now, we are ready to define the adversaries for the M-IBE scheme. The general security definition for IBE requires the indistinguishability of encryptions against a fully-adaptive chosen ciphertext attacker (IND-CCA). By this definition, we have two entities, the adversary ğ´ğ‘‘ğ‘£ and the challenger ïƒ. After presenting the random public key, the adversary controls it in three phases. In phase 1, ğ´ğ‘‘ğ‘£ randomly constructs decryption queries on the Ciphertext. In the challenge phase, ğ´ğ‘‘ğ‘£ choose ğ‘€ 0 , ğ‘€ 1 and C* for messages ğ‘€ ğ‘ given by the challenger, where ğ‘€ 0 , and ğ‘€ 1 are two random messages and C* is challenged Ciphertext. Phase 2 continues constructing more decryption queries; indeed, it cannot have info for the decryption of C*. Finally, ğ´ğ‘‘ğ‘£ guess bit ğ‘ â€² corresponds to ğ‘. The ğ´ğ‘‘ğ‘£ 's advantage is defined to be Here, we explore the BF model to permit adversaries to extract the partial private keys, or private keys, or both, for random Identities and replace the public key with identity with a random value. A list of activities that an adversary can take against an M-IBE scheme is given below: â€¢ Partial Key Supply: To derive the partial key < ğ‘„ 0 , ğ‘‡ 0 > for user ğ´ğ‘‘ğ‘£ , ïƒ provides the output by running the algorithm Partial-key-supply. â€¢ Key securing: To acquire the mystified private key ğ‘„ 1 for user ğ´ğ‘‘ğ‘£, ïƒ gives output by running the algorithm key-securing. â€¢ Key obtaining: ğ´ğ‘‘ğ‘£ requests the user's private key. To compute the actual private key ïƒ , the algorithm key extracts if the corresponding public key is not changed. â€¢ Request public key: Suppose ğ´ğ‘‘ğ‘£ has public keys. To calculate the public key PA for user ğ´ğ‘‘ğ‘£, C runs the algorithm set-public-key and responds to ğ´ğ‘‘ğ‘£. â€¢ Replace public key: ğ´ğ‘‘ğ‘£ can adaptively replace the public key PA for user ğ´ğ‘‘ğ‘£ with any random P'A. â€¢ Decryption query: To get private key SA, ïƒ runs the algorithm Set-Private-Key and then the decryption algorithm and respond to ğ´ğ‘‘ğ‘£, if ğ´ğ‘‘ğ‘£ has not substituted the user's public key. Otherwise, ïƒ could not decrypt. However, our need is that ïƒ decrypts Ciphertexts for those public keys have been substituted. However, ğ´ğ‘‘ğ‘£ is permissible to substitute the public key for ğ¼ğ· ğ‘â„ with a new ID and then request a decryption of C*. We assumed that adversaries who have master-key were not permitted to substitute public keys. Here, we will try our PKG to achieve the same level of trust as CA in a traditional PKI. So we will classify adversaries into two types with different potentials: M-IBE Type I Adversary: Denoted as ï I , such adversaries do not have master-key. Indeed, ï I can request public keys and substitute them with new values of its choice, extract partial private and private keys and constructs decryption queries for each identity of its choice. Additionally, some limitations on adversary ğ´ğ‘‘ğ‘£ ğ¼ are: 1. Given ğ¼ğ· ğ‘â„ , ğ´ğ‘‘ğ‘£ ğ¼ cannot extract the private key. 2. If the user's public key has already been substituted, ğ´ğ‘‘ğ‘£ ğ¼ cannot request the private key for any identity. 3. Before the challenge phase, ğ´ğ‘‘ğ‘£ ğ¼ do not allow substituting the public key for the challenge identity ğ¼ğ· ğ‘â„ and extracting the partial private key. 4. In Phase 2, ğ´ğ‘‘ğ‘£ ğ¼ does not allow the construction of a decryption query on the challenge Ciphertext ğ¶ ğ‘â„ with an identity ğ¼ğ· ğ‘â„ and public key ğ‘ƒ ğ‘â„ . M-IBE Type II Adversary: Denoted as ğ´ğ‘‘ğ‘£ ğ¼ğ¼ , such adversaries have master-key. Indeed, ğ´ğ‘‘ğ‘£ ğ¼ cannot substitute the public key. Using the master key, Adversary ğ´ğ‘‘ğ‘£ ğ¼ğ¼ can compute partial private keys. Additionally, some limitations on adversary ğ´ğ‘‘ğ‘£ ğ¼ are: 1. ğ´ğ‘‘ğ‘£ ğ¼ğ¼ does not allow substituting public keys. 2. ğ´ğ‘‘ğ‘£ ğ¼ğ¼ does not allow extracting the private key for ğ¼ğ· ğ‘â„ . 3. In Phase 2, ğ´ğ‘‘ğ‘£ ğ¼ do not allow the construction of a decryption query on the challenge Ciphertext ğ¶ ğ‘â„ with an identity ğ¼ğ· ğ‘â„ and the public key ğ‘ƒ ğ‘â„ . Chosen Ciphertext security for M-IBE M-IBE scheme is semantically secure against an adaptive chosen Ciphertext attack ('IND-CCA secure\") if no polynomial bounded adversary ïof Type I or Type II has a non-negligible advantage against the challenger in the following game: â€¢ Setup: For security parameter K, Challenger ïƒ runs the Setup algorithm. It responds ğ´ğ‘‘ğ‘£ to the output of system parameters ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ . Challenger ïƒ keeps the master key for Type I adversary. Otherwise, it gives to ğ´ğ‘‘ğ‘£. â€¢ Phase 1: ğ´ğ‘‘ğ‘£ provides the number of requests. Each request for partial private key extraction, a private key extraction, a public key, a substitute public key or a decryption query for an individual user. According to the rules defined above, these queries can be run adaptively. â€¢ Challenge Phase: ğ´ğ‘‘ğ‘£ responds to the challenge identity ğ¼ğ· ğ‘â„ and two equallength message ğ‘€ 0 and ğ‘€ 1 . The Challenger randomly chose a bit b âˆˆ {0, 1} and computes ğ¶ ğ‘â„ . If encryption gives â”´, then ğ´ğ‘‘ğ‘£ lose the game. Otherwise, ğ¶ ğ‘â„ is given to ğ´ğ‘‘ğ‘£. â€¢ Phase 2: According to the rule defined above, ï provides a second sequence of requests similar to Phase 1. â€¢ Guess: A response with a guess ğ‘ â€² âˆˆ {0, 1} . If ğ‘ â€² = ğ‘, ğ´ğ‘‘ğ‘£ wins the game with )"
    },
    {
      "heading": "M-IBE schemes from Pairing",
      "text": "In this section, we implement identity-based encryption free from key escrow problems based on our proposed model. The first scheme, BasicM-IBE, is identical to the BasicIdent scheme of [7] and contains the basis of our most important scheme FullM-IBE. The master scheme is identical to the scheme FullIdent of [7]. Assuming the difficulty of GBDHP, our scheme is IND-CCA secure."
    },
    {
      "heading": "Basic M-IBE scheme",
      "text": "Here, we describe the four algorithms required to understand the fundamental ideas underlying our scheme that is identical to BasicIdent [7]. Bob can decrypt the message. Output: Alice sends an encrypted Ciphertext C that Bob successfully decrypts without losing confidentiality. 1. Setup: This phase is identical to the Setup phase of Algorithm 4.1. 2. Key extract: Identical to the KeyExtract phase in algorithm 4.1. 3. Encrypt: Alice randomly chooses ğ‘Ÿ âˆˆ Z q and may encrypt her message using Bob's identity ID by â€¢ Compute ğ‘Ÿ = H 3 (ğ‘§, ğ‘€), where ğ‘§ âˆˆ {0,1} * â€¢ ğ‘„ ğ¼ğ· = ğ» 1 (ğ¼ğ·, ğ‘ğ‘˜ğ‘” ğ‘ƒğ‘¢ğ‘ , ğ‘ğ‘˜ğ‘ğ‘œ ğ‘ƒğ‘¢ğ‘ ) and ğ‘” = ğ» 2 (ğ‘’(ğ‘„ ğ¼ğ· , ğ‘ğ‘˜ğ‘ğ‘œ ğ‘ƒğ‘¢ğ‘ )) â€¢ The resulting Ciphertext ğ¶ =< ğ‘ˆ, ğ‘‰, ğ‘Š >=< ğ‘Ÿğ‘ƒ, ğ‘§ âŠ• ğ» 2 (ğ‘” ğ‘Ÿ ), ğ‘€ âŠ• ğ» 4 (ğ‘§) > â€¢ C Sent to Bob. 4. Decrypt: Bob can decrypt C by computing â€¢ ğ‘”â€² = ğ‘’(ğ‘ˆ, ğ· ğ¼ğ· ) and ğ‘§ â€² = ğ‘‰ âŠ• ğ» 2 (ğ‘”â€²)   â€¢ ğ‘€ â€² = ğ‘Š âŠ• ğ» 4 (ğ‘§â€²) and ğ‘Ÿ = ğ» 4 (ğ‘§ â€² , ğ‘€) Return the message ğ‘€ â€² if U= ğ‘Ÿâ€²ğ‘ƒ. The scheme's consistency will be discussed in the next chapter, and we analyze that in decryption, z' and encryption z are equals. This completes the FullM-IBE scheme."
    },
    {
      "heading": "Summary",
      "text": "This chapter presents the implementation of the scheme proposed in section 1.1, which aims to address the key escrow problem in cryptographic systems. Firstly, a review of the related scheme model is provided. Subsequently, cryptographic objectives that must be achieved in the proposed scheme are defined, and a model is designed to meet these objectives. In the subsequent section, an algorithm for the proposed scheme is described, and BasicM-IBE and FullM-IBE are implemented, which are similar to BasicIden and FullIden as presented in [7]. The Full-IBE is designed to be secure against IND-CCA adversaries. a) ï‚ outputs ğ‘„ 1 (ğ¼ğ·) = ğ‘„ ğ‘– if ID found in the ğ» 1 list, b) ï‚ Randomly chooses ğ‘ ğ¼ from ğ‘ ğ‘ , gives ğ» 1 (ğ¼ğ·) = ğ‘ ğ¼ ğ‘„ and adds the tuple < ğ¼ğ· ğ‘– , ğ‘„, ğ‘ ğ¼ , â”´, â”´ , ğ‘¥ ğ‘– , ğ‘¦ ğ‘– , ğ‘ƒ 0 , ğ‘ƒ 1 , ğ‘ƒ 2 > to the ğ» 1 list, if ID does not find in the ğ» 1 list such that ID is I-th distinct ğ» 1 query made by ğ´ğ‘‘ğ‘£ ğ¼ . c) Otherwise, when ID does not exist in the list and ID is the i-th distinct ğ» 1 query made by ğ´ğ‘‘ğ‘£ ğ¼ where i â‰ I, ï‚ randomly chooses bi, xi and yi from Zq, givesH(ID) = bi.P and adds <ID, bi.P, bi, xi, yi, xi.P, xi.P0, yi.P> to the H1 list if ID does not find in list where ID is the i-th H1 query such that I â‰  i. After the definition of H1, the FullM-IBE partial Private Key for IDi = bi.P0 such that i â‰  I. Thus, the Public Key is <xi.P, xi.P0>, and the Private Key is <xi.bi.P0> for IDi when c = 0. Otherwise, ï‚ can compute s0.bI.Q, the partial Private Key of IDI. â€¢ H2 and H4 queries: ï I makes H2 queries and passed them to the challenger ïƒ. Adversaryï I makes H4 query and ï‚ passes this query to ïƒ, indeed, keeps list <Ïƒ'i,H4,i> and ïƒ's answer to them. â€¢ H3 queries: 1) Adversary ï I makes H4 query and ï‚ passes this query to ïƒ, indeed, keeps list <Ïƒ'i.Mj, H3,j> and C's answer to them. 2) ï‚ manages a list of tuples < Q, bi, xi, yi, N1i, N2i> which is initially empty. â€¢ H5 queries: Let Zi= e(xi.yi.P, -xi.bi.P) When ïI queriesH5, ï‚responds as follows: Phase 1: ïI receives params from ï‚ and make many requests for a user, including a partial Private Key extraction, a private key extraction, a request for a public key, a substitution a Public Key or a decryption query. ï‚ replies to these requests as follows: â€¢ Partial Private Key Extraction: Let ïI request IDi. One of the three cases will occur: â–ª ï‚ outputs with biP0, if i â‰ I. â–ª ï‚ aborts, if i = I and c = 0. â–ª ï‚ outputs with s.bI.Q, if i = I and c = 1. â€¢ Private Key Extraction: Let AI make the request on IDi. Let the Public Key for IDi has not been the substitute. One of the two cases will occur: â–ª Brespondsxi.bi.P0, if i â‰  I. â–ª Otherwise, B aborts. â€¢ Request for Public Key: Let ïI request IDi.ï‚ returns <xi.P, xi.P0> by obtaining the H1 list. Finally, now we examine the probability that ï‚ in decryption query phase correctly controls all qD decryption queries of ğ´ğ‘‘ğ‘£ ğ¼ . Thus, ï‚'s advantage is at least Ñ” 2q 1 q 5 Î» q D . It follows that either ï‚'s advantage as a Type I adversary or ï‚'s advantage as a Type II adversary at least one public information share on the communication network. At the same time, CL-PKC takes three public pieces of information."
    },
    {
      "heading": "Compared with other schemes",
      "text": "Compared with CB-PKC, our scheme preserves the advantage of ID-based cryptography and has one number of public information on the network. At the same time, CB-PKC has two numbers of public information, as shown in Table 5.2. Both schemes achieve the third level of trust on PKG. From a computational point of view, our scheme is faster in encryption and decryption. At the same time, our scheme is slightly slower than another scheme in the key issuing process. Compared to VIBE, as shown in Tables 5.1 and 5.2, our scheme is performed well and faster in encryption algorithm and has a minimum number of public information shared on the network. Here, we analyze that our scheme is the most advantageous variant of the generic IBE scheme that removes the inherited key escrow problem with the following advantage: â€¢ Minimum of public information shared on the network â€¢ Achieve trust level 3 on PKG â€¢ Preserve the advantage of the ID-based cryptosystem. Moreover, with the minimum computational cost of encryption and decryption, our scheme will be more efficient for low-power consumption devices, where key issuing overload dominates the server side.  CLAIM 4: Key recovery. In the case of PKG compromising the Private Key by the PKG, the user and the PKPO may claim that the Private Key DID has been compromised by PKG and file a legal case against the PKG in court. Consequently, PKG will be present in the Court for their punishment. In the case of the malicious user, PKPO may claim on the victim's request that the user may be malicious and acting in a mischievous activity."
    },
    {
      "heading": "Claim",
      "text": "Consequently, all three entities (PKG, PKPO, and user) will present in court on-a legal court order and release their master key to derive the user Private Key DID. Thus, the judge may recover the Private Key and decrypt the malicious message."
    },
    {
      "heading": "Summary",
      "text": "This chapter demonstrates the consistency of the encryption and decryption algorithms 4.2 and 4.3. Furthermore, we prove that our scheme is secure against IND-CCA1 of type I and Type II attacks, as stated in Theorem 1, supported by Lemma 2 through Lemma 7. In the subsequent section, we perform a comparative analysis of our scheme with HIBE, VIBE, threshold key issuing, CL-PKC, and CB-PKC. Based on the results in Tables 5.1 and 5.2, our scheme outperforms the others. Finally, we assert that our scheme of transforming a generic IBE into a fair ID-based cryptosystem is consistent with the objective stated in Chapter 1 (Section 1.4). applications in various domains, such as healthcare, finance, and education, warrant further investigation."
    },
    {
      "heading": "Applications and Future Scope",
      "text": "The resulting infrastructure, designed for low computation on the client side and overload shifted to the server side (PKG) on the cloud, is environment-friendly, practical, and instantly ready to use. â€¢ The infrastructure is instantly ready to use, eliminating the need for additional steps once the user joins the network and issues their private key. The encryption and decryption process requires minimal computation cost and the lowest number of public information sharing on the network, providing a user-friendly and efficient solution. â€¢ Moreover, the proposed scheme is environment-friendly, as compared to previous approaches. It balances the user's right to privacy with the government's right to monitor unlawful messages, utilizing a server-side approach to reduce computation on the client side. â€¢ The infrastructure is also practical, as wireless devices increasingly influence daily life, with applications expected to increase daily. The proposed solution shifts the maximum computation operation to the server side, reducing the computations required on the client side. Thus, the proposed solution is applicable for encryption and decryption in low-computation devices like mobiles, laptops, and tablets on the customer side."
    }
  ]
}