{
  "paperid": "0510042v1",
  "title": "Secure and Practical Identity-Based Encryption",
  "authors": [
    "Naccache",
    "Bellare",
    "Rogaway",
    "Boneh",
    "Franklin",
    "Boneh",
    "Boyen",
    "Boneh",
    "Boyen",
    "Canetti",
    "Halevi",
    "Katz",
    "Canetti",
    "Halevi",
    "Katz",
    "Cocks",
    "Shamir",
    "Waters"
  ],
  "year": 2005,
  "abstract": "In this paper, we present a variant of Waters' Identity-Based Encryption scheme with a much smaller public-key size (only a few kilobytes). We show that this variant is semantically secure against passive adversaries in the standard model.In essence, the new scheme divides Waters' public key size by a factor ℓ at the cost of (negligibly) reducing security by ℓ bits. Therefore, our construction settles an open question asked by Waters and constitutes the first fully secure practical Identity-Based Encryption scheme 1 .",
  "sections": [
    {
      "heading": "Introduction",
      "text": "The concept of Identity-Based Encryption (ibe) was invented by Shamir in 1984 [9]. It allows a party to encrypt a message using the recipient's identity as a public key. The corresponding private-key is provided by a central authority. The advantage of ibe over conventional public-key encryption is that it avoids certificate management, which greatly simplifies the implementation of secure communications between users. With an ibe scheme, users can simply use their email addresses as their identities. Moreover, the recipient does not need to be online to present a public-key certificate before the sender encrypts a message, and the sender does not have to be online to check the validity of the certificate. There are currently two ibe security notions. The stronger notion, called semantic security against passive adversaries (IND-ID-CPA), was introduced by Boneh and Franklin in [2]. As per this notion, the adversary can request the private keys for identities of his choosing; eventually he must be able to distinguish the encryption of two messages for an identity he decides of 2 . This notion will be described in detail in section 2. A weaker notion of security, introduced by Canetti, Halevi and Katz in [5,6], is called selective-id semantic security against passive adversaries (IND-sID-CPA). As per this notion, the adversary must commit ahead of time to the identity that it will attack, that is, before he receives the public parameters. In this paper, an ibe scheme satisfying the stronger notion will be called fully secure. The present paper's goal is to construct a practical and fully secure ibe scheme. There are several security models for public-key cryptosystems. The random oracle model has been introduced by Bellare and Rogaway as a \"paradigm for designing efficient protocols\" [1]. It assumes that all parties, including the adversary, have access to a public, truly random hash function H. In practice, this ideal hash function H is instantiated as a concrete cryptographic hash function (for example, sha-1 [8]). This model proved to be extremely useful for designing simple, efficient and highly practical solutions for many problems. However, from a theoretical perspective, it is clear that a security proof in the random oracle model is only a heuristic indication of the system's security when instantiated with a particular hash function such as sha-1. A contrario, in the standard model, one does not assume idealized oracle accesses. In the standard model, security is proven using only standard complexity assumptions. Consequently, from a security perspective, a proof in the standard model is preferable to a proof in the random oracle model. Therefore, an important research direction in modern cryptography is the construction of cryptosystems provably secure in the standard model, with an efficiency comparable to what can be achieved in the random oracle model. In this article an ibe scheme will be (sub silentio) called fully secure if it is fully secure in the standard model. Our goal is to construct a practical and fully secure ibe. The first efficient identity-based encryption scheme was proposed by Boneh and Franklin at crypto 2001 [2]. The Boneh-Franklin scheme is fully secure in the random oracle model. This scheme and all subsequent ibe schemes (except one exotic species [7]) are based on bilinear maps; the only known construction of bilinear maps is based on the Weil or the Tate pairing over certain families of elliptic curves. Since then, Boneh and Boyen proposed at eurocrypt 2004 an ibe scheme secure without random oracles, but reaching only selective id security [3]. Boneh and Boyen also proposed at crypto 2004 an ibe scheme fully secure in the standard model (i.e. without random oracles), but their scheme is too inefficient to be practical. Finally, the first practical and fully secure ibe scheme was proposed at eurocrypt 2005 by Waters [10]. Encryption and decryption are very efficient since only a few exponentiations and bilinear map computations are required. However, a drawback of Waters' scheme is that the size of the public parameters is very large: namely, the public parameters contain n + 4 group elements, where n is the size of the bit-string representing identities. Since n can be the output of a hash-function, we must take at least n = 160. Moreover, when an Elliptic Curve over F 2 p is used (the simpler setting), the size of a group element must be at least 1024 bits, to attain a security level equivalent to a 1024-bit rsa. Therefore, each participant must store at least 164 kilobytes of public parameters, which is prohibitive for most present-day \"normal\" smart card. In the conclusion of his eurocrypt 2005 paper [10], Waters states that finding an efficient identity-based encryption scheme secure without random oracles with short public parameters is an open problem. This paper solves this open problem and introduces a variant of Waters' scheme with a much smaller public-key size (only a few kilobytes). Eo ipso, we define the first practical identity based encryption Scheme, semantically secure against passive adversaries in the standard model."
    },
    {
      "heading": "Definitions",
      "text": "In this section we first recall the definition of an ibe scheme. We then recall the definition of semantic security against passive adversaries for ibe, introduced in [2]. An ibe consists scheme of four algorithms : -Setup : the Setup algorithm generates the system's public parameters, denoted by params, and a private master key denoted master-key. -Keygen : the Keygen algorithm takes as input an identity v and outputs the private key d v for identity v, using master-key. -Encrypt : the encryption algorithm encrypts messages for an identity v using params. -Decrypt : the decryption algorithm decrypts ciphertexts for identity v using the private-key d v . The semantic security of an ibe scheme is defined through the following scenario between an attacker A and a challenger C : -Setup : C generates the master public parameters and gives them to A. -Phase 1 : A can request the private-key corresponding to an identity v of his choice. A can repeat this multiple times for different identities. This completes the description of the scenario. The advantage of an adversary A in breaking the scheme is defined as : where the probability is taken over the adversary's random coins and the challenger's random coins. Definition 1 (ibe semantic security). An ibe scheme is said to be (t, q, ε)semantically secure if all t-time adversaries making at most q private key queries have an advantage at most ε in breaking the scheme."
    },
    {
      "heading": "Complexity Assumptions",
      "text": "The new construction is based on bilinear maps. In this section, we recall known facts and complexity assumptions on bilinear maps; the reader is referred to [2] for more details. Let G and G 1 be groups of prime order p and let g be a generator of G. We say that G has a bilinear map e : G × G → G 1 if the following conditions hold : e is efficiently computable, e is bilinear, that is e(g a , g b ) = e(g, g) ab for all a, b and e is non-degenerate, that is e(g, g) = 1. The Bilinear Diffie-Hellman problem is defined as follows : Definition 2 (Bilinear Diffie-Hellman Problem (bdh)). Given the 4-uple (g, g a , g b , g c ) where a, b, c ← Z p , output e(g, g) abc . The decisional version is defined in the usual manner : Definition 3 (Decisional Bilinear Diffie-Hellman Problem (dbdh)). Let g, g a , g b , g c defined as previously. Let β be a random binary coin. Let z = e(g, g) abc if β = 1, and let z be a random element in G 1 otherwise. Given (g, g a , g b , g c , z), output a guess β ′ of β. We say that an algorithm as an advantage ε in solving dbdh if Definition 4 (dbdh Assumption). We say that the (t, ε)-dbdh assumption holds in G if no t-time algorithm has an advantage at least ε in solving the dbdh problem in G."
    },
    {
      "heading": "The New Idea",
      "text": "The following describes a new practical and fully secure ibe scheme. The new scheme is a variant of Waters' ibe, but with shorter public parameters. Let G be a group of prime order p, let g be a generator of G, and let e be an admissible bilinear map into G 1 . Identities will be represented as n dimensional vectors v = (v 1 , . . . , v n ) where each v i is an ℓ-bit integer. The integers n and ℓ are parameters unrelated to p, and n ′ = n • ℓ is the output length of a collision-resistant hash function H : {0, 1} * → {0, 1} n ′ . Setup : A secret α ∈ Z p is chosen at random. One sets g 1 = g α and g 2 is chosen randomly in G. One chooses a random u ′ ∈ G and a random n dimensional vector U = (u i ) whose elements are randomly chosen in G. The public parameters are g, g 1 , g 2 , u ′ and U. The master secret is g α 2 . Keygen : ) n be an identity. Let r be random in Z p . The private key d v for identity v is constructed as : Encryption : A message m is encrypted for identity v as follows. A value t is chosen at random in Z p . The ciphertext is then : 3 ) be an encryption of m under identity v. The ciphertext c can then be decrypted using 4.1 How Does The New Cryptosystem Relate to Waters' Scheme? Our construction is a modification of the Waters' scheme [10]. Namely, in Waters' scheme, to encrypt a message for identity v = (v 1 , . . . , v n ′ ) ∈ {0, 1} n ′ , one computes the product : where U = (u 1 , . . . , u n ′ ) is an n ′ dimensional public vector. The new construction encodes identities as a n dimensional vectors v = (v 1 , . . . , v n ) where each v i is a ℓ-bit integers and n • ℓ = n ′ , and computes the modified product : where U = (u 1 , . . . , u n ) is now an n dimensional public vector. Therefore, the size of the public vector U is slashed by a factor n ′ /n = ℓ."
    },
    {
      "heading": "Performance",
      "text": "The size of the public parameter is n + 4 group elements, where n ′ = n • ℓ is the output size of a collision-resistant hash-function. If the value e(g 1 , g 2 ) is precomputed, encryption requires the equivalent of one exponentiation in G 1 and three exponentiations in G. Decryption requires two bilinear map computations, one group operation G 1 and one inversion in G 1 . Compared to Waters' scheme, the public parameter size is shrunk by a factor ℓ; encryption and decryption are almost as efficient as in Waters' scheme."
    },
    {
      "heading": "Security Proof",
      "text": "The following theorem proves that the new cryptosystem is fully secure in the standard model, under the Decisional Bilinear Diffie-Hellman Assumption. Theorem 1. The new ibe construction is (t, q, ε)-semantically secure, assuming that the (t ′ , ε ′ )-dbdh assumption holds, where : Proof. The security proof is very similar to Waters' proof given in [10]. Assume that there exists a (t, q, ε) adversary A. We construct a simulator B that solves the dbdh problem with advantage at least ε ′ . The simulator B receives the dbdh challenge (g, A = g a , B = g b , C = g c , z) and must output a guess β ′ as to whether z = e(g, g) abc (β = 1) or z is a random element in G 1 (β = 0). As in [10] we first describe a simulator B that does not quite work, and then we slightly modify it so that it works."
    },
    {
      "heading": "Setup:",
      "text": "The simulator B first sets an integer m = 2q and chooses randomly: (where 0 ≤ x ′ ≤ m -1). a y ∈ Z p and an n dimensional vector y = (y 1 , . . . , y n ) (where each For an identity v = (v 1 , . . . , v n ), we define the functions : The simulator lets g 1 = A and g 2 = B. It then defines the public parameters u ′ = g x ′ -km 2 g y ′ and u i = g x i 2 g y i . Therefore, the distribution of the public parameters is the same as in the attack scenario. We have that for any identity v : The following equality, valid if F (v) = 0 mod p, will be used to answer the private-key queries : Phase 1: The simulator B must answer the private key queries of A. Consider a query for identity v. To answer this query, it would be sufficient to have F (v) = 0 mod p. We observe that since -p < F (v) < p, we have that F (v) = 0 mod p implies F (v) = 0 and therefore F (v) = 0 mod m. Here we only answer the private-key query if F (v) = 0 mod m, which implies F (v) = 0 mod p. In this case, B generates a random r in Z p and constructs the private key d v as follows : Letting r ′ = r -a/F (v) and using (3), one obtains : which shows that d v is a valid private key for identity v, with the same distribution as in the attack scenario. Otherwise, if F (v) = 0 mod m, then the simulator B aborts and outputs a random bit β ′ as its guess for β."
    },
    {
      "heading": "Challenge:",
      "text": "The adversary submits two message m 0 and m 1 and an identity v * . Again, we distinguish two cases : if F (v * ) = 0 mod p, then the simulator B aborts and outputs a random bit β ′ . Otherwise, the simulator flips a fair binary coin γ and constructs the ciphertext : If B was given a legitimate bdh tuple, i.e. if z = e(g, g) abc , then by virtue of equation ( 2) and F (v * ) = 0 mod p we have : This shows that the ciphertext T is a valid encryption of m γ with the same distribution as in the attack scenario. Otherwise, we have that z is a random element of G 1 , which implies that the adversary obtains no information about γ whatsoever. Phase 2: The simulator B repeats the same operation as in Phase 1."
    },
    {
      "heading": "Guess:",
      "text": "The adversary outputs a guess γ ′ for γ. If γ = γ ′ , the simulator B outputs This completes the description of simulator B. As in [10], the problem with simulator B is that it aborts with a probability that is a function of the queried identities v and v * . Therefore, even if Pr[γ ′ = γ] > 1  2 + ε in the real attack scenario, we might have Pr[β ′ = β] ≃ 1 2 in the simulation. As in [10], a solution consists in artificially aborting the simulator at the end of the guess phase, so that the overall probability of aborting is made nearly constant. First, we analyse the probability that the simulator B aborts when answering a private-key query or in the challenge phase. To start with, we fix all the random variables that the adversary can see, including its random coins: we fix the bdh tuple (g, A = g a , B = g b , C = g c , z), the public parameters u ′ and the u i . We also fix the random numbers r ′ used when answering private-key queries, and the binary coin γ. Let P denote those fixed parameters. The adversary can then be seen as a deterministic algorithm. In particular, the identities v j , 1 ≤ j ≤ q queried by the adversary are fixed, and also the challenge identity v * . We observe that when those random variables are fixed, the random variables x ′ and x i still have an independent and uniform distribution between zero and m -1, and k has a uniform distribution between zero and 2 ℓ • n -1. We let V = (v 1 , . . . , v q ) be the list of private-key queries and let X = (x ′ , x 1 , . . . , x n ). We define the function : We have that the simulator B does not abort iff τ (X, v, v * , k) = 0. In Appendix a, we show the following lower bound for the probability that B does not abort : In the following, we modify the simulator so that it always aborts with probability nearly λ. In the guess phase, the new simulator B ′ will sample an estimate η ′ of the probability Pr X,k [τ (X, v, v * , k) = 0]. This probability is a function of v and v * . Then if η ′ > λ, simulator B ′ will proceed as in B with probability λ/η ′ , and artificially abort with probability 1 -λ/η ′ ; in this latter case, it outputs a random guess for β ′ . If η ′ ≤ λ, the simulator B ′ does not artificially abort. We assume that the simulator makes O(ε -2 ln(ε -1 )λ -1 ln(λ -1 )) samples. Using Chernoff's bound, one obtains the following bound for the estimate η ′ of η : Let Art denote the event that the simulator artificially aborts in the guess phase. Let Abort denote the event that the simulator aborts, either artificially or not. Then for a fixed parameter P, we have : Then for a randomly sampled η ′ , we obtain using (4) : One can show that the same inequality holds if η • (1 -ε/8) ≤ λ. Then since inequality (5) holds for any fixed parameter P, this remains true for a random P, conditioned on γ ′ = γ or γ ′ = γ, that is : Pr We have that if β = 1, the simulator succeeds if it outputs β ′ = 1; this happens if it aborts and then correctly guesses β ′ (with probability 1 2 ), or if it does not abort and γ = γ ′ : Using inequalities ( 6) and ( 7), we obtain : Since the adversary is a (t, q, ε)-adversary, we have that : This gives : proved that this variant is a fully secure in the standard model. The new scheme allows to compress the public parameter size by a multiplicative factor of ℓ, at the cost of reducing the security level by only ℓ bits. Therefore, the new scheme constitutes the first fully secure and fully practical identity-based encryption scheme known to date. ∀v, we have that This shows that if F (v * ) = 0 mod m, then there is a unique 0 ≤ k < n • 2 ℓ such that F (v * ) = 0 over the integers. Since k is uniformly and independently distributed between zero and 2 ℓ • n -1, we have that : We denote by A j the event that the simulator can answer the j-th private-key query : and by B ′ the event : We have that : We have : Pr[¬A j |B ′ ] (10) The pairwise independence of the function F (v) mod m stems from the following lemma, which proof is straightforward : Lemma 1. Let x ′ and x 1 , . . . , x n be random variables uniformly distributed between zero and m -1 and let F (v) = x ′ + n i=1 v i • x i . Then for all v = v ′ and all a, a ′ ∈ Z m , Then using (8), ( 9), (10), we obtain : 1 m And m = 2 • q yields the following lower bound λ :"
    }
  ]
}