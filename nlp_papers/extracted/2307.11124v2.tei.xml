<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Approximate Computing Survey, Part I: Terminology and Software &amp; Hardware Approximation Techniques</title>
				<funder ref="#_FdMxdpa">
					<orgName type="full">Advanced Technology Research Council</orgName>
					<orgName type="abbreviated">ATRC</orgName>
				</funder>
				<funder>
					<orgName type="full">ASPIRE</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2025-03-19">19 Mar 2025</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Vasileios</forename><surname>Leon</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Muhammad</forename><forename type="middle">Abdullah</forename><surname>Hanif</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Muhammad</forename><surname>Shafique</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">National Technical University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">New York University</orgName>
								<address>
									<settlement>Abu Dhabi</settlement>
									<country key="AE">United Arab Emirates</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">GIORGOS ARMENIAKOS</orgName>
								<orgName type="institution" key="instit2">National Technical University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Villanova University</orgName>
								<address>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">New York University</orgName>
								<address>
									<settlement>Abu Dhabi</settlement>
									<country key="AE">United Arab Emirates</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution" key="instit1">KIAMAL PEKMESTZI</orgName>
								<orgName type="institution" key="instit2">National Technical University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">National Technical University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="department">School of Electrical and Computer Engineering</orgName>
								<orgName type="institution">National Technical University of Athens</orgName>
								<address>
									<addrLine>Muhammad Abdullah Hanif</addrLine>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff8">
								<orgName type="department">Division of Engineering</orgName>
								<orgName type="institution">New York University Abu Dhabi</orgName>
								<address>
									<country key="AE">United Arab Emirates</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff9">
								<orgName type="department" key="dep1">Giorgos Armeniakos</orgName>
								<orgName type="department" key="dep2">School of Electrical and Computer Engineering</orgName>
								<orgName type="institution">National Technical University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff10">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Xun Jiao</orgName>
								<orgName type="institution" key="instit2">Villanova University</orgName>
								<address>
									<addrLine>Muhammad Shafique</addrLine>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff11">
								<orgName type="department">Division of Engineering</orgName>
								<orgName type="institution">New York University Abu Dhabi</orgName>
								<address>
									<country key="AE">United Arab Emirates</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff12">
								<orgName type="department">School of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Kiamal Pekmestzi</orgName>
								<orgName type="institution" key="instit2">National Technical University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff13">
								<orgName type="department" key="dep1">Dimitrios Soudris</orgName>
								<orgName type="department" key="dep2">School of Electrical and Computer Engineering</orgName>
								<orgName type="institution">National Technical University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Approximate Computing Survey, Part I: Terminology and Software &amp; Hardware Approximation Techniques</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2025-03-19">19 Mar 2025</date>
						</imprint>
					</monogr>
					<idno type="MD5">B07DE230DDFBD8E50D450A27BC481DCD</idno>
					<idno type="DOI">10.1145/3716845</idno>
					<idno type="arXiv">arXiv:2307.11124v2[cs.AR]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2" ident="GROBID" when="2025-11-07T10:20+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<label type="revision">a91ee48</label>
					<label type="parameters">startPage=-1, endPage=-1, consolidateCitations=0, consolidateHeader=0, consolidateFunders=0, includeRawAffiliations=false, includeRawCitations=false, includeRawCopyrights=false, generateTeiIds=false, generateTeiCoordinates=[], sentenceSegmentation=false, flavor=null</label>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Inexact Computing</term>
					<term>Approximation Method</term>
					<term>Approximate Programming</term>
					<term>Approximation Framework</term>
					<term>Approximate Circuit</term>
					<term>Approximate Arithmetic</term>
					<term>Error Resilience</term>
					<term>Accuracy</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The rapid growth of demanding applications in domains applying multimedia processing and machine learning has marked a new era for edge and cloud computing. These applications involve massive data and computeintensive tasks, and thus, typical computing paradigms in embedded systems and data centers are stressed to meet the worldwide demand for high performance. Concurrently, over the last 15 years, the semiconductor industry has established power efficiency as a first-class design concern. As a result, the community of computing systems is forced to find alternative design approaches to facilitate high-performance and powerefficient computing. Among the examined solutions, Approximate Computing has attracted an ever-increasing interest, which has resulted in novel approximation techniques for all the layers of the traditional computing stack. More specifically, during the last decade, a plethora of approximation techniques in software (programs, frameworks, compilers, runtimes, languages), hardware (circuits, accelerators), and architectures (processors, memories) have been proposed in the literature. The current article is Part I of a comprehensive survey on Approximate Computing. It reviews its motivation, terminology and principles, as well it classifies the state-of-the-art software &amp; hardware approximation techniques, presents their technical details, and reports a comparative quantitative analysis. CCS Concepts: • General and reference → Surveys and overviews; • Software and its engineering → Software notations and tools; • Hardware → Integrated circuits; • Computer systems organization → Architectures.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The proliferation of emerging technologies such as Artificial Intelligence (AI), Machine Learning (ML), Digital Signal Processing (DSP), big data analytics, cloud computing and Internet of Things (IoT) is driving the growing demand for computational power and storage requirements. The International Data Corporation (IDC) reported that the global data sphere is expected to grow from 33 zettabytes (2018) to 175 zettabytes by 2025 with a Compound Annual Growth Rate (CAGR) of 61% <ref type="bibr" target="#b40">[41]</ref>, highlighting the pressing need for more efficient computing solutions. This problem is intensified, especially when considering resource-restricted systems and/or battery-driven devices, such as smartphones and wearables <ref type="bibr" target="#b15">[16]</ref>.</p><p>Historically, the industry of computing systems was driven for more than 40 years by two fundamental principles: Moore's Law <ref type="bibr" target="#b129">[130]</ref> and Dennard's Law <ref type="bibr" target="#b45">[46]</ref>. Today, even though the number of transistors integrated per area is still increasing (Moore's Law), the supply voltage cannot be scaled according to Dennard's Law, and thus, the power density is increased. The end of Dennard's scaling combined with other factors (e.g., the cooling technology and the natural limits of silicon) led us to the "Dark Silicon" era <ref type="bibr" target="#b47">[48]</ref>. In this era, the power efficiency is a critical issue for computing systems, either they are placed at the edge (embedded systems) or on the cloud (data centers). Concurrently, the compute-intensive workloads of novel AI/ML and DSP applications challenge their deployment in terms of performance (speed). As a result, the industry of computing systems is forced to find new design/computing approaches that will improve the power efficiency while providing the desired performance. I: Need for Low-Power/Energy Computing. With the continuous shrinking of the transistor size into deep nanometer regime, the power/energy consumption has become a critical issue and a top priority to consider in the design of computing systems. Actually, with the current trend, scientists have predicted that by the year 2040 computers will need more electricity than the world's energy resources can generate, unless radical improvements are made in the computer design <ref type="bibr" target="#b142">[143]</ref>. The ever-increasing deployment of IoT devices <ref type="bibr" target="#b51">[52,</ref><ref type="bibr" target="#b66">67]</ref>, the exploding "Big Data" from all kinds of sources (e.g., videos and images), and the growth of supporting cyberinfrastructure such as data centers, are all exaggerating this situation.</p><p>This challenge is present in computing devices of all sizes -from low-power edge devices to high-performance data centers. For example, for mobile/edge devices used intensively in IoT endpoints, low-power/energy computing must be achieved to increase the battery life. On the other hand, data centers must achieve low-power/energy to reduce the costs in electricity and cooling, and achieve reliable operations. In certain applications (e.g., autonomous driving), the high power consumption could lead to an increased temperature of the computing chips, which will adversely affect the reliability of the chips and cause severe consequences. Recently, the increasing workload (in terms of data size and computational demands) from the AI, ML, and DSP domains are all worsening the issue of power/energy consumption. II: Need for Accelerated Computing. Many practical application domains, such as autonomous driving, robotics, and space, require real-time processing of data streams. However, the very nature of existing powerful algorithms pose significant challenges to the hardware implementations. A specific example is the recent massive deployment of AI/ML methods with millions of parameters, like in the case of Deep Neural Networks (DNNs). Typically speaking, the execution of DNN models requires a huge amount of computing operations, such as additions/multiplications and transformations, as well as intensive memory accesses, which may lead to a significant delay in processing data streams. This can cause compromised quality of results, especially in resourceconstrained edge devices that have real-time latency requirements.</p><p>How Can Approximate Computing Help? As Dennard's Law expired in the mid-2000s and Moore's Law is declining, the transistor scaling is increasingly less effective in improving performance, energy efficiency, and robustness. Therefore, alternative computing paradigms are urgently needed as we look to the future of the computing industry. Approximate Computing (AxC) has recently arisen as a promising candidate for resolving this challenge due to its success in many compute-intensive applications (e.g., image processing, object classification, and bio-signal analysis). Such applications show an inherent error tolerance, i.e., they do not require completely accurate computations for delivering acceptable output quality. For example, in image processing, a few pixel drops do not affect how images are perceived by human eyes; AI/ML may not need precise model parameters to get accurate results in classification and detection; communication systems are resilient against occasional noise. This paves the way for new optimization opportunities. By introducing a new design dimension -"accuracy" -to the overall design optimization, it is possible to trade off accuracy and lead to less power used, less time consumed, and fewer computing resources required. This leads to the promising novel design paradigm of Approximate Computing. Some examples of accuracy/quality metrics are peak signal-to-noise ratio (multimedia applications), relative difference (numerical analysis), and classification accuracy (machine learning).</p><p>The idea of leveraging imprecise computation for improved design dates back several decades in real-time system scheduling, where imprecise computation was used to enhance its dependability <ref type="bibr" target="#b103">[104]</ref>. Another related research field is Fault Tolerance, which seeks to continue to provide the required functionality despite occasional failures by hiding the errors <ref type="bibr" target="#b140">[141]</ref>. Compared to this field, Approximate Computing "intentionally" seeks to design imperfect hardware and software systems (induce errors) for improved performance and/or power/area efficiency. Specifically, researchers have built approximate integrated circuits, software programs, and architectures that outperform their conventional "accurate" counterparts in terms of resources (power, area, and/or performance). Approximate Computing has achieved tremendous success in many application domains and targets among other image processing <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4]</ref>, computer vision <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b14">15]</ref>, computer graphics <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>, machine learning <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14]</ref>, signal processing <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b13">14]</ref>, financial analysis <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14]</ref>, database search <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">14]</ref>, and scientific computing <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18]</ref>. The error resilience of such application domains and the relaxed constraints for the quality of the results constitute Approximate Computing as an applicable design paradigm. They originate from:</p><p>(1) The user's intention to accept inaccuracies and results of lower quality.</p><p>(2) The limited human perception, e.g., in multimedia applications. <ref type="bibr" target="#b2">(3)</ref> The lack of perfect/golden results for validation, e.g., in data mining applications. <ref type="bibr" target="#b3">(4)</ref> The lack of a unique answer/solution, e.g., in machine learning applications.</p><p>(5) The application's self-healing property, i.e., its capability to absorb/compensate errors by default. (6) The application's inherent approximate nature, e.g., in probabilistic calculations, iterative algorithms, and learning systems. <ref type="bibr" target="#b6">(7)</ref> The application's analog/noisy real-world input data, e.g., in multimedia/signal processing.</p><p>The prominent outcome of approximate systems, in parallel with the ever-increasing demand for efficient and sustainable computing, has attracted a vast research interest. In this context, approximation techniques are applied at different design layers, i.e., from software/programs to hardware/circuits. Motivated by the benefits of Approximate Computing, as well as the great momentum it has gained over the last years, we conduct a survey that is presented in two parts. The goal is to cover the entire spectrum of Approximate Computing. The contribution and the content of the two-part survey are analyzed in Section 2. </p><formula xml:id="formula_0">✓ ✓ ≈ ≈ ✗ ✗ ✓ ✗ ≈ ✗ ✗ ≈ [127]</formula><p>2015 33 1 84</p><formula xml:id="formula_1">✓ ≈ ✓ ≈ ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✗ [207] 2015 15 59 ✓ ✓ ✓ ✗ ≈ ✗ ✗ ✗ ≈ ✗ ✗ ✗ [199] 2015 6 54 ✓ ✓ ✓ ✗ ✗ ✓ ✗ ✗ ≈ ✗ ✗ ✗ [175] 2016 6 47 ✓ ✓ ✓ ✗ ✗ ≈ ✗ ✗ ≈ ✗ ✗ ≈ [131] 2017 4 40 ✓ ✓ ✗ ≈ ≈ ✗ ✗ ✗ ≈ ✗ ✗ ✗ [12] 2017 6 72 ✓ ✓ ✓ ≈ ≈ ≈ ✗ ✓ ≈ ✗ ✓ ✗ [182] 2020 39 1 235 ≈ ✓ ✓ ✗ ✓ ≈ ✗ ✗ ≈ ✗ ✓ ✗</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This work</head><p>Pt. 1 2023 36 1 222</p><formula xml:id="formula_2">✓ ✓ ✓ ✓ ✓ ✓ Pt. 2 2023 36 1 301 ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓</formula><p>1 Single-column pages. 2 Quantitative analysis involving count of works, frequencies and numerical assessments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">APPROXIMATE COMPUTING SURVEY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scope and Contribution:</head><p>The literature includes surveys on Approximate Computing that target specific areas, e.g., arithmetic circuits <ref type="bibr" target="#b70">[71]</ref> and logic synthesis <ref type="bibr" target="#b168">[169]</ref>, or focus on a single approximation technique, e.g., precision scaling <ref type="bibr" target="#b34">[35]</ref>. In <ref type="bibr" target="#b197">[198]</ref> and <ref type="bibr" target="#b12">[13]</ref>, a thorough analysis of software and hardware approximation techniques, respectively, is provided, but they are both laser-focused on DNN applications. Similarly, the survey of <ref type="bibr" target="#b42">[43]</ref> mainly reviews the impact of AxC on edge computing and none of the <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b70">71,</ref><ref type="bibr" target="#b168">169,</ref><ref type="bibr" target="#b197">198]</ref> surveys cover approximations from system level down to circuit level. In contrast, the proposed two-part survey covers the entire computing stack, reviewing and classifying all the state-of-the-art approximation techniques from the software, hardware, and architecture layers for a wide range of application domains. Table <ref type="table" target="#tab_0">1</ref> reports a list of surveys that can be classified along with the proposed one, showing a qualitative comparison and key aspects that characterize each work. In the current work, the AxC stack (pyramid of design layers) is formed as shown in Fig. <ref type="figure">1</ref>, and design techniques &amp; approaches from all the layers are analyzed. In fact, this is the traditional computing stack with the addition of various kind of approximation techniques across the design layers (from the application and software down to the hardware and device). It is worth mentioning that the proposed two-part survey is the first to report a quantitative analysis with numerical assessments at this extent. More explicitly, the current survey constitutes a comprehensive and detailed guide that provides a step-by-step explanation of key concepts, techniques, and applications of the AxC paradigm. The reader will have a complete view on AxC principles and works that implement and evaluate software, hardware, application-specific and architectural approximations. This survey also acts as a tutorial on the state-of-the-art approximation techniques. The main objectives and contributions of the survey are: 1) to attribute definitions in key AxC aspects and explain the main terminology, 2) to analyze the state-of-the-art works, identify approximation categories and cluster the reviewed works with respect to the approximation type/approach, 3) to survey application domains of AxC including the impact of approximations on them, and 4) to identify and discuss open challenges and future directions as a step towards the realization of approximate applications.</p><p>SW Approximation Techniques (e.g., Memoization, Skipping) Architectural Approximations (e.g., Approx. Processors) HW Approximation Techniques (e.g., Approx. Units) Application-driven Approximation Device-driven Approximation Application Language Runtime System Compiler Architecture Circuits Functional Blocks Device HW/SW Stack in Approximate Computing TPU v1 Fig. 1. The Approximate Computing stack: approximation techniques in the design abstraction layers. Paradigm AxC Approximate Progr. Languages Selective Task Skipping Precision Scaling Relaxed Synchronization Approximate Memoization Data Sampling Circuit Functional Approximation Voltage Over-Scaling Over-Clocking Principles Terminology Applications AxC Software Approximations Approximate Processors Approximate Data Storage Application-Driven Analysis Application Spectrum Error/Quality Metrics Benchmark Suites Hardware Approximations Cross-Layer Approximations End-to-End Approximations Motivation Challenges Part I Part II Future Directions Fig. 2. Organization of the proposed two-part survey on Approximate Computing.</p><p>Organization: As shown in Fig. <ref type="figure">2</ref>, the proposed survey is divided into two parts, which constitute standalone manuscripts focusing on different aspects/areas of Approximate Computing:</p><p>Part I: It is presented in the current paper, and it introduces the AxC paradigm (terminology and principles) and reviews software &amp; hardware approximation techniques. Part II: It is presented in <ref type="bibr" target="#b93">[94]</ref>, and it reviews application-specific &amp; architectural approximation techniques and introduces the AxC applications (domains, quality metrics, benchmarks). The remainder of the article (Part I of the survey) is organized as follows. Section 3 provides fundamental concepts of AxC, while the next two sections (Sections 4-5) review and classify software-and hardware-level works, respectively. Section 6 performs a quantitative analysis for all the reviewed approximation techniques. Finally, Section 7 concludes the survey.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THE APPROXIMATE COMPUTING PARADIGM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Terminology of Approximate Computing</head><p>Even though approximate computations have been examined since the 1960s (e.g., Mitchell's logarithmic-based multiplication/division <ref type="bibr" target="#b124">[125]</ref>), the first systematic efforts to define the Approximate Computing paradigm started in the late 2000s. Various terms have been used in the literature to describe strategies for delivering approximate architectures, programs, and circuits. Approximate Computing is synonymous or overlaps with these terms. Chakradhar et al. <ref type="bibr" target="#b26">[27]</ref> define Best-Effort Computing as "the approach of designing software/hardware computing systems with reduced workload, improved parallelization and/or approximate components towards enhanced efficiency and scalability". The term Relaxed Programming is introduced by Carbin et al. <ref type="bibr" target="#b22">[23]</ref> to express "the transformation of programs with approximation methods and relaxed semantics to enable greater flexibility in their execution". Chippa et al. <ref type="bibr" target="#b37">[38]</ref> use the term Scalable Effort Design for "the systematic approach that embodies the notion of scalable effort into the design process at different levels of abstraction, involving mechanisms to vary the computational effort and control knobs to achieve the best possible trade-off between energy efficiency and quality of results".</p><p>According to Mittal <ref type="bibr" target="#b126">[127]</ref>, "Approximate Computing exploits the gap between the accuracy required by the applications/users and that provided by the computing system to achieve diverse optimizations". Han and Orshansky <ref type="bibr" target="#b58">[59]</ref> distinguish Approximate Computing from Probabilistic/Stochastic Computing, stating that "it does not involve assumptions on the stochastic nature of the underlying processes implementing the system and employs deterministic designs for producing inaccurate results". Another interesting point of view is expressed by Sampson <ref type="bibr" target="#b164">[165]</ref>, who claims that Approximate Computing is based on "the idea that we are hindering the efficiency of the computer systems by demanding too much accuracy from them". The current article attributes the following definition: Approximate Computing: It constitutes a radical paradigm shift in the design and development of computing systems, circuits and programs, which is built on top of the error-resilient nature of various application domains and relies on disciplined methods to intentionally insert errors for providing valuable resource gains in exchange for tunable accuracy loss.</p><p>Table <ref type="table">2</ref> describes the most frequently used terms in Approximate Computing. The term error is used to indicate that the output result is different from the accurate result (produced with conventional computing). Error is distinguished from fault, which refers to an unexpected condition (e.g., stuck-at-logic in circuits, bit-flips in memories, faults in operating systems) that causes the system to unintentionally output erroneous results. Another significant term is accuracy, which is defined as the distance between the approximate and the accurate result and is measured using application-specific and general-computing error metrics. Accuracy is distinguished from precision, which expresses the differentiation between nearby discrete values and does not refer to errors of Approximate Computing but to quantization noise (inserted by the real-to-digital value mapping). Moreover, in Approximate Computing, the term Quality-of-Service (QoS) is used to describe the overall quality of the results regarding accuracy and errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Principles of Approximate Computing</head><p>To enable and realize significant efficiency gains through approximations, the design of approximate systems should be guided using the following steps/principles:</p><p>-Application Analysis: The quality requirements and metrics vary across applications. Therefore, it is essential to analyze the application in detail to identify the acceptable QoS and specify the error metrics that can truly quantify the output quality for evaluation and comparison.</p><p>Table 2. Terminology of Approximate Computing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Term Description</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error-Resilient Application</head><p>The application that allows computation errors and accepts results of lower quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Quality of Service</head><p>The quality of the results in terms of errors and accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Accuracy Constraint</head><p>The quality requirements that the results need to satisfy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error Bound/Threshold</head><p>The maximum error allowed in the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Golden Result</head><p>The result that is obtained from the original accurate computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acceptable Result</head><p>The result that satisfies the accuracy constraints and error bounds of the application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Variable Accuracy</head><p>The capability of providing different levels of accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Non-Critical Task/Computation</head><p>The task/computation that can be safely approximated due to its small impact on the quality of the output results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error Analysis</head><p>The study involving metrics, mathematics and simulations to examine the range, frequency, scaling, and/or propagation of the errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approximation Technique/Method</head><p>The systematic and disciplined approach to insert computation errors in exchange for gains in power, energy, area, latency, and/or throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approximation Degree/Strength</head><p>The aggressiveness of the approximation technique in terms of errors inserted and tasks/computations approximated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approximation Configuration</head><p>An instance of the parameters and settings of the approximation technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Frozen Approximation</head><p>The approximation that is fixed and cannot be re-configured at a different degree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic Approximation Tuning</head><p>The capability of adjusting the approximation degree at runtime to satisfy the desired error constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cross-Layer Approximation</head><p>The approximation that is applied at multiple design abstraction layers (software, hardware, architecture).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Heterogeneous Approximation</head><p>The approximation that applies concurrently multiple configurations of different degree within the same system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Application-Driven Approximation</head><p>The approximation that is applied with respect to the error resilience and sensitivity of the targeted application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Device-Driven Approximation</head><p>The approximation that is applied with respect to the targeted device/technology (e.g., CPU, GPU, ASIC, FPGA).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approximate Space Exploration</head><p>The study involving error analysis and resource gain quantification to examine trade-offs and select the most suitable approximation techniques/configurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approximation Localization</head><p>The systematic approach to locate the tasks/computations and design regions that are offered for approximation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error Modeling</head><p>The process of emulating the errors inserted by the approximations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error Prediction</head><p>The process of predicting errors before computing the final result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error Detection</head><p>The process of identifying an error occurrence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error Compensation</head><p>The process of modifying the erroneous result to reduce the error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error Correction</head><p>The process of replacing the erroneous result with the accurate one.</p><p>-Workload Analysis: Not all tasks/computations in an application can be approximated. Therefore, it is important to identify the non-critical tasks/computations (to be approximated) and isolate them from the critical ones. This is essential to enable disproportionate benefits, i.e., significant improvements in efficiency for a negligible loss in quality.</p><p>-Development of Approximation Methodology: To achieve ultra-high efficiency gains while ensuring that acceptable quality is maintained, approximations are required to be introduced systematically in the system. Moreover, the sources of disproportionate benefits are distributed across different layers of the computing stack. Therefore, to achieve a superior quality-efficiency trade-off, the development of sophisticated methodologies that can exploit the cross-layer knowledge of the system and deploy approximations systematically across various layers and sub-systems of the given system becomes an important step.</p><p>-Development of Error Models: Error estimation is vital for comparing different approximations. However, empirical evaluation of approximate implementations is time-consuming and costly (especially when inducing approximations at multiple design layers or at low-level hardware implementations). Therefore, it is essential to build models that can emulate the errors and examine the output quality of the system when approximated.</p><p>-Design Space Exploration: Typically, various types of approximations can be deployed in a system, where each sub-system/system module may have a completely different set of approximations that lead to disproportionate benefits. Therefore, design space exploration is performed to examine different approximation configurations, evaluate the approximation space and make decisions regarding the final approximate implementation that yields significant efficiency gains while meeting user-defined quality and performance constraints. These exploration methodologies are usually supported by error and performance models to efficiently search the approximation space.</p><p>-Error Analysis: Input distribution can have a profound impact on the resilience of the approximated system. Therefore, it is important to study the errors for different input distributions using appropriate error/QoS metrics.</p><p>-Quantification of Results: This is performed to prove the resilience of the application and ensure that constraints about QoS and/or resources are met.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SOFTWARE APPROXIMATION TECHNIQUES</head><p>This section classifies and presents approximation techniques that are applied at software level, i.e., the higher level of the design abstraction hierarchy. The goal of software Approximate Computing is to improve the execution time of the program and/or the energy consumption of the system. The techniques of the literature, illustrated in Fig. <ref type="figure" target="#fig_0">3</ref>, can be categorized into five classes: (i) Selective Task Skipping, (ii) Approximate Memoization, (iii) Relaxed Synchronization, (iv) Precision Scaling, (v) Data Sampling, and (vi) Approximate Programming Languages. Typical software approximation techniques integrate some of the following features: approximation libraries/frameworks, compiler extensions, accuracy tuning tools, runtime systems, and language annotations. Moreover, numerous of these techniques allow the programmer to specify QoS constraints, provide approximate code variants, and mark the program regions/tasks for approximation.</p><p>The remainder of this section reports representative state-of-the-art works for software approximation techniques. The references of these works are summarized in Table <ref type="table">3</ref>. The literature also includes software approximation frameworks, such as ACCEPT <ref type="bibr" target="#b165">[166]</ref> and OPPROX <ref type="bibr" target="#b125">[126]</ref>, which apply multiple state-of-the-art approximation techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Selective Task Skipping</head><p>4.1.1 Loop Perforation. The loop perforation technique aims at skipping some of the loop iterations in a software program to provide performance/energy gains in exchange for QoS loss. Subsequently, several relevant works <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b62">63,</ref><ref type="bibr" target="#b79">80,</ref><ref type="bibr" target="#b98">99,</ref><ref type="bibr" target="#b121">122,</ref><ref type="bibr" target="#b134">135,</ref><ref type="bibr" target="#b177">178,</ref><ref type="bibr" target="#b178">179,</ref><ref type="bibr" target="#b184">185]</ref>, which involve design space exploration on loop perforation with programming frameworks and profiling tools, are presented.</p><p>Starting with one of the first state-of-the-art works, the SpeedPress compiler <ref type="bibr" target="#b62">[63]</ref> supports a wide range of loop perforation types, i.e., modulo, truncation, and randomized. It takes as input the original source code, a set of representative inputs, as well as a programmer-defined QoS acceptability model, and outputs a loop perforated binary. In the same context, Misailovic et al. <ref type="bibr" target="#b121">[122]</ref> propose a QoS profiler to identify computations that can be approximated via loop perforation. The proposed profiling tool searches the space of loop perforation and generates results for multiple perforation configurations. In <ref type="bibr" target="#b178">[179]</ref>, the same authors propose a methodology to exclude critical loops, i.e., whose skipping results in unacceptable QoS, and perform exhaustive and greedy design space explorations to find the Pareto-optimal perforation configurations for a given QoS constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approx. Memoization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SOFTWARE APPROXIMATION TECHNIQUES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Loop Perforation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Selective Task Skipping Data Sampling</head><p>Computation Skipping</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Relaxed Synchronization Precision Scaling</head><p>Memory Access Skipping Table 3. Classification of software approximation techniques. SW Approximation Class References Loop Perforation [15, 63, 80, 99, 122, 135, 178, 179, 185] Computation Skipping [6, 21, 101, 149, 154, 155, 195, 196] Memory Access Skipping [82, 85, 119, 164, 211, 220] Approximate Memoization [8, 19, 28, 83, 110, 124, 148, 150, 163, 188, 218] Relaxed Synchronization [22, 116, 121, 123, 153, 156, 181, 183] Precision Scaling [20, 36, 37, 44, 45, 57, 81, 88-90, 102, 117, 158, 159, 171, 186, 213] Data Sampling [3, 9, 55, 64, 79, 86, 91, 139, 144, 145, 206, 221] Approx. Programming Languages <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b75">76,</ref><ref type="bibr" target="#b104">105,</ref><ref type="bibr" target="#b113">114,</ref><ref type="bibr" target="#b119">120,</ref><ref type="bibr" target="#b136">137,</ref><ref type="bibr" target="#b137">138,</ref><ref type="bibr" target="#b166">167,</ref><ref type="bibr" target="#b167">168,</ref><ref type="bibr" target="#b179">180,</ref><ref type="bibr" target="#b186">187]</ref> In <ref type="bibr" target="#b177">[178]</ref>, the authors propose an architecture that employs a profiler to identify non-critical loops towards their perforation. To protect code segments that can be affected by the perforated loops, the architecture is equipped with HaRE, i.e., a hardware resilience mechanism. Another interesting work is GraphTune <ref type="bibr" target="#b134">[135]</ref>, which is an input-aware loop perforation scheme for graph algorithms. This approach analyzes the input dependence of graphs to build a predictive model that finds near-optimal perforation configurations for a given accuracy constraint. Li et al. <ref type="bibr" target="#b98">[99]</ref> propose a compiling &amp; profiling system, called Sculptor, to improve the conventional loop perforation, which skips a static subset of iterations. More specifically, Sculptor dynamically skips a subset of the loop instructions (and not entire iterations) that do not affect the output accuracy. More recently, the authors of <ref type="bibr" target="#b14">[15]</ref> develop LEXACT, which is a tool for identifying non-critical code segments and monitoring the QoS of the program. LEXACT searches the loop perforation space, trying to find perforation configurations that satisfy pre-defined metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approx. Programming Languages</head><p>The loop perforation technique has been also used in approximation frameworks for heterogeneous multi-core systems combining various approximation mechanisms. Tan et al. <ref type="bibr" target="#b184">[185]</ref> propose a task scheduling algorithm that employs multiple approximate versions of the tasks with loops perforated. Kanduri et al. <ref type="bibr" target="#b79">[80]</ref> target applications whose main computations are continuously repeated and tune the loop perforation at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Computation Skipping.</head><p>This technique omits the execution of blocks of codes according to the acceptable QoS loss, programmer-defined constraints, and/or runtime predictions regarding the output accuracy <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b100">101,</ref><ref type="bibr" target="#b114">115,</ref><ref type="bibr" target="#b148">149,</ref><ref type="bibr" target="#b153">154,</ref><ref type="bibr" target="#b154">155,</ref><ref type="bibr" target="#b194">195,</ref><ref type="bibr" target="#b195">196]</ref>. Compared to loop perforation, these techniques do not focus only on skipping loop iterations, but also skip higher-level computations/tasks e.g., an entire convolution operation. Most of the state-of-the-art works perform application-specific computation skipping.</p><p>Meng et al. <ref type="bibr" target="#b114">[115]</ref> introduce a parallel template to develop approximate programs for iterativeconvergence recognition &amp; mining algorithms. The proposed programming template provides several strategies (implemented as libraries) for task dropping, such as convergence-based computation pruning, computation grouping in stages, and early termination of iterations. Another interesting work involving application-specific computation skipping is presented in <ref type="bibr" target="#b20">[21]</ref>. The authors of this work study the error tolerance of the supervised semantic indexing algorithm to make approximation decisions. Regarding their task dropping approach, they choose to omit the processing of common words (e.g., "the", "and") after the initial iterations, as these computations have negligible impact on the output accuracy.</p><p>The authors of <ref type="bibr" target="#b148">[149]</ref> propose two techniques to find computations with low impact on the QoS of the Reduce-and-Rank computation pattern, targeting to approximate or skip them completely. To identify these computations, the first technique uses intermediate reduction results and ranks, while the second one is based on the spatial or temporal correlation of the input data (e.g., adjacent image pixels or successive video frames). Similarly to the other state-of-the-art works, Vassiliadis et al. <ref type="bibr" target="#b194">[195,</ref><ref type="bibr" target="#b195">196]</ref> propose a programming environment that skips (or approximates) computations according to programmer-defined QoS constraints. More specifically, the programmer expresses the significance of the tasks using pragmas directives, optionally provides approximate variants of tasks, and specifies the desired task percentage to be executed accurately. Based on these constraints, the proposed system makes decisions at runtime regarding the approximation/skipping of the less significant tasks.</p><p>Rinard <ref type="bibr" target="#b153">[154]</ref> builds probabilistic distortion models based on linear regression to study the impact of computation skipping on the output accuracy. In particular, the programmer partitions the computations into tasks, which are then marked as "critical" or "skippable" through random skip executions. The probabilistic models estimate the output distortion as a function of the skip rates of the skippable tasks. This approach is also applied in parallel programs <ref type="bibr" target="#b154">[155]</ref>, where probabilistic distortion models are employed to tune the early phase termination at barrier synchronization points, targeting to keep all the parallel cores busy.</p><p>Significant research has been also conducted on skipping the computations of Convolutional Neural Networks (CNNs). Lin et al. <ref type="bibr" target="#b100">[101]</ref> introduce PredictiveNet to predict the sparse outputs of the nonlinear layers and skip a large subset of convolutions at runtime. The proposed technique, which does not require any modification in the original CNN structure, examines the most-significant part of the convolution to predict if the nonlinear layer output is zero, and then decides whether to skip the remaining least-significant part computations or not. In the same context, Akhlaghi et al. <ref type="bibr" target="#b5">[6]</ref> propose SnaPEA, exploiting the convolution-activation algorithmic chain in CNNs (activation takes as input the convolution result and outputs zero if the latter is negative). This technique early predicts negative convolution results based on static re-ordering of the weights and monitoring of the partial sums' sign bit, in order to skip the rest computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Memory Access Skipping.</head><p>Another approach to improve the execution time and energy consumption at the software level is the memory access skipping. Such techniques <ref type="bibr" target="#b81">[82,</ref><ref type="bibr" target="#b84">85,</ref><ref type="bibr" target="#b118">119,</ref><ref type="bibr" target="#b163">164,</ref><ref type="bibr" target="#b210">211,</ref><ref type="bibr" target="#b219">220]</ref> aim at avoiding high-latency memory operations, while they inherently reduce the number of computations.</p><p>Miguel et al. <ref type="bibr" target="#b118">[119]</ref> exploit the approximate data locality to skip the required memory accesses due to L1 cache miss. They employ a load value approximator, which learns value patterns using a global history buffer and an approximator table, to estimate the memory data values. RFVP <ref type="bibr" target="#b210">[211]</ref> uses value prediction instead of memory accessing. When selected load operations miss in the cache memory, RFVP predicts the requested vales without checking for misprediction or recovering the values. Thus, timing overheads from pipeline flushes and re-executions are avoided. Furthermore, a tunable rate of cache misses is dropped after the value prediction to eliminate long memory stalls. Similarly, the authors of <ref type="bibr" target="#b84">[85]</ref> propose a framework that skips costly last-level cache misses according to a programmer-defined error constraint and an heuristic predicting skipped data.</p><p>To improve the performance of CUDA kernels on GPUs, Samadi et al. <ref type="bibr" target="#b163">[164]</ref> propose a runtime approximation framework, called SAGE, which focuses on optimizing the memory operations among other functionalities. The approximations lie in skipping selective atomic operations (used by kernels to write shared variables) to avoid conflicts leading to performance decrease. Furthermore, SAGE reduces the number of memory accesses by packing the read-only input arrays, and thus, allowing to access more data with fewer requests. Karakoy et al. <ref type="bibr" target="#b81">[82]</ref> propose a slicing-based approach to identify data (memory) accesses that can be skipped to deliver energy/performance gains within an acceptable error bound. The proposed method applies backward and forward code slicing to estimate the gains from skipping each output data. Moreover, the '0' value is used for each data access that is not performed. The ApproxANN framework <ref type="bibr" target="#b219">[220]</ref>, besides performing approximate computations, skips memory accesses on neural networks according to the neuron criticality. More specifically, a theoretical analysis is adopted to study the impact of neurons on the output accuracy and characterize their criticality. The neuron approximation under a given QoS constraint is tuned by an iterative algorithm, which applies the approximations and updates the criticality of each neuron (it may change due to approximations in other neurons).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Approximate Memoization</head><p>The memoization technique stores results of previous calculations or pre-computed values in memory to use them instead of performing calculations. Namely, this memory functions as a look-up table that maps a set of data identifiers to a set of stored data. The current survey focuses on approximate memoization techniques <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b123">124,</ref><ref type="bibr" target="#b162">163,</ref><ref type="bibr" target="#b187">188]</ref> relying on software frameworks, compilers and programmer's decisions. Nevertheless, it is noted that that there are also approaches <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b109">110,</ref><ref type="bibr" target="#b149">150,</ref><ref type="bibr" target="#b217">218]</ref> requiring hardware modification to support memoization, as well as hardwarelevel look-up table approximation techniques (e.g., <ref type="bibr" target="#b147">[148]</ref>). The latter work proposes a quantized look-up table, called qLUT, which replaces complex arithmetic functions. The qLUT table contains precomputed output values corresponding to a small input set that has been created from the original input data using their probability distributions.</p><p>Chadhuri et al. <ref type="bibr" target="#b27">[28]</ref> propose an approximate memoization for computations in loops. Prior to executing an expensive function within a loop, this technique checks a look-up table to find if this computation was previously performed for similar input data. In this case, the cached result is used, otherwise, the function is executed and the new computation is stored in the look-up table. Paraprox <ref type="bibr" target="#b162">[163]</ref> is a software framework for identifying common patterns in data-parallel programs and applying tailored approximations to them. For the Map &amp; Scatter/Gather patterns, Paraprox uses memoization rather than performing computations. In particular, it fills a look-up table with pre-computed data, which are obtained from the execution of the Map &amp; Scatter/Gather function for some representative inputs, and performs runtime look-up table queries instead of the conventional computations.</p><p>iACT <ref type="bibr" target="#b123">[124]</ref> is another approximation framework that applies runtime memoization among other functionalities. The programmer uses pragmas to declare the functions for memoization and specify the error tolerance percentage. For each function call-site, the framework creates a global table to store pairs of function arguments and output results. In case the function arguments are already stored in the table (within an error bound), the corresponding output results are returned. Otherwise, the function is accurately executed and the new input-output pairs are stored in the table. The ATM approach <ref type="bibr" target="#b18">[19]</ref> performs runtime task memoization, relying on hashing functions to store the task inputs and an adaptive algorithm to automatically decide whether to use memoization or execute the task. The programmer needs to use pragmas to specify the tasks that are suitable for memoization. The authors of <ref type="bibr" target="#b82">[83]</ref> introduce an approximate memoization mechanism for GPU fragment shading operations, which reduces the precision of the input parameters and performs partial matches. To identify approximate memoization opportunities, they characterize various fragment shader instructions in terms of memoization hits and output accuracy. Moreover, runtime policies are proposed to tune the precision according to the errors introduced.</p><p>Contrary to the aforementioned techniques, TAF-Memo <ref type="bibr" target="#b187">[188]</ref> is an output-based function memoization technique, i.e., it memoizes function calls based on their output history. TAF-Memo checks for temporal locality by calculating the relative arithmetic difference of two consecutive output values from the same function call-site. In case this difference is below the acceptable error constraint, memoization is applied by returning the last computed output for the following function calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Relaxed Synchronization</head><p>The execution of parallel applications on multi/many-core systems requires time-consuming synchronization to either access shared data or satisfy data dependencies. Various techniques <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b115">116,</ref><ref type="bibr" target="#b120">121,</ref><ref type="bibr" target="#b122">123,</ref><ref type="bibr" target="#b152">153,</ref><ref type="bibr" target="#b155">156,</ref><ref type="bibr" target="#b180">181,</ref><ref type="bibr" target="#b182">183]</ref> have been proposed to relax the conventional synchronization requirements that guarantee error-free execution, delivering speedup in exchange for QoS loss.</p><p>The authors of <ref type="bibr" target="#b152">[153]</ref> propose the RaC methodology to systematically relax synchronization, while always satisfying a programmer-defined QoS constraint. Initially, the programmer specifies the parallel code segments, and then applies the four-step RaC methodology. This methodology identifies criteria for quantifying the acceptable QoS, selects the relaxation points, modifies the code to enable the execution of both the original and relaxed versions, and selects the suitable relaxation degree (i.e., which instances to relax for each synchronization point). Misailovic et al. <ref type="bibr" target="#b122">[123]</ref> propose the Dubstep system, which relaxes the synchronization of parallelized programs based on a "findtransform-navigate" approach. More specifically, Dubstep performs a profiling-based analysis of the original program to find possible optimizations, inserts opportunistic synchronization and barriers, and finally, performs an exploration including accuracy, performance and safety analysis for the transformed program.</p><p>QuickStep <ref type="bibr" target="#b120">[121]</ref> is a system for approximately parallelizing sequential programs, i.e., without preserving the semantics of the original program, within statistical accuracy bounds. Among other transformations, QuickStep replicates shared objects to eliminate the bottlenecks of synchronized operations on them. HELIX-UP <ref type="bibr" target="#b21">[22]</ref> is another parallelizing compiler that selectively relaxes strict adherence to program semantics to tackle runtime performance bottlenecks, involving profiling and user interaction to tune QoS. The compiler also offers a synchronization-relaxing knob to decrease the inter-core communication overhead by synchronizing sequential segments with prior iterations. More recently, the authors of <ref type="bibr" target="#b182">[183]</ref> introduce PANDORA, which is an approximate parallelizing framework based on symbolic regression machine learning and sampled outputs of the original function. To avoid timing bottlenecks, such as data movement and synchronization, and improve parallelism, PANDORA eliminates loop-carried dependencies using fitness functions and constraints regarding error and performance. In <ref type="bibr" target="#b180">[181]</ref>, the authors exploit the concept of approximate shared value locality to reduce synchronization conflicts in programs using optimistic synchronization. The reduction of conflicts on approximately local variables, detected for a given similarity constraint, is achieved through an arbitration mechanism that imprecisely shares the values between threads. The authors of <ref type="bibr" target="#b115">[116]</ref> apply aggressive coarse-grained parallelism on recognition &amp; mining algorithms by relaxing or even ignoring data dependencies between different iterations. As a result, the timing overheads are reduced in comparison with the conventional parallel implementation, which also applies parallelization only within the iteration (iterations are executed serially). Rinard <ref type="bibr" target="#b155">[156]</ref> introduces synchronization-free updates to shared data structures by eliminating the conventional use of mutual exclusion and dropping array elements at the worst scenario. Moreover, the same work applies relaxed barrier synchronization, allowing the threads to pass the barrier without stalling to wait for the other threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Precision Scaling</head><p>Precision scaling (tuning) refers to the discipline reduction of the numerical precision, resulting in improved processing speed and/or memory bandwidth <ref type="bibr" target="#b34">[35]</ref>. The state-of-the-art software-level works <ref type="bibr">[20, 36, 37, 44, 45, 57, 81, 88-90, 102, 117, 158, 159, 171, 186, 213]</ref> address several challenges, such as the scaling degree, scaling automation, mixed precision, and dynamic scaling.</p><p>Starting with works based on formal methods to reduce the precision and examine the errors, the Gappa tool <ref type="bibr" target="#b44">[45]</ref> automates the study of rounding errors in elementary functions and floatingpoint calculations using interval arithmetic. An extended version of this tool is Gappa++ <ref type="bibr" target="#b101">[102]</ref>, which provides automated analysis of numerical errors in a wide range of computations, i.e., fixedpoint, floating-point, linear and non-linear. This tool integrates several features, such as operation rewriting to facilitate the isolation of rounding errors, and affine arithmetic to accurately bound linear calculations with correlated errors. FPTuner <ref type="bibr" target="#b35">[36]</ref> is a tool that performs formal error analysis based on symbolic Taylor expansions and quadratically constrained quadratic programming. It searches for precision allocations that satisfy constraints such as the number of operators at a given precision and the number of type casts. Rosa <ref type="bibr" target="#b43">[44]</ref> is a source-to-source compiler that combines satisfiability modulo theories with interval arithmetic to bound the round-off errors of the fixedand floating-point formats.</p><p>Several works of the literature employ heuristics and automated search to scale the precision of floating-point programs. Precimonious <ref type="bibr" target="#b158">[159]</ref> searches all the program variables in their order of declaration using the delta-debugging algorithm, and lowers their precision according to an error constraint specified by the programmer. In the same context, HiFPTuner <ref type="bibr" target="#b56">[57]</ref> firstly groups dependent variables that may require the same precision, and then performs a customized hierarchical search. Lam et al. <ref type="bibr" target="#b89">[90]</ref> introduce a framework that employs the breadth-first search algorithm to identify code regions that can tolerate lower precision. Similarly to this technique, CRAFT <ref type="bibr" target="#b88">[89]</ref> performs binary searches to initially determine the required program precision, and then truncate the results of some of the floating-point instructions. Towards the detection of large floating-point errors, the authors of <ref type="bibr" target="#b36">[37]</ref> propose S 3 FP. This tool is based on an heuristic-guided search to find the inputs causing the largest errors. The Blame Analysis <ref type="bibr" target="#b157">[158]</ref> combines concrete and shadow execution to generate a blame set for the program instructions, which contains the minimum precision requirements under a giver error constraint. This approach can be also used in cooperation with the previous search-based works, and specifically, as pre-processing to reduce the search space. Schkufza et al. <ref type="bibr" target="#b170">[171]</ref> treat the scaling of floating-point precision as a stochastic search problem. In particular, they repeatedly apply random program transformations and use a robust search to guarantee the maximum errors.</p><p>The concept of dynamic precision scaling, i.e., the tuning of the precision at runtime with respect to the input data and error sensitivity, has been studied in <ref type="bibr" target="#b212">[213]</ref>. The dynamic scaling framework of this work integrates an offline application profiler, a runtime monitor to track workload changes, and an accuracy controller to adjust the precision accordingly. ApproxMA <ref type="bibr" target="#b185">[186]</ref> dynamically scales the precision of data memory accesses in algorithms such as mixture model-based clustering. This framework integrates a runtime precision controller, which generates custom bit-widths according to the QoS constraints, and a memory access controller, which loads the scaled data from memory. The custom bit-widths are generated by analyzing a subset of data and intermediate results and calculating metrics regarding the error appearance and the number of tolerable errors.</p><p>Mixed floating-point precision has been also studied in high-performance computing workloads. ADAPT <ref type="bibr" target="#b116">[117]</ref> uses algorithmic differentiation, i.e., a technique for numerically evaluating the derivative of a function corresponding to the program, to estimate the output error of high-performance computing workloads. It provides a precision sensitivity profile to guide the development of mixedprecision programs. In the same context, the authors of <ref type="bibr" target="#b19">[20]</ref> propose an instruction-based search that explores information about the dynamic program behaviour and the temporal locality.</p><p>To enable mixed floating-point precision in GPUs, the authors of <ref type="bibr" target="#b87">[88]</ref> propose the GPUMixer tool, which relies on static analysis to find code regions where precision scaling improves the performance. Next, GPUmixer performs a dynamic analysis involving shadow computations to examine if the scaled program configurations satisfy the accuracy constraints. In the same context, PreScaler <ref type="bibr" target="#b80">[81]</ref> is an automatic framework that generates precision-scaled OpenCL programs, considering both kernel execution and data transfer. Initially, it employs a system inspector to collect information about precision scaling on the target platform, and an application profiler to identify memory objects with floating-point elements for potential scaling. This information is exploited by a decision maker that finds the best scaling configuration using decision tree search on a minimized space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Data Sampling</head><p>Approximate Computing is also exploited in big data analysis, in an effort to reduce the increased number of computations and storage requirements due to the large amount of input data. The key idea is to perform computations on a representative data sample rather than on the entire input dataset. Therefore, various data sampling methods <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b63">64,</ref><ref type="bibr" target="#b78">79,</ref><ref type="bibr" target="#b85">86,</ref><ref type="bibr" target="#b90">91,</ref><ref type="bibr" target="#b138">139,</ref><ref type="bibr" target="#b143">144,</ref><ref type="bibr" target="#b144">145,</ref><ref type="bibr" target="#b205">206,</ref><ref type="bibr" target="#b220">221]</ref> are examined to provide real-time processing with error bounds in applications involving stream analytics, database search, and model training.</p><p>EARL <ref type="bibr" target="#b90">[91]</ref> is an extension of Hadoop (i.e., a software framework that provides distributed storage and big data processing on clusters), which delivers early results with reliable error bounds. It applies statistics-based uniform sampling from distributed files. Goiri et al. <ref type="bibr" target="#b54">[55]</ref> propose the ApproxHadoop framework to generate approximate MapReduce programs based on task dropping and multi-stage input sampling. They also bound the errors using statistical theories. The programmer tunes the approximation by specifying either the desired error bound or the task dropping and input sampling ratios. Similarly, ApproxSpark <ref type="bibr" target="#b63">[64]</ref> performs sampling at multiple arbitrary points of long chains of transformations to facilitate the aggregation of huge amounts of data. This framework models the clustering information of transformations as a data provenance tree, and then computes the approximate aggregate values as well as error thresholds. Moreover, the sampling rates are dynamically selected according to programmer-specified error thresholds.</p><p>Sampling methods have been also examined in stream analytics. StreamApprox <ref type="bibr" target="#b144">[145]</ref> is an approximate stream analytics system that supports both batched and pipelined stream processing. It employs two sampling techniques, i.e., stratified and reservoir sampling, to approximate the outputs with rigorous error bounds. IncApprox <ref type="bibr" target="#b85">[86]</ref> combines approximate and incremental computations to provide stream analytics with bounded error. This system executes a stratified sampling algorithm that selects data for which the results have been memoized from previous runs, and adjusts the computations to produce an incrementally updated output. On the other hand, PrivApprox <ref type="bibr" target="#b143">[144]</ref> combines sampling and randomized response to provide both approximate computations and privacy guarantee. This system integrates a query execution interface that enables the systematic exploration of the trade-off between accuracy and query budget. ApproxIoT <ref type="bibr" target="#b205">[206]</ref> facilitates approximate stream analytics at the edge by combining stratified reservoir sampling and hierarchical processing.</p><p>A variety of sampling methods have been employed in approximate query processing systems for databases. BlinkDB <ref type="bibr" target="#b2">[3]</ref> performs approximate distributed query processing, supporting SQLbased aggregation queries with time and error constraints. It creates stratified samples based on past queries, and uses an heuristic-based profiler to dynamically select the sample that meets the query's constraints. Another system applying approximate big-data queries is Quickr <ref type="bibr" target="#b78">[79]</ref>, which integrates operators sampling multiple join inputs into a query optimizer, and then searches for an appropriate sampled query plan. Sapprox <ref type="bibr" target="#b220">[221]</ref> is a distribution-aware system that employs the occurrences of sub-datasets to drive the online sampling. In particular, the exponential number of sub-datasets is reduced to a linear one using a probabilistic map, and then, cluster sampling with unequal probability theory is applied for sub-dataset sampling. Sapprox also determines the optimal sampling unit size in relation with approximation costs and accuracy.</p><p>Numerous works of the literature use data sampling to decrease the increased computational cost of model training in machine learning applications. Zombie <ref type="bibr" target="#b8">[9]</ref> is a two-stage system that trains approximate models based on clustering and active learning. The first stage applies offline indexing to organize the dataset into index groups of similar elements. Subsequently, the stage of online querying uses the index groups that are likely to output useful features to creates the training subset of data. BlinkML <ref type="bibr" target="#b138">[139]</ref> approximately trains a model on a small sample, while providing accuracy guarantees. The sample is obtained through uniform random sampling, however, in case of very large datasets, a memory-efficient algorithm is employed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Approximate Programming Languages</head><p>The high-level approximation of software programs has been examined through approximate programming languages, i.e., language extensions that allow the programmer to systematically declare approximate code regions, variables, loops, and functions, insert randomness in the program, and/or specify error constraints. The literature involves numerous works <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b75">76,</ref><ref type="bibr" target="#b104">105,</ref><ref type="bibr" target="#b113">114,</ref><ref type="bibr" target="#b119">120,</ref><ref type="bibr" target="#b136">137,</ref><ref type="bibr" target="#b137">138,</ref><ref type="bibr" target="#b166">167,</ref><ref type="bibr" target="#b167">168,</ref><ref type="bibr" target="#b179">180,</ref><ref type="bibr" target="#b186">187]</ref> that enable approximate procedural, object-oriented, and probabilistic programming.</p><p>Ansel et al. <ref type="bibr" target="#b10">[11]</ref> introduce a set of PetaBricks language extensions that allow the programmer to write code of variable accuracy. These extensions expose the performance-accuracy trade-off to the compiler, which automatically searches the algorithmic space to tune the program according to the programmer's accuracy constraints. Eon <ref type="bibr" target="#b179">[180]</ref> is a programming language that allows the programmer to annotate program flows (paths) with different energy states. The Eon runtime system predicts the workload and energy of the system, and then adjusts the execution of flows according to the programmer's declarations and the energy constraints. In the same context, Baek and Chilimbi <ref type="bibr" target="#b13">[14]</ref> propose Green, which is a two-phase programming framework providing language extensions to approximate expensive functions and loops. The programmer uses pragma-like annotations to specify approximate variants of functions. In the calibration phase, Green builds a model to quantify the QoS loss and the performance/energy gains. This model is then used in the operational phase to generate an approximate program satisfying the programmer's QoS constraint. DECAF <ref type="bibr" target="#b17">[18]</ref> is a type-based approximate programming language that allows the programmer to specify the correctness probability for some of the program variables. The DECAF type system also integrates solver-aided type inference to automatically tune the type of the rest variables, code specialization, and dynamic typing. Flikker <ref type="bibr" target="#b104">[105]</ref> provides language annotations to mark the program variables and partition the data into critical and non-critical regions (the latter are stored in unreliable memories). Topaz <ref type="bibr" target="#b0">[1]</ref> is a task-based language that maps tasks onto approximate hardware and uses an outlier detector to find and re-execute the computations producing unacceptable results.</p><p>In <ref type="bibr" target="#b22">[23]</ref>, the authors introduce language constructs for generating approximate programs and proof rules for verifying the acceptability properties. Rely <ref type="bibr" target="#b23">[24]</ref> is an imperative language that allows the programmer to introduce quantitative reliability specifications for generating programs with data stored in approximate memory and inexact arithmetic/logical operations. Chisel <ref type="bibr" target="#b119">[120]</ref> automates the selection of Rely's approximations while satisfying the programmer-defined reliability and accuracy constraints. To solve this optimization problem, Chisel employs an integer programming solver. All these works include safety analysis and program verification for sequential programs. In contrast, Parallely <ref type="bibr" target="#b49">[50]</ref> is a programming language for approximating parallel programs through canonical sequentialization, i.e., a verification method that generates sequential programs capturing the semantics of parallel programs.</p><p>Targeting approximations in Java programs, the authors of <ref type="bibr" target="#b166">[167]</ref> propose EnerJ, i.e., a language extension providing type qualifiers to specify data that can be approximately stored or computed. EnerJ guarantees isolation of the approximate computations. FlexJava <ref type="bibr" target="#b136">[137]</ref> offers another set of language extensions to annotate approximate programs. Using an approximation safety analysis, FlexJava automates the approximation of data and operations while ensuring safety guarantees. ExpAX <ref type="bibr" target="#b137">[138]</ref> allows the programmer to explicitly specify error expectations for a subset of Java. Based on an approximation safety analysis, it identifies operations that are candidate for approximation, and then, a heuristic-based framework approximates those that statistically satisfy the error expectations.</p><p>Significant research has also been conducted on probabilistic programming languages. Church <ref type="bibr" target="#b55">[56]</ref> is a probabilistic language that inserts randomness on a deterministic function subset using stochastic functions. The Church semantics are defined in terms of evaluation histories and conditional distributions on the latter. Similarly, Venture <ref type="bibr" target="#b113">[114]</ref> is another language that enables the specification of probabilistic models and inference problems. The Anglican <ref type="bibr" target="#b186">[187]</ref> language and runtime system provides probabilistic evaluation model and functional representations, e.g., distributions and sequences of random variables.</p><p>Uncertain&lt;T&gt; <ref type="bibr" target="#b16">[17]</ref> is a language abstraction that manipulates data as probability distributions. More specifically, random variables are declared as "uncertain" and a Bayesian network for representing computations is build, where nodes correspond to the variables and edges correspond to conditional variable dependencies. The Uncertain&lt;T&gt; runtime system performs hypothesis tests and sampling to evaluate the network. In the same context, Sampson et al. <ref type="bibr" target="#b167">[168]</ref> use probabilistic assertions on random variables. Their tool, called MayHap, performs probabilistic evaluation by statically building a Bayesian representation network based on the input distribution and dynamically interpreting it via sampling. In the same context, AxProf <ref type="bibr" target="#b75">[76]</ref> is a profiling-based framework for analyzing randomized approximate programs. The programmer specifies probabilistic predicates for the output, i.e., regarding the expectation of the output value and/or the probability that the output satisfies a condition, and AxProf generates approximate programs based on statistical tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">HARDWARE APPROXIMATION TECHNIQUES</head><p>This section classifies and introduces the hardware approximation techniques, which are applied at the lower level of the design abstraction hierarchy. These techniques aim to improve the area, power consumption, and performance of the circuits i.e., the basic building blocks of accelerators, processors, and computing platforms. The hardware approximation techniques can be categorized into three classes: (i) Circuit Functional Approximation (CFA), (ii) Voltage Over-Scaling (VOS), and (iii) Over-Clocking (OC). In approximate hardware, two types of errors are distinguished: the functional errors (produced by CFA) and the timing errors (produced by VOS and OC). Fig. <ref type="figure" target="#fig_1">4</ref> illustrates the hardware approximation techniques, including a further taxonomy to sub-classes. Table 4. Classification of hardware approximation techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HW Approximation Class Technique/Approach</head><p>Adder Approximation Use of Approximate Full Adder Cells <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b139">140,</ref><ref type="bibr" target="#b208">209]</ref> Segmentation and Carry Prediction <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b76">77,</ref><ref type="bibr" target="#b83">84,</ref><ref type="bibr" target="#b173">174,</ref><ref type="bibr" target="#b207">208,</ref><ref type="bibr" target="#b211">212]</ref> Multiplier Approximation</p><p>Truncation and Rounding <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b92">93,</ref><ref type="bibr" target="#b94">95,</ref><ref type="bibr" target="#b97">98,</ref><ref type="bibr" target="#b189">190,</ref><ref type="bibr" target="#b213">214]</ref> Approximate Radix Encodings <ref type="bibr" target="#b68">[69,</ref><ref type="bibr" target="#b96">97,</ref><ref type="bibr" target="#b106">107,</ref><ref type="bibr" target="#b196">197,</ref><ref type="bibr" target="#b203">204,</ref><ref type="bibr" target="#b204">205,</ref><ref type="bibr" target="#b221">222]</ref> Use of Approximate Compressors <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b128">129,</ref><ref type="bibr" target="#b161">162,</ref><ref type="bibr" target="#b183">184]</ref> Logarithmic Approximation <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b107">108,</ref><ref type="bibr" target="#b141">142,</ref><ref type="bibr" target="#b159">160]</ref> Divider Approximation Bit-width Scaling <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b69">70]</ref> Use of Approximate Adder/Subtractor Cells <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b33">34]</ref> Simplification of Computations <ref type="bibr" target="#b65">[66,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b160">161,</ref><ref type="bibr" target="#b190">191,</ref><ref type="bibr" target="#b214">215]</ref> Approximate Synthesis</p><p>Structural Netlist Transformation <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b102">103,</ref><ref type="bibr" target="#b169">170,</ref><ref type="bibr" target="#b199">200]</ref> Boolean Rewriting <ref type="bibr" target="#b61">[62,</ref><ref type="bibr" target="#b117">118,</ref><ref type="bibr" target="#b151">152,</ref><ref type="bibr" target="#b200">201]</ref> High-Level Approximate Description <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b91">92,</ref><ref type="bibr" target="#b132">133,</ref><ref type="bibr" target="#b133">134,</ref><ref type="bibr" target="#b209">210]</ref> Evolutionary Synthesis <ref type="bibr" target="#b131">[132,</ref><ref type="bibr" target="#b172">173,</ref><ref type="bibr" target="#b191">[192]</ref><ref type="bibr" target="#b192">[193]</ref><ref type="bibr" target="#b193">[194]</ref> Voltage Over-Scaling Slack Re-distribution <ref type="bibr" target="#b77">[78]</ref> Circuit Re-design and Architecture Modification <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b127">128,</ref><ref type="bibr" target="#b218">219]</ref> Fine-Grained Scaling <ref type="bibr" target="#b135">[136,</ref><ref type="bibr" target="#b201">202,</ref><ref type="bibr" target="#b216">217]</ref> Error Modeling <ref type="bibr" target="#b67">[68,</ref><ref type="bibr" target="#b73">74,</ref><ref type="bibr" target="#b108">109,</ref><ref type="bibr" target="#b145">146,</ref><ref type="bibr" target="#b215">216]</ref> Over-Clocking Tight Synthesis <ref type="bibr" target="#b6">[7]</ref> Circuit Re-design and Architecture Modification <ref type="bibr" target="#b150">[151,</ref><ref type="bibr" target="#b176">177,</ref><ref type="bibr" target="#b202">203]</ref> Error Detection &amp; Correction <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b99">100,</ref><ref type="bibr" target="#b146">147]</ref> Error Prediction <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b71">72,</ref><ref type="bibr" target="#b72">73,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b111">112,</ref><ref type="bibr" target="#b156">157]</ref> The remainder of this section presents state-of-the-art works, organized according to the proposed classification of Table <ref type="table">4</ref>. It is noted that, even though some works may belong to more than one sub-class, they are assigned to their prevalent one and their relevant features are highlighted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Circuit Functional Approximation</head><p>Circuit functional approximation modifies the original accurate design by reducing its circuit complexity at logic level. Typical CFA approaches include: (i) the modification of the circuit's truth table, (ii) the use of an approximate version of the initial hardware algorithm, (iii) the use of small inexact components as building blocks, and (iv) approximate circuit synthesis. The main target of CFA is the arithmetic circuits <ref type="bibr" target="#b70">[71]</ref>, as they constitute the key processing units of processors and accelerators, and thus, they inherently affect their power efficiency and performance. The literature provides several open-source libraries of approximate arithmetic circuits, such as ApproxAdderLib <ref type="bibr" target="#b173">[174]</ref>, EvoApprox8b <ref type="bibr" target="#b131">[132]</ref> and SMApproxLib <ref type="bibr" target="#b188">[189]</ref>. This survey focuses on approximate adders, multipliers, and dividers. However, it is noted that that numerous works design and evaluate other approximate arithmetic operations, such as circuits for Multiplication-and-Accumulation (MAC) <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b53">54]</ref>, square root <ref type="bibr" target="#b69">[70]</ref>, squaring <ref type="bibr" target="#b112">[113]</ref>, square-accumulate <ref type="bibr" target="#b52">[53]</ref>, and Coordinate Rotation Digital Computer (CORDIC) <ref type="bibr" target="#b32">[33]</ref>. The literature also includes automated methods for generating approximate circuits, which are presented in the context of approximate logic synthesis. Moreover, there are works applying functional approximations based on the inputs such as <ref type="bibr" target="#b110">[111]</ref>, where the authors configure and assign different approximation operators for a given data flow program based on the input workload. It is also important to mention that methodologies for digital hardware design based on approximate arithmetic circuits and formats have been proposed <ref type="bibr" target="#b95">[96]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Approximate Adders.</head><p>Significant research has been conducted on the design of approximate area-and power-efficient adders. The approximation techniques for inexact adders involve: (i) use of approximate full adder cells <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b139">140,</ref><ref type="bibr" target="#b208">209]</ref> and (ii) segmentation and carry prediction <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b76">77,</ref><ref type="bibr" target="#b83">84,</ref><ref type="bibr" target="#b173">174,</ref><ref type="bibr" target="#b207">208,</ref><ref type="bibr" target="#b211">212]</ref>. Next, representative state-of-the-art works for approximate adders are presented.</p><p>The IMPACT adders are based on inexact full adders cells, which are approximated at the transistor level to deliver up to 45% area reduction <ref type="bibr" target="#b57">[58]</ref>. Another transistor-level cell approximation is proposed in <ref type="bibr" target="#b208">[209]</ref>, where the AXA 4-transistor XOR/XNOR-based adders are implemented, delivering up to 31% gain in dynamic power consumption. Moreover, in <ref type="bibr" target="#b139">[140]</ref>, approximate reverse carry propagate full adders are used to build the hybrid RCPA adders. Targeting higher level approximations, the OLOCA adder splits the addition into accurate and approximate segments <ref type="bibr" target="#b41">[42]</ref>, and for the latter, it employs OR gates for the most-significant bit additions and outputs constant '1' for the least-significant ones.</p><p>To reduce the worst-case carry propagation delay, Kim et al. <ref type="bibr" target="#b83">[84]</ref> propose a carry prediction scheme leveraging the less-significant input bits, which is 2.4× faster than the conventional ripplecarry adder. Similarly, Hu et al. <ref type="bibr" target="#b64">[65]</ref> introduce a carry speculating method to segment the carry chain in their design, which also performs error and sign correction. Compared to the accurate adder, the proposed design is 4.3× faster and saves 47% power.</p><p>The quality constraint of applications may vary during runtime, thus, research efforts have also focused on designing dynamically configurable adders that can tune their accuracy. In <ref type="bibr" target="#b76">[77]</ref>, the authors propose an accuracy-configurable adder, called ACA, which consists of several subadders and an error detection &amp; correction module. The accuracy is controlled at runtime, while operation in accurate mode is also supported. Another dynamically configurable adder, called GDA, is proposed in <ref type="bibr" target="#b211">[212]</ref>, where multiplexers select the carry input either from the previous sub-adder or the carry prediction unit, providing a more graceful accuracy degradation. In the same direction, the GeAr adder <ref type="bibr" target="#b173">[174]</ref> employs multiple sub-adders of equal length to variable approximation modes. This architecture supports accurate mode via a configurable error correction unit.</p><p>Akbari et al. <ref type="bibr" target="#b4">[5]</ref> introduce the RAP-CLA adder, which splits the conventional carry look-ahead scheme into two segments, i.e., the approximate part and the augmenting part, supporting approximate and accurate mode. When operating at the approximate mode, the augmenting part is power-gated to reduce power consumption. Another carry-prediction-based approach supporting both modes is the SARA design <ref type="bibr" target="#b207">[208]</ref>. This adder uses carry ripple sub-adders, and the carry prediction does not require a dedicated circuitry. Finally, the BSCA adder, which is based on a block-based carry speculative approach <ref type="bibr" target="#b46">[47]</ref>, integrates an error recovery unit and non-overlapped blocks consisting of a sub-adder, a carry prediction unit, and a selection unit.</p><p>5.1.2 Approximate Multipliers. The multiplication circuits have attracted significant interest from the research community. The literature includes a plethora of inexact multipliers that can be categorized according to the prevailing approximation techniques: (i) truncation and rounding <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b92">93,</ref><ref type="bibr" target="#b94">95,</ref><ref type="bibr" target="#b97">98,</ref><ref type="bibr" target="#b189">190,</ref><ref type="bibr" target="#b213">214]</ref>, (ii) approximate radix encodings <ref type="bibr" target="#b68">[69,</ref><ref type="bibr" target="#b96">97,</ref><ref type="bibr" target="#b106">107,</ref><ref type="bibr" target="#b196">197,</ref><ref type="bibr" target="#b203">204,</ref><ref type="bibr" target="#b204">205,</ref><ref type="bibr" target="#b221">222]</ref>, (iii) use of approximate compressors <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b128">129,</ref><ref type="bibr" target="#b161">162,</ref><ref type="bibr" target="#b183">184]</ref>, and (iv) logarithmic approximation <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b107">108,</ref><ref type="bibr" target="#b141">142,</ref><ref type="bibr" target="#b159">160]</ref>. Subsequently, the state-of-the-art works from each category are introduced.</p><p>Starting with the rounding and truncation techniques, the DRUM multiplier <ref type="bibr" target="#b59">[60]</ref> dynamically reduces the input bit-width, based on the leading '1' bits, to achieve 60% power gain in exchange for mean relative error of 1.47%. Zendegani et al. propose the RoBa multiplier <ref type="bibr" target="#b213">[214]</ref>, which rounds the operands to the nearest exponent-of-two and performs a shift-based multiplication in segments. In <ref type="bibr" target="#b97">[98]</ref>, the PR approximate multiplier perforates partial products and applies rounding to the remaining ones, delivering up to 69% energy gains. The same approximation technique is integrated in the mantissa multiplication of floating-point numbers to create the AFMU multiplier <ref type="bibr" target="#b94">[95]</ref>. Vahdat et al. propose the TOSAM multiplier <ref type="bibr" target="#b189">[190]</ref> that truncates the input operands according to their leading '1' bit. To decrease the error, the truncated values are rounded to the nearest odd number. In <ref type="bibr" target="#b92">[93]</ref>, different rounding, perforation and encoding schemes are combined to extract the most energy-efficient multiplication circuits. Finally, Frustaci et al. <ref type="bibr" target="#b50">[51]</ref> implement an alternative dynamic truncation with correction, along with an efficient mapping for the remaining partial product bits.</p><p>Next, multipliers that generate their partial products based on approximate radix encodings are presented. Liu et al. <ref type="bibr" target="#b106">[107]</ref> modify the Karnaugh map of the radix-4 encoding to create approximate encoders for generating the least-significant partial product bits. A similar approach is followed in <ref type="bibr" target="#b196">[197]</ref>, where approximate radix-4 partial product generators are designed. Jiang et al. <ref type="bibr" target="#b68">[69]</ref> use an approximate adder to generate the ±3× multiplicand term in the radix-8 multiplier. In <ref type="bibr" target="#b203">[204]</ref>, the authors propose a hybrid low-radix encoding that encodes the most-significant bits with the accurate radix-4 encoding and the least-significant bits with the an approximate radix-8 encoding. A similar approach is used in <ref type="bibr" target="#b204">[205]</ref>, where the authors propose approximate radix-8 multipliers for FPGA-based design. Targeting to high-order radix, the authors of <ref type="bibr" target="#b96">[97]</ref> propose the hybrid high-radix encoding, which applies both the accurate radix-4 and approximate radix-2 𝑘 encodings. Correspondingly, in <ref type="bibr" target="#b221">[222]</ref>, a radix-256 encoder is proposed for approximate multiplication circuits.</p><p>Several works employ approximate compressors for the partial product accumulation. Momeni et al. <ref type="bibr" target="#b128">[129]</ref> modify the truth table of the accurate 4:2 compressor to create two simplified designs and use them in the Dadda multiplier. The authors in <ref type="bibr" target="#b3">[4]</ref> design 4:2 compressors, again for Dadda multipliers, which can switch between accurate and approximate mode at runtime, consuming 68% lower power. In <ref type="bibr" target="#b161">[162]</ref>, an approximate 4:2 compressor is implemented in FinFET based on a three-input majority gate, and then it is used in the Dadda architecture along truncation. Esposito et al. <ref type="bibr" target="#b48">[49]</ref> introduce a new family of approximate compressors and assign them to each column of the partial product matrix according to their allocation algorithm. Another interesting work is the design of approximate compressors for multipliers using the stacking circuit concept <ref type="bibr" target="#b183">[184]</ref>.</p><p>Regarding the approximate logarithmic multipliers, Liu et al. <ref type="bibr" target="#b107">[108]</ref> employ a truncated binarylogarithm converter and inexact adders for the mantissa addition to design the ALM family of multipliers. The logarithmic-based REALM multiplier <ref type="bibr" target="#b159">[160]</ref> partitions the power-of-two intervals of the input operands into segments, and determines an error compensation factor for each one. The ILM multiplier <ref type="bibr" target="#b9">[10]</ref> differentiates from the conventional design, as it rounds the input operands to their nearest power-of-two using a nearest '1' bit detector. Pilipovic et al. <ref type="bibr" target="#b141">[142]</ref> propose a two-stage trimming logarithmic multiplier, which firstly, reduces the bit-width of the input operands, and then, the bit-width of the mantissas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Approximate Dividers.</head><p>The division circuits have received less attention than adders and multipliers. Nevertheless, the literature provides numerous works aiming to reduce the large critical paths of the conventional dividers. The approximation techniques for division circuits can be categorized as follows: (i) bit-width scaling <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b69">70]</ref>, (ii) use of approximate adder/subtractor cells <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b33">34]</ref>, and (iii) simplification of computations <ref type="bibr" target="#b65">[66,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b160">161,</ref><ref type="bibr" target="#b190">191,</ref><ref type="bibr" target="#b214">215]</ref>.</p><p>The first class of approximation techniques uses exact dividers with reduced bit-width. The approximate divider of <ref type="bibr" target="#b60">[61]</ref> dynamically selects the most relevant bits from the input operands and performs accurate division at lower bit-width, providing up to 70% power gains in exchange for 3% average error. The design makes use of leading '1' bit detectors, priority encoders, multiplexers, subtractor and barrel shifter. Similarly, the AAXD divider of <ref type="bibr" target="#b69">[70]</ref> detects the leading '1' bits and uses a pruning scheme to extract the bits that will be given as input to the divider. Additionally, the design integrates an error correction unit to form the final output.</p><p>Regarding the second class of approximation techniques, Chen et al. <ref type="bibr" target="#b30">[31]</ref> perform the subtraction of the non-restoring array divider with inexact subtractor circuits employing pass transistor logic. For their divider, called AXDnr, the authors examine different schemes regarding which subtractions of the division array to approximate. Similarly, in the AXDr divider of <ref type="bibr" target="#b31">[32]</ref>, some of the subtractions of the restoring array divider are performed with inexact subtractor circuits. The use of inexact cells has also been examined in the high-radix SRT divider <ref type="bibr" target="#b33">[34]</ref>. In this divider, called HR-AXD, the inexact cell is a signed-digit adder that is employed according to different replacement schemes, along with cell truncation and error compensation. Adams et al. <ref type="bibr" target="#b1">[2]</ref> introduce two approximate division architectures, called AXRD-M1 and AXRD-M2, which deliver up to 46% area and 57% power gains, respectively, compared to the exact restoring divider. The first design replaces some of the restoring divider cells with inexact ones of simplified logic, while the second one involves the elimination of some rows of the divider.</p><p>Targeting to perform the division with alternative simplified computations, the SEERAD divider <ref type="bibr" target="#b214">[215]</ref> rounds the divisor to a specific form based on the leading '1' bit position, and thus, the division is transformed to shift-&amp;-add multiplication. In the same context, Vahdat et al. <ref type="bibr" target="#b190">[191]</ref> propose the TruncApp divider that multiplies the truncated dividend with the approximate inverse divisor. Targeting to model the division operation, the CADE divider of <ref type="bibr" target="#b65">[66]</ref> performs the floating-point division by subtracting the input mantissas. To compensate a large error (estimated by analyzing the most-significant input bits), a pre-computed value is retrieved from memory. In <ref type="bibr" target="#b105">[106]</ref>, the proposed AXHD divider approximates the least-significant computations of the division using an non-iterative logarithmic approach that is based on leading '1' bit detection and subtraction of the logarithmic mantissas. Finally, Saadat et al. <ref type="bibr" target="#b160">[161]</ref> propose approximate integer and floating-point dividers with near-zero error bias, called INZeD and FaNZeD, respectively, by combining an error correction method with the classical approximate logarithmic divider.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.4">Approximate</head><p>Synthesis. An automated approach to generate inexact circuits is the approximate logic synthesis. This method provides increased approximation diversity, i.e., it generates multiple approximate circuit variants, without relying on the manual approximation inserted by the designer, such as in the case of the aforementioned arithmetic approximations. Another benefit of approximate synthesis is that several techniques generate the approximate variant that leads to the maximum hardware gains for a given approximation/error constraint. The state-of-the-art techniques can be categorized as follows <ref type="bibr" target="#b168">[169]</ref>: (i) structural netlist transformation <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b102">103,</ref><ref type="bibr" target="#b169">170,</ref><ref type="bibr" target="#b171">172,</ref><ref type="bibr" target="#b199">200]</ref>, (ii) Boolean rewriting <ref type="bibr" target="#b61">[62,</ref><ref type="bibr" target="#b117">118,</ref><ref type="bibr" target="#b151">152,</ref><ref type="bibr" target="#b200">201]</ref>, (iii) high-level approximate description <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b91">92,</ref><ref type="bibr" target="#b132">133,</ref><ref type="bibr" target="#b133">134,</ref><ref type="bibr" target="#b209">210]</ref>, and (iv) evolutionary synthesis <ref type="bibr" target="#b131">[132,</ref><ref type="bibr" target="#b172">173,</ref><ref type="bibr" target="#b191">[192]</ref><ref type="bibr" target="#b192">[193]</ref><ref type="bibr" target="#b193">[194]</ref>.</p><p>Several works of the literature employ a direct acyclic graph to represent the circuit netlist, where each node corresponds to a gate. In this context, the GLP technique <ref type="bibr" target="#b171">[172]</ref> prunes nodes with an iterative greedy approach according to their impact on the final output and their toggle activity. In contrast, the CC framework <ref type="bibr" target="#b169">[170]</ref> performs an exhaustive exploration of all possible node subsets that can be pruned without surpassing the error constraint. Venkataramani et al. <ref type="bibr" target="#b199">[200]</ref> propose SASIMI, which is based on a greedy heuristic to find signal pairs assuming the same value and substitute one with the other. This automatic synthesis framework guarantees that the user-defined quality constraint is satisfied, and generates accuracy-configurable circuits. To apply stochastic netlist transformation, the SCALS framework <ref type="bibr" target="#b102">[103]</ref> maps an initial gate-level network to the targeted technology (standard-cell or FPGA), and then iteratively extracts sets of sub-netlists and inserts random approximations in them. These sub-netlists are evaluated using statistical hypothesis testing. Castro-Codinez et al. <ref type="bibr" target="#b24">[25]</ref> propose the AxLS framework, which converts the Verilog netlist to XML format and then applies typical transformation techniques, e.g., gate pruning, with respect to an error threshold.</p><p>The second category includes techniques that apply approximations in a formal Boolean representation of the circuit before it is synthesized. The SALSA approach <ref type="bibr" target="#b200">[201]</ref> encodes the error constraints into a quality logic function, which compares the outputs of the accurate and approximate circuits. Towards logic simplification, SALSA computes the "observability don't cares" for each output of the approximate circuit, i.e., the set of input values for which the output is insensitive. In the same direction, but for sequential circuits, Ranjan et al. introduce ASLAN <ref type="bibr" target="#b151">[152]</ref>. This framework generates several approximate variants of the combinational blocks, and then identifies the best approximations for the entire sequential circuit based on a gradient-descent approach. Miao et al. <ref type="bibr" target="#b117">[118]</ref> use a two-phase Boolean minimization algorithm to address the problem of approximate synthesis. The first phase solves the problem under a given constraint for error magnitude, and the second phase iteratively finds a solution that also satisfies the error frequency constraint. In an iterative manner, the BLASYS methodology <ref type="bibr" target="#b61">[62]</ref> partitions the circuit into smaller circuits, and for each one, it generates an approximate truth table based on Boolean matrix factorization. The approximate sub-circuits are synthesized and the trade-off between error and power/area efficiency for the entire circuit is evaluated.</p><p>Regarding approximations introduced at the hardware description level, Yazdanbakhsh et al. <ref type="bibr" target="#b209">[210]</ref> propose the Axilog language annotations, which provide syntax and semantics for approximate design and reuse in Verilog. Axilog allows the designer to partition the design into accurate and approximate segments. ABACUS <ref type="bibr" target="#b133">[134]</ref> is another interesting work that parses the behavioral Verilog description of the design to create its abstract syntax tree. Next, a set of diverse transformations is applied to the tree to create approximate variants, which are then written in Verilog. An expanded version of ABACUS is introduced in <ref type="bibr" target="#b132">[133]</ref>, where sorting-based evolutionary algorithms are employed for design space exploration. Moreover, the new ABACUS version focuses on approximations in critical paths to facilitate the reduction of the supply voltage. Lee et al. <ref type="bibr" target="#b91">[92]</ref> generate approximate designs in Verilog from C accurate descriptions. The proposed framework computes data statistics and mobility information for the given design, and employs an heuristic solver for optimizing the energy-quality trade-off. Targeting to high-level synthesis, the AxHLS approach <ref type="bibr" target="#b25">[26]</ref> performs a design space exploration based on analytical models to identify the best arithmetic approximations for a given error constraint. Starting from a C description, AxHLS adopts scheduling and binding operations to apply the approximations provided by the exploration and generate the Verilog code.</p><p>The fourth class of techniques for automated synthesis of approximate circuits is based on evolutionary algorithms, i.e., heuristic-based search algorithms that treat circuit approximation as multi-objective optimization problem and generate a set of solutions. In this context, Sekanina et al. <ref type="bibr" target="#b172">[173]</ref> use Cartesian genetic programming to minimize the error in adders considering the number of logic gates as constraint. This approach is extended in <ref type="bibr" target="#b192">[193]</ref>, where approximate multipliers and median filters are evolved through randomly seeded Cartesian genetic programming. Based on the same utilities, the authors of <ref type="bibr" target="#b131">[132]</ref> propose the EvoApprox8b library of approximate adders and multipliers. This library is generated by examining various trade-offs between accuracy and hardware efficiency, and offers different approximation variants and circuit architectures. In <ref type="bibr" target="#b193">[194]</ref>, a search-based technique for evolutionary circuit synthesis for FPGAs is proposed. In particular, this approach represents the circuit as a directed acyclic graph, and re-synthesizes approximate configurations based on Cartesian genetic programming. Vasicek et al. <ref type="bibr" target="#b191">[192]</ref> adjust the approximation degree with respect to the significance of the inputs. To do so, they adopt a weighted error metric to determine the significance of each input vector and use Cartesian genetic programming to minimize the circuit's area while satisfying a threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Voltage Over-Scaling</head><p>Voltage over-scaling aims to reduce the circuit's supply voltage below its nominal value, while keeping the clock frequency constant. The circuit operation at a lower voltage value produces timing errors due to the failure of the critical paths to meet the delay constraints. Nevertheless, considering that power consumption depends on the voltage value, VOS techniques are continously examined in the literature. An exploration and quantification of the benefits and overheads of VOS is presented in <ref type="bibr" target="#b86">[87]</ref>. Research involving VOS can be classified in the following categories: (i) slack re-distribution <ref type="bibr" target="#b77">[78]</ref>, (ii) circuit re-design and architecture modification <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b127">128,</ref><ref type="bibr" target="#b218">219]</ref>, (iii) fine-grained scaling <ref type="bibr" target="#b135">[136,</ref><ref type="bibr" target="#b201">202,</ref><ref type="bibr" target="#b216">217]</ref>, and (iv) error modeling <ref type="bibr" target="#b67">[68,</ref><ref type="bibr" target="#b73">74,</ref><ref type="bibr" target="#b108">109,</ref><ref type="bibr" target="#b145">146,</ref><ref type="bibr" target="#b215">216]</ref>.</p><p>Kahng et al. <ref type="bibr" target="#b77">[78]</ref> shift the timing slack of the frequently executed near-critical paths through slack redistribution, and thus, reduce the minimum voltage at which the error rate remains acceptable. The proposed technique is based on post-layout cell resizing to deliver the switching activity-aware slack redistribution. More specifically, a heuristic finds the voltage satisfying the desired error rate, and then increases the transistor width of the cells to optimize the frequently executed paths.</p><p>In <ref type="bibr" target="#b127">[128]</ref>, the authors optimize building blocks for more graceful degradation under VOS, using two techniques, i.e., dynamic segmentation &amp; error compensation and delay budgeting of chained datapath. The first technique bit-slices the datapath of the adder and employs a multi-cycle error correction circuitry that tracks the carries. The second technique adds transparent latches between chained arithmetic units to distribute the clock period. To facilitate VOS, Chen et al. <ref type="bibr" target="#b28">[29]</ref> build their designs on the residue number system, which provides shorter critical paths than conventional arithmetic. They also employ the reduced precision redundancy scheme to eliminate the timing errors. Another interesting work is Thundervolt <ref type="bibr" target="#b218">[219]</ref>, which provides error recovery in the MAC units of systolic arrays. To detect timing errors, Thundervolt employs Razor shadow flip-flops. In case an error occurs in a MAC, a multiplexer forwards the previous MAC's accurate partial sum (stored in the Razor flip-flop) to the next MAC.</p><p>Targeting fine-grained VOS solutions, i.e., the use of different voltages across the same circuit architecture, <ref type="bibr">Pandey et al. propose GreenTPU [136]</ref>. This technique stores input sequences producing timing errors in MACs. As a result, when such an input sequence pattern is identified, the voltage of the MAC is scaled accordingly to prevent timing errors. In the same context, the authors of <ref type="bibr" target="#b201">[202]</ref> propose NN-APP. This framework analyzes the error propagation in neural networks to model the impact of VOS on accuracy. Based on this analysis, as well as an error resilience study for the neurons, NN-APP uses a voltage clustering method to assign the same voltage to neurons with similar error resilience. Another fine-grained VOS approach is proposed in <ref type="bibr" target="#b216">[217]</ref>. This framework provides voltage heterogeneity by using a greedy algorithm to solve the optimization problem of grouping and assigning the voltage of arithmetic units to different islands.</p><p>The analysis of errors in circuits under VOS is considered a key factor, as it guides the aggressiveness of voltage scaling towards the acceptable error margins. In <ref type="bibr" target="#b108">[109]</ref>, an analytical method to study the errors in voltage over-scaled arithmetic circuits is proposed. Similarly, the authors of <ref type="bibr" target="#b67">[68]</ref> introduce a probabilistic approach to model the errors of the critical paths. In the same category, works relying on simulations to analyze the errors of VOS can be included. Ragavan et al. <ref type="bibr" target="#b145">[146]</ref> characterize arithmetic circuits in terms of energy efficiency and errors using transistor-level SPICE simulation for various voltages. Based on this characterization, they propose a statistical model to simulate the behavior of arithmetic operations in VOS systems. By exploiting machine learning methods, Jiao et al. <ref type="bibr" target="#b73">[74]</ref> propose LEVAX to model voltage over-scaled functional units. This input-aware model is trained on data from gate-level simulations to predict the timing error rate for each output bit. To provide accurate VOS-aware gate-level simulation, Zervakis et al. propose VOSsim <ref type="bibr" target="#b215">[216]</ref>. This framework performs an offline characterization of the flip-flop for timing violations, and calculates the cell delays for the targeted voltage, enabling gate-level simulation under VOS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Over-Clocking</head><p>Over-clocking (or frequency over-scaling) aims to operate the circuit/system at higher clock frequencies than those that respect the critical paths. As a result, timing errors are induced in exchange for increased performance. A trade-off analysis between accuracy and performance when over-clocking FPGA-based designs is presented in <ref type="bibr" target="#b175">[176]</ref>. In the same work, the authors show that OC outperforms the traditional bit truncation for the same error constraint. The analysis of the current survey considers that the state-of-the-art works of the domain focus on the following directions: (i) tight synthesis <ref type="bibr" target="#b6">[7]</ref>, (ii) circuit re-design and architecture modification <ref type="bibr" target="#b150">[151,</ref><ref type="bibr" target="#b176">177,</ref><ref type="bibr" target="#b202">203]</ref>, (iii) error detection &amp; correction <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b99">100,</ref><ref type="bibr" target="#b146">147]</ref>, and (iv) error prediction <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b71">72,</ref><ref type="bibr" target="#b72">73,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b111">112,</ref><ref type="bibr" target="#b156">157]</ref>.</p><p>The first approach towards the reduction of timing errors caused by OC optimizes the critical paths of the design. In this context, the SlackHammer framework <ref type="bibr" target="#b6">[7]</ref> synthesizes circuits with tight delay constraints to reduce the number of near-critical paths, and thus, decrease the probability of timing errors when frequency is over-scaled. At first, SlackHammer isolates the paths and identifies potential delay optimizations. Based on the isolated path analysis, the framework performs an iterative synthesis with tighter constraints for the primary outputs with negative slack.</p><p>The second class of techniques aims at modifying the conventional circuit architecture to facilitate frequency OC and increase the resilience to timing errors. The retiming technique <ref type="bibr" target="#b150">[151]</ref> re-defines the boundaries of combinational logic by moving the flip-flops backward or forward between the stages. Based on this circuit optimization, the synthesis is relaxed by ignoring the paths that are bottleneck to minimum period retiming. Targeting different circuit architectures, Shi et al. <ref type="bibr" target="#b176">[177]</ref> adopt an alternative arithmetic, called Online, and show that online-based circuits are more resilient to the timing errors of OC than circuits with traditional arithmetic. The modification of the initial neural network model to provide resilience in timing errors has also attracted research interest. In this direction, Wang et al. <ref type="bibr" target="#b202">[203]</ref> propose an iterative reclocking-and-retraining framework for operating neural network circuits at higher frequencies under a given accuracy constraint. The clock frequency is gradually increased, and the network's weights are updated through back-propagation training until to find the maximum frequency for which the timing errors are mitigated and the accuracy constraint is satisfied.</p><p>Several works propose circuits for timing error detection &amp; correction, enabling the use of over-clocking. These techniques either improve the frequency value of the first failure, i.e., the first timing error, or reduce the probability of timing errors. TIMBER <ref type="bibr" target="#b38">[39]</ref> masks timing errors by borrowing time from successive pipeline stages. According to this approach, the use of discrete time-borrowing flip-flops and continuous time-borrowing latches slows down the appearance of timing errors with respect to the frequency scaling. Ragavan et al. <ref type="bibr" target="#b146">[147]</ref> detect and correct timing errors by employing a dynamic speculation window on the double-sampling scheme. This technique adds an extra register, called shadow and clocked by a second "delayed" clock, at the end of the pipelined path to sample the output data at two different time instances. This approach also uses an online slack measurement to adaptively over-clock the design. The TEAI approach <ref type="bibr" target="#b99">[100]</ref> is based on the locality of the timing errors in software-level instructions, i.e., the tendency of specific instructions to produce timing errors. TEAI identifies these instructions at runtime, and sends error alarms to hardware, which is equipped with error detection &amp; correction circuits.</p><p>Significant research has also been conducted on predicting the timing errors in advance, allowing to over-scale the frequency according to the acceptable error margins. In <ref type="bibr" target="#b156">[157]</ref>, the authors introduce an instruction-level error prediction system for pipelined micro-processors, which stalls the pipeline when critical instructions are detected. Their method is based on gate-level simulations to find the critical paths that are sensitized during the program execution. Similarly, Constantin et al. <ref type="bibr" target="#b39">[40]</ref> obtain the maximum delays for each arithmetic instruction through gate-level simulations, and dynamically exploit timing margins to apply frequency over-scaling.</p><p>In addition to instruction-level prediction models, there are numerous works that build models based on machine learning and simulations of functional units. A representative work of this approach is WILD <ref type="bibr" target="#b71">[72]</ref>, which builds a workload-dependent prediction model using logistic regression. In the same direction, SLoT <ref type="bibr" target="#b72">[73]</ref> is a supervised learning model that predicts timing errors based on the inputs and the clock frequency. At first, SLoT performs gate-level simulation to extract timing class labels, i.e., "timing error" or "no timing error", for different inputs and frequencies. These classes are then used, along with features extracted from random data pre-processing, to train the error prediction model. Towards the same approach, TEVoT <ref type="bibr" target="#b74">[75]</ref> uses machine learning to build a timing error prediction model that can predict the timing errors under different clock speeds and operating conditions, which are used to estimate the output quality of error-tolerant applications (e.g., image processing). DEVoT <ref type="bibr" target="#b111">[112]</ref> is an extension of TEVoT that formulates the timing error prediction as a circuit dynamic delay prediction problem, saving significant prediction resources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">COMPARATIVE QUANTITATIVE ANALYSIS OF APPROXIMATION TECHNIQUES</head><p>This section reports a quantitative analysis for the software and hardware approximation classes. Due to their very large volume, diversity and differentiation, direct intra-and cross-layer comparisons are not performed. However, significant outcomes can be extracted for each class (e.g., type and size of workloads, acceptable accuracy loss, targeted resource gains). It is also noted that additional comparisons are reported in Part II of the survey <ref type="bibr" target="#b93">[94]</ref>, where an application-driven analysis of case studies is presented, involving both software and hardware techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Software Approximation Techniques</head><p>Table <ref type="table" target="#tab_5">5</ref> reports remarkable software-level works from each approximation class, along with key numerical results for resource gains and errors. Based on the literature's review, each software approximation technique is favored in specific workloads (e.g., precision scaling in high-performance floating-point programs and data sampling in large queries), even though there are also more general techniques (e.g., loop perforation). Most works evaluate the approximations for various levels of quality degradation, e.g., 2%, 5%, and 10%, with the latter being widely considered as the largest acceptable threshold for the workloads of Table <ref type="table" target="#tab_5">5</ref>. Another significant outcome is that the combination of approximation knobs, such as in the case of approximate programming languages, delivers more resource gains than the application of a single approximation technique. For example, in comparison with approximate memoization, the approximate programming language of Table <ref type="table" target="#tab_5">5</ref> provides 8%-28% more energy gain for workloads of similar type and size. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Hardware Approximation Techniques</head><p>The respective results for all the hardware approximation techniques analyzed in the previous sections are summarized in Fig. <ref type="figure" target="#fig_2">5</ref>. To generate Fig. <ref type="figure" target="#fig_2">5</ref>, we identified the most commonly used workloads among each hardware approximation family and categorized them into two arbitrary levels: small and heavy. Workloads requiring more than 50M operations (such as in deep neural networks) are classified as heavy, while those below this threshold are considered small. Then, we created a decision tree that helps the reader to identify the works having remarkable results with respect to the complexity of the workload, the baseline bit precision and the desired accuracy loss constraint. For the accuracy loss, two thresholds are considered, i.e., small accuracy loss (less than 1%) and moderate accuracy loss (less than 5%). For only few reported works, we define low accuracy loss as an MRED of less than 5%, while medium accuracy loss falls between 5% and 15%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Workload ≤8b &gt;8b</head><p>≤1% ≤5% ≤1% ≤5% <ref type="bibr" target="#b196">[197]</ref> 46% [205] 68% ≤8b &gt;8b ≤1% ≤5% ≤1% ≤5% ≤8b &gt;8b ≤1% ≤5% ≤1% ≤5% Voltage Over-scaling Functional Approx small Over-clocking ≤8b &gt;8b ≤1% ≤5% ≤1% ≤5% ≤8b &gt;8b ≤1% ≤5% ≤1% ≤5% ≤8b &gt;8b ≤1% ≤5% ≤1% ≤5% Voltage Over-scaling Functional Approx Over-clocking heavy [95] 55% [95] 66% [151] 9% [151] 25% [203] 13% [203] 19% [219] 56% [136] 67% [146] 73% [146] 91% [190] 44% [190] 54% [142] 40% [142] 76% N/E N/E [203] 7% [203] 10% [219] 36% [219] 45% [109] 15% [109] 20% : Bit Precision : Accuracy Loss : Ref w/ top results N/E: Not Evaluated The leaves represent the works that achieve the highest energy reduction in each case. Overall, it seems that both Voltage Over-scaling and Circuit Functional Approximation appear among the top energy reduction results, outperforming Over-clocking. It is worth noting that Over-clocking shows a significant lack of energy efficiency compared to other techniques when processing heavy workloads. On the other hand, approximation techniques in small workloads can achieve substantial energy savings (e.g., 68%, 91%), even when using reduced precision and considering low accuracy loss thresholds. However, the high difference between small and heavy workloads highlights the need for continued research into hardware approximation techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>This article presented Part I of a comprehensive survey on Approximate Computing, focusing on key aspects of this novel design paradigm (motivation, terminology, and principles) and reviewing the state-of-the-art software and hardware approximation techniques. The review and classification was performed in both coarse-grained and fine-grained manners: each software/hardware-level technique was assigned to a higher-level approximation class (e.g., precision scaling, voltage overscaling), as well as to a lower-level class with respect to its technical/implementation details (e.g., radix encoding, error prediction). Finally, a quantitative analysis of the approximation techniques was reported, involving the most commonly used workloads and key numerical results. Part II of the survey reviews the state-of-the-art software &amp; hardware application-specific approximation techniques and architecture-level approximations in processors and memories. It also presents the application spectrum of Approximate Computing, including an analysis of use cases with remarkable results per technique and application domain, as well as well-established benchmark suites and error metrics for Approximate Computing.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Classification of SW approximation techniques in 6 classes: Selective Task Skipping, Approximate Memoization, Relaxed Synchronization, Precision Scaling, Data Sampling, and Approximate Programming Languages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Classification of HW approximation techniques in 3 classes: Circuit Functional Approximation, Voltage Over-Scaling and Over-Clocking.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Fig.<ref type="bibr" target="#b4">5</ref>. Classification and comparative analysis of the most remarkable hardware approximation works with respect to their workload complexity, baseline bit precision and an accuracy loss threshold (1% and 5%). The leafs present the corresponding work along with their top results in energy reduction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Qualitative comparison of Approximate Computing surveys on the entire computing stack.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>2</cell></row><row><cell>A x C S u r v e y</cell><cell>Ye ar Co ve ra ge</cell><cell>Pa ge s #</cell><cell>Re fe re nc es #</cell><cell>SW Te ch .</cell><cell>H W Te ch .</cell><cell>A rc h. A pp ro x.</cell><cell>A I/M L</cell><cell>M em or ie s</cell><cell>Fr am ew or ks &amp; To ol s</cell><cell>M et ri cs</cell><cell>Be nc hm ar ks</cell><cell>CP U /F PG A / G PU /A SI C</cell><cell>Te rm in ol og y</cell><cell>Ch al le ng es</cell><cell>Q ua nt . A na ly si s</cell></row><row><cell>[59]</cell><cell cols="2">2013 6</cell><cell>65</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 .</head><label>5</label><figDesc>Quantitative analysis of software approximation techniques.</figDesc><table><row><cell>Approximation Class</cell><cell>Workloads</cell><cell>Resource Gains</cell><cell>Accuracy Metric</cell><cell>Ref.</cell></row><row><cell>Loop Perforation</cell><cell>BlackScholes, KMeans X264, Streamcluster</cell><cell>32%-36% energy 2×-8.5× speedup</cell><cell cols="2">rel.err=3.5%, PSNR=36dB [15] error=5%,10% [99]</cell></row><row><cell>Computation Skipping</cell><cell>GoogLeNet, VGGNet MPEG, KNN</cell><cell>2.2×-1.9× speedup ∼2× energy</cell><cell>class.accur.loss≤3% qual.degrad=2.5%,5%</cell><cell>[6] [149]</cell></row><row><cell>Memory Access Skipping</cell><cell>FluidAnimate, BodyTrack Gaussian, MatMul</cell><cell>6%-28% speedup 1.45×-2.4× speedup</cell><cell>error&lt;10% qual.degrad=10%</cell><cell>[119] [211]</cell></row><row><cell>Approximate Memoization</cell><cell>BoxMuller, GammaCorr BodyTrack, Sobel</cell><cell>1.5×-3.2× speedup 22% energy</cell><cell>qual.degrad=10% qual.degrad=4%-10%</cell><cell>[163] [124]</cell></row><row><cell>Relaxed Synchronization</cell><cell>Graph500, KMeans Barnes-Hut, VolRender</cell><cell>3×-15× speedup 6× speedup</cell><cell>qual.degrad=0 qual.degrad=0</cell><cell>[153] [123]</cell></row><row><cell>Precision Scaling</cell><cell>Lulesh, JetEngine Bessel, FFT</cell><cell>1.2×-1.4× speedup 11.5×-43.4× speedup</cell><cell>error=10 -13 -10 -11 error=10 -10 -10 -4</cell><cell>[117] [57]</cell></row><row><cell>Data Sampling</cell><cell>WikiLength Conviva, TPC-H</cell><cell>21% speedup 10×-100× speedup</cell><cell>error=0.34% accur.loss=2%-10%</cell><cell>[55] [3]</cell></row><row><cell>Approx. Programm. Languages</cell><cell>PageRank, Sobel MonteCarlo, RayTracer</cell><cell>1.1×-1.7× speedup 30%-50% energy</cell><cell>e2e.error=10 -8 -10 -16 error&lt;0.2</cell><cell>[50] [167]</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Computing Surveys, Volume 57, Issue 7, Article 185. Publication Year: 2025.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGEMENT</head><p>This research is partially supported by <rs type="funder">ASPIRE</rs>, the technology program management pillar of <rs type="person">Abu Dhabi</rs>'s <rs type="funder">Advanced Technology Research Council (ATRC)</rs>, via the <rs type="programName">ASPIRE Awards for Research Excellence</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_FdMxdpa">
					<orgName type="program" subtype="full">ASPIRE Awards for Research Excellence</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Approximate Computation with Outlier Detection in Topaz</title>
		<author>
			<persName><forename type="first">Sara</forename><surname>Achour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Int&apos;l. Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="711" to="730" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Approximate Restoring Dividers Using Inexact Cells and Estimation From Partial Remainders</title>
		<author>
			<persName><forename type="first">Elizabeth</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suganthi</forename><surname>Venkatachalam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seok-Bum</forename><surname>Ko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="page" from="468" to="474" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">BlinkDB: Queries with Bounded Errors and Bounded Response Times on Very Large Data</title>
		<author>
			<persName><forename type="first">Sameer</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barzan</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aurojit</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGOPS European Conference on Computer Systems (EuroSys)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="29" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Compressors for Utilizing in Dynamic Accuracy Configurable Multipliers</title>
		<author>
			<persName><forename type="first">Omid</forename><surname>Akbari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massoud</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1352" to="1361" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
	<note>Dual-Quality</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">RAP-CLA: A Reconfigurable Approximate Carry Look-Ahead Adder</title>
		<author>
			<persName><forename type="first">Omid</forename><surname>Akbari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massoud</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems II: Express Briefs</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="page" from="1089" to="1093" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">SnaPEA: Predictive Early Activation for Reducing Computation in Deep Convolutional Neural Networks</title>
		<author>
			<persName><forename type="first">Vahideh</forename><surname>Akhlaghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Yazdanbakhsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kambiz</forename><surname>Samadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rajesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hadi</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><surname>Esmaeilzadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE Int&apos;l. Symposium on Computer Architecture (ISCA)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="662" to="673" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">SlackHammer: Logic Synthesis for Graceful Errors Under Frequency Scaling</title>
		<author>
			<persName><forename type="first">Tanfer</forename><surname>Alan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="2802" to="2811" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fuzzy Memoization for Floating-Point Multimedia Applications</title>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Alvarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesus</forename><surname>Corbal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mateo</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="922" to="927" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Input Selection for Fast Feature Engineering</title>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">R</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Cafarella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Conference on Data Engineering (ICDE)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="577" to="588" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An Improved Logarithmic Multiplier for Energy-Efficient Neural Computing</title>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Saeed Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><forename type="middle">F</forename><surname>Cockburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="614" to="625" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Language and Compiler Support for Auto-Tuning Variable-Accuracy Algorithms</title>
		<author>
			<persName><forename type="first">Jason</forename><surname>Ansel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yee</forename><forename type="middle">Lok</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cy</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marek</forename><surname>Olszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Edelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Int&apos;l. Symposium on Code Generation and Optimization</title>
		<imprint>
			<biblScope unit="page" from="85" to="96" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Review of Approximate Computing Techniques Towards Fault Mitigation in HW/SW Systems</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Aponte-Moreno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alejandro</forename><surname>Moncada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Felipe</forename><surname>Restrepo-Calle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cesar</forename><surname>Pedraza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Latin-American Test Symposium (LATS)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Hardware Approximate Techniques for Deep Neural Network Accelerators: A Survey</title>
		<author>
			<persName><forename type="first">Giorgos</forename><surname>Armeniakos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Zervakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="1" to="36" />
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Green: A Framework for Supporting Energy-Conscious Programming Using Controlled Approximation</title>
		<author>
			<persName><forename type="first">Woongki</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trishul</forename><forename type="middle">M</forename><surname>Chilimbi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="198" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">LEXACT: Low Energy N-Modular Redundancy Using Approximate Computing for Real-Time Multicore Processors</title>
		<author>
			<persName><forename type="first">Farshad</forename><surname>Baharvand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seyed</forename><surname>Ghassem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miremadi</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Emerging Topics in Computing</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="431" to="441" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">FlexiCores: Low Footprint, High Yield, Field Reprogrammable Flexible Microprocessors</title>
		<author>
			<persName><forename type="first">Nathaniel</forename><surname>Bleier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Calvin</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francisco</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antony</forename><surname>Sou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE Int&apos;l. Symposium on Computer Architecture (ISCA)</title>
		<imprint>
			<date type="published" when="2022">2022</date>
			<biblScope unit="page" from="831" to="846" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Uncertain&lt;T&gt;: A First-Order Type for Uncertain Data</title>
		<author>
			<persName><forename type="first">James</forename><surname>Bornholt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Mytkowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathryn</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Int&apos;l. Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="51" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Probability Type Inference for Flexible Approximate Programming</title>
		<author>
			<persName><forename type="first">Brett</forename><surname>Boston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Int&apos;l. Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="470" to="487" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">ATM: Approximate Task Memoization in the Runtime System</title>
		<author>
			<persName><forename type="first">Iulian</forename><surname>Brumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Casas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miquel</forename><surname>Moreto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mateo</forename><surname>Valero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gurindar</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Parallel and Distributed Processing Symposium (IPDPS)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1140" to="1150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Tuning Floating-Point Precision Using Dynamic Program Information and Temporal Locality</title>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Brunie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Costin</forename><surname>Iancu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Khaled</forename><forename type="middle">Z</forename><surname>Ibrahim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><surname>Brisk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brandon</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE SC, Int&apos;l. Conference for High Performance Computing, Networking, Storage and Analysis</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Best-Effort Semantic Document Search on GPUs</title>
		<author>
			<persName><forename type="first">Surendra</forename><surname>Byna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiayuan</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srimat</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srihari</forename><surname>Cadambi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on General-Purpose Computation on Graphics Processing Units (GPGPU)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="86" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">HELIX-UP: Relaxing Program Semantics to Unleash Parallelization</title>
		<author>
			<persName><forename type="first">Simone</forename><surname>Campanoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Glenn</forename><surname>Holloway</surname></persName>
		</author>
		<author>
			<persName><surname>Gu-Yeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Int&apos;l. Symposium on Code Generation and Optimization</title>
		<imprint>
			<biblScope unit="page" from="235" to="245" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Proving Acceptability Properties of Relaxed Nondeterministic Approximate Programs</title>
		<author>
			<persName><forename type="first">Deokhwan</forename><surname>Michael Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Verifying Quantitative Reliability for Programs That Execute on Unreliable Hardware</title>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Michael Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Int&apos;l. Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="33" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">AxLS: A Framework for Approximate Logic Synthesis Based on Netlist Transformations</title>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Castro-Godínez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Humberto</forename><surname>Barrantes-García</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="2845" to="2849" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
	<note>Express Briefs</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">AxHLS: Design Space Exploration and High-Level Synthesis of Approximate Accelerators using Approximate Functional Units and Analytical Models</title>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Castro-Godínez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julián</forename><surname>Mateus-Vargas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Int&apos;l. Conference On Computer Aided Design (ICCAD)</title>
		<imprint>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Best-Effort Computing: Re-thinking Parallel Software and Hardware</title>
		<author>
			<persName><forename type="first">T</forename><surname>Srimat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="865" to="870" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Proving Programs Robust</title>
		<author>
			<persName><forename type="first">Swarat</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Lublinerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sara</forename><surname>Navidpour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGSOFT Symposium and European Conference on Foundations of Software Engineering (FSE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="102" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Energy-Efficient Digital Signal Processing via Voltage-Overscaling-Based Residue Number System</title>
		<author>
			<persName><forename type="first">Jienan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianhao</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1322" to="1332" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Efficient Implementations of Reduced Precision Redundancy (RPR) Multiply and Accumulate (MAC)</title>
		<author>
			<persName><forename type="first">Ke</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linbin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Reviriego</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="784" to="790" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Design of Approximate Unsigned Integer Non-Restoring Divider for Inexact Computing</title>
		<author>
			<persName><forename type="first">Linbin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Great Lakes Symposium on VLSI (GLSVLSI)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="51" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On the Design of Approximate Restoring Dividers for Error-Tolerant Applications</title>
		<author>
			<persName><forename type="first">Linbin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="page" from="2522" to="2533" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Algorithm and Design of a Fully Parallel Approximate Coordinate Rotation Digital Computer (CORDIC)</title>
		<author>
			<persName><forename type="first">Linbin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Multi-Scale Computing Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="139" to="151" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Design, Evaluation and Application of Approximate High-Radix Dividers</title>
		<author>
			<persName><forename type="first">Linbin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Multi-Scale Computing Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="299" to="312" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Tools for Reduced Precision Computation: A Survey</title>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Cherubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Agosta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="1" to="35" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Rigorous Floating-Point Mixed-Precision Tuning</title>
		<author>
			<persName><forename type="first">Wei-Fan</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Baranowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Briggs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Solovyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ganesh</forename><surname>Gopalakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zvonimir</forename><surname>Rakamarić</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Symposium on Principles of Programming Languages (POPL</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="300" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Efficient Search for Inputs Causing High Floating-Point Errors</title>
		<author>
			<persName><forename type="first">Wei-Fan</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ganesh</forename><surname>Gopalakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zvonimir</forename><surname>Rakamaric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Solovyev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="43" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Scalable Effort Hardware Design</title>
		<author>
			<persName><forename type="first">Debabrata</forename><surname>Vinay Kumar Chippa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaushik</forename><surname>Mohapatra</surname></persName>
		</author>
		<author>
			<persName><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Srimat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="2004" to="2016" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Time-Borrowing Circuit Designs and Hardware Prototyping for Timing Error Resilience</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mihir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vikas</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">C</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kartik</forename><surname>Aitken</surname></persName>
		</author>
		<author>
			<persName><surname>Mohanram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="497" to="509" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Exploiting Dynamic Timing Margins in Microprocessors for Frequency-Over-Scaling with Instruction-Based Clock Adjustment</title>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Constantin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lai</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Karakonstantis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anupam</forename><surname>Chattopadhyay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Burg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="381" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">Tom</forename><surname>Coughlin</surname></persName>
		</author>
		<ptr target="https://www.forbes.com/sites/tomcoughlin/2018/11/27/175-zettabytes-by-2025/?sh=254787045459" />
		<title level="m">175 Zettabytes By 2025</title>
		<imprint>
			<date type="published" when="2023">2023. 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Systematic Design of an Approximate Adder: The Optimized Lower Part Constant-OR Adder</title>
		<author>
			<persName><forename type="first">Ayad</forename><surname>Dalloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ardalan</forename><surname>Najafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Garcia-Ortiz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1595" to="1599" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Approximation Opportunities in Edge Computing Hardware: A Systematic Literature Review</title>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Hans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aleksandr</forename><surname>Damsgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jari</forename><surname>Ometov</surname></persName>
		</author>
		<author>
			<persName><surname>Nurmi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="1" to="49" />
			<date type="published" when="2023">2023. 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Towards a Compiler for Reals</title>
		<author>
			<persName><forename type="first">Eva</forename><surname>Darulova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Viktor</forename><surname>Kuncak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="1" to="28" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Certifying the Floating-Point Implementation of an Elementary Function Using Gappa</title>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Florent De Dinechin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Lauter</surname></persName>
		</author>
		<author>
			<persName><surname>Melquiond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="242" to="253" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Design of Ion-Implanted MOSFET&apos;s with Very Small Physical Dimensions</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Dennard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Gaensslen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hwa-Nien</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">L</forename><surname>Rideout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bassous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Leblanc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal of Solid-State Circuits</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="256" to="268" />
			<date type="published" when="1974">1974. 1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Block-Based Carry Speculative Approximate Adder for Energy-Efficient Applications</title>
		<author>
			<persName><forename type="first">Farhad</forename><surname>Ebrahimi-Azandaryani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omid</forename><surname>Akbari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massoud</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="137" to="141" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
	<note>Express Briefs</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Power Challenges May End the Multicore Era</title>
		<author>
			<persName><forename type="first">Emily</forename><surname>Hadi Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Renée</forename><surname>Blem</surname></persName>
		</author>
		<author>
			<persName><surname>St</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karthikeyan</forename><surname>Amant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Doug</forename><surname>Sankaralingam</surname></persName>
		</author>
		<author>
			<persName><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page" from="93" to="102" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Approximate Multipliers Based on New Approximate Compressors</title>
		<author>
			<persName><forename type="first">Darjn</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Giuseppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maria</forename><surname>Strollo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ettore</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><forename type="middle">De</forename><surname>Caro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Petra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems I: Regular Papers</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="page" from="4169" to="4182" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Verifying Safety and Accuracy of Approximate Parallel Programs via Canonical Sequentialization</title>
		<author>
			<persName><forename type="first">Vimuth</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keyur</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the ACM on Programming Languages</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Approximate Multipliers With Dynamic Truncation for Energy Reduction via Graceful Quality Degradation</title>
		<author>
			<persName><forename type="first">Fabio</forename><surname>Frustaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefania</forename><surname>Perri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pasquale</forename><surname>Corsonello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimo</forename><surname>Alioto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="3427" to="3431" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
	<note>Express Briefs</note>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<author>
			<persName><surname>Gartner</surname></persName>
		</author>
		<ptr target="https://www.gartner.com/en/newsroom/press-releases/2018-11-07-gartner-identifies-top-10-strategic-iot-technologies-and-trends" />
		<title level="m">Gartner Identifies Top 10 Strategic IoT Technologies and Trends</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">SquASH: Approximate Square-Accumulate With Self-Healing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ghayoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Gillani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abdullah Hanif</surname></persName>
		</author>
		<author>
			<persName><surname>Krone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sabih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Gerez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andre</forename><forename type="middle">B J</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><surname>Kokkeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="49112" to="49128" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">MACISH: Designing Approximate MAC Accelerators With Internal-Self-Healing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ghayoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><forename type="middle">Abdullah</forename><surname>Gillani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Hanif</surname></persName>
		</author>
		<author>
			<persName><surname>Verstoep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sabih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Gerez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andre</forename><forename type="middle">B J</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><surname>Kokkeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access 7 ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="77142" to="77160" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
	<note>Publication Year</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">ApproxHadoop: Bringing Approximations to MapReduce Frameworks</title>
		<author>
			<persName><forename type="first">Inigo</forename><surname>Goiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ricardo</forename><surname>Bianchini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santosh</forename><surname>Nagarakatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thu</forename><forename type="middle">D</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Int&apos;l. Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="383" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Church: A Language for Generative Models</title>
		<author>
			<persName><forename type="first">Noah</forename><forename type="middle">D</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vikash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Mansinghka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">B</forename><surname>Bonawitz</surname></persName>
		</author>
		<author>
			<persName><surname>Tenenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Uncertainty in Artificial Intelligence (UAI)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="220" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Exploiting Community Structure for Floating-Point Precision Tuning</title>
		<author>
			<persName><forename type="first">Hui</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cindy</forename><surname>Rubio-González</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGSOFT Int&apos;l. Symposium on Software Testing and Analysis (ISSTA)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="333" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Low-Power Digital Signal Processing Using Approximate Adders</title>
		<author>
			<persName><forename type="first">Vaibhav</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Debabrata</forename><surname>Mohapatra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaushik</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="124" to="137" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Approximate Computing: An Emerging Paradigm for Energy-Efficient Design</title>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Orshansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE European Test Symposium (ETS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">DRUM: A Dynamic Range Unbiased Multiplier for Approximate Applications</title>
		<author>
			<persName><forename type="first">Soheil</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Iris</forename><surname>Bahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherief</forename><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Int&apos;l. Conference on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page" from="418" to="425" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A Low-Power Dynamic Divider for Approximate Applications</title>
		<author>
			<persName><forename type="first">Soheil</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Iris</forename><surname>Bahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherief</forename><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">BLASYS: Approximate Logic Synthesis Using Boolean Matrix Factorization</title>
		<author>
			<persName><forename type="first">Soheil</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hokchhay</forename><surname>Tann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherief</forename><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<title level="m" type="main">Using Code Perforation to Improve Performance, Reduce Energy Consumption, and Respond to Failures</title>
		<author>
			<persName><forename type="first">Henry</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stelios</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anant</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
		<idno>MIT-CSAIL-TR-2009-042</idno>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="page" from="1" to="21" />
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Approximation with Error Bounds in Spark</title>
		<author>
			<persName><forename type="first">Guangyan</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandro</forename><surname>Rigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Desheng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thu</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Symposium on Modeling, Analysis, and Simulation of Computer and Telecommunication Systems</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="61" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A New Approximate Adder with Low Relative Error and Correct Sign Calculation</title>
		<author>
			<persName><forename type="first">Junjun</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weikang</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1449" to="1454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">CADE: Configurable Approximate Divider for Energy Efficiency</title>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Imani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ricardo</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tajana</forename><surname>Rosing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="586" to="589" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<author>
			<persName><forename type="first">Iot</forename><surname>Analytics</surname></persName>
		</author>
		<ptr target="https://iot-analytics.com/number-connected-iot-devices/" />
		<title level="m">State of IoT 2023</title>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Design Methodology for Voltage-Overscaled Ultra-Low-Power Systems</title>
		<author>
			<persName><forename type="first">Dongsuk</forename><surname>Jeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingoo</forename><surname>Seok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhengya</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Blaauw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Sylvester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="952" to="956" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
	<note>Express Briefs</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Approximate Radix-8 Booth Multipliers for Low-Power and High-Performance Operation</title>
		<author>
			<persName><forename type="first">Honglan</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fei</forename><surname>Qiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="page" from="2638" to="2644" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Low-Power Unsigned Divider and Square Root Circuit Designs Using Adaptive Approximation</title>
		<author>
			<persName><forename type="first">Honglan</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leibo</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="1635" to="1646" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Approximate Arithmetic Circuits: A Survey, Characterization, and Recent Applications</title>
		<author>
			<persName><forename type="first">Honglan</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francisco</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><forename type="middle">Hernandez</forename><surname>Santiago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hai</forename><surname>Mo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leibo</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="2108" to="2135" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">WILD: A Workload-Based Learning Model to Predict Dynamic Delay of Functional Units</title>
		<author>
			<persName><forename type="first">Xun</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abbas</forename><surname>Rahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajesh</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Conference on Computer Design (ICCD)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="185" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">SLoT: A Supervised Learning Model to Predict Dynamic Timing Errors of Functional Units</title>
		<author>
			<persName><forename type="first">Xun</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abbas</forename><surname>Rahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajesh</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Design, Automation &amp; Test</title>
		<imprint>
			<biblScope unit="page" from="1183" to="1188" />
			<date type="published" when="2017">2017</date>
			<pubPlace>Europe (DATE</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">LEVAX: An Input-Aware Learning-Based Error Model of Voltage-Scaled Functional Units</title>
		<author>
			<persName><forename type="first">Xun</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongning</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wanli</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="5032" to="5041" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">TEVoT: Timing Error Modeling of Functional Units under Dynamic Voltage and Temperature Variations</title>
		<author>
			<persName><forename type="first">Xun</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongning</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wanli</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Statistical Algorithmic Profiling for Randomized Approximate Programs</title>
		<author>
			<persName><forename type="first">Keyur</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vimuth</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE Int&apos;l. Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="608" to="618" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Accuracy-Configurable Adder for Approximate Arithmetic Designs</title>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seokhyeong</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="820" to="825" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Slack Redistribution for Graceful Degradation Under Voltage Overscaling</title>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seokhyeong</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Sartori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asia and South Pacific Design Automation Conference (ASP-DAC</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="825" to="831" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Quickr: Lazily Approximating Complex Ad-Hoc Queries in Big Data Clusters</title>
		<author>
			<persName><forename type="first">Srikanth</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anil</forename><surname>Shanbhag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aleksandar</forename><surname>Vitorovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthaios</forename><surname>Olma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Grandl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Surajit</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bolin</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGMOD Int&apos;l. Conference on Management of Data (MOD</title>
		<imprint>
			<biblScope unit="page" from="631" to="646" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Approximation-Aware Coordinated Power/Performance Management for Heterogeneous Multi-cores</title>
		<author>
			<persName><forename type="first">Anil</forename><surname>Kanduri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Miele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Amir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pasi</forename><surname>Rahmani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristiana</forename><surname>Liljeberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikil</forename><surname>Bolchini</surname></persName>
		</author>
		<author>
			<persName><surname>Dutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">PreScaler: An Efficient System-Aware Precision Scaling Framework on Heterogeneous Systems</title>
		<author>
			<persName><forename type="first">Seokwon</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyunghwan</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongjun</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Int&apos;l. Symposium on Code Generation and Optimization</title>
		<imprint>
			<biblScope unit="page" from="280" to="292" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Architecture-Aware Approximate Computing</title>
		<author>
			<persName><forename type="first">Mustafa</forename><surname>Karakoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orhan</forename><surname>Kislal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xulong</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mahmut</forename><surname>Taylan Kandemir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meenakshi</forename><surname>Arunachalam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the ACM on Measurement and Analysis of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Clumsy Value Cache: An Approximate Memoization Technique for Mobile GPU Fragment Shaders</title>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Keramidas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chrysa</forename><surname>Kokkala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iakovos</forename><surname>Stamoulis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Approximate Computing (WAPCO)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">An Energy Efficient Approximate Adder with Carry Skip for Error Resilient Neuromorphic VLSI Systems</title>
		<author>
			<persName><forename type="first">Yongtae</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yong</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peng</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Int&apos;l. Conference on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page" from="130" to="137" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Data Access Skipping for Recursive Partitioning Methods</title>
		<author>
			<persName><forename type="first">Orhan</forename><surname>Kislal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mahmut</forename><forename type="middle">T</forename><surname>Kandemir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Systems &amp; Structures</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="143" to="162" />
			<date type="published" when="2018">2018. 2018</date>
			<publisher>Elsevier Computer Languages</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">IncApprox: A Data Analytics System for Incremental Approximate Computing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dhanya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Do</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pramod</forename><surname>Le Quoc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christof</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rodrigo</forename><surname>Fetzer</surname></persName>
		</author>
		<author>
			<persName><surname>Rodrigues</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Int&apos;l. Conference on World Wide Web</title>
		<imprint>
			<biblScope unit="page" from="1133" to="1144" />
			<date type="published" when="2016">2016</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Low-Power Multimedia System Design by Aggressive Voltage Scaling</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>Kurdahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kang</forename><surname>Eltawil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanley</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amin</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><surname>Khajeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="852" to="856" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">GPUMixer: Performance-Driven Floating-Point Tuning for GPU Scientific Applications</title>
		<author>
			<persName><forename type="first">Ignacio</forename><surname>Laguna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">C</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ranvijay</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saurabh</forename><surname>Bagchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISC Int&apos;l. Conference on High Performance Computing (HPC)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="227" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Fine-Grained Floating-Point Precision Analysis</title>
		<author>
			<persName><forename type="first">O</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">K</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><surname>Hollingsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SAGE Int&apos;l. Journal of High Performance Computing Applications</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="231" to="245" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Automatically Adapting Programs for Mixed-Precision Floating-Point Computation</title>
		<author>
			<persName><forename type="first">O</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">K</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><surname>Hollingsworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bronis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">P</forename><surname>De Supinski</surname></persName>
		</author>
		<author>
			<persName><surname>Legendre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Int&apos;l. Conference on Supercomputing (ICS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="369" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Early Accurate Results for Advanced Analytics on MapReduce</title>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Laptev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1028" to="1039" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">High-Level Synthesis of Approximate Hardware under Joint Precision and Voltage Scaling</title>
		<author>
			<persName><forename type="first">Seogoo</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lizy</forename><forename type="middle">K</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Gerstlauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="187" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Cooperative Arithmetic-Aware Approximation Techniques for Energy-Efficient Multipliers</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantinos</forename><surname>Asimakopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sotirios</forename><surname>Xydis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiamal</forename><surname>Pekmestzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Abdullah Hanif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giorgos</forename><surname>Armeniakos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xun</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiamal</forename><surname>Pekmestzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximate Computing Survey, Part II: Application-Specific &amp; Architectural Approximation Techniques and Applications</title>
		<imprint>
			<date type="published" when="2025">2025. 2025</date>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="1" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Improving Power of DSP and CNN Hardware Accelerators Using Approximate Floating-Point Multipliers</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Theodora</forename><surname>Paparouni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evangelos</forename><surname>Petrongonas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiamal</forename><surname>Pekmestzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Embedded Computing Systems</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1" to="21" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Exploiting the Potential of Approximate Arithmetic in DSP &amp; AI Hardware Accelerators</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiamal</forename><surname>Pekmestzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int&apos;l. Conference on Field-Programmable Logic and Applications (FPL)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="263" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Approximate Hybrid High Radix Encoding for Energy-Efficient Inexact Multipliers</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Zervakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiamal</forename><surname>Pekmestzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="421" to="430" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Walking through the Energy-Error Pareto Frontier of Approximate Multipliers</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Zervakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="40" to="49" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
	<note>Sotirios Xydis, Dimitrios Soudris, and Kiamal Pekmestzi</note>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Sculptor: Flexible Approximation with Selective Dynamic Loop Perforation</title>
		<author>
			<persName><forename type="first">Shikai</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sunghyun</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Mahlke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Int&apos;l. Conference on Supercomputing (ICS)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="341" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Eliminating Timing Errors Through Collaborative Design to Maximize the Throughput</title>
		<author>
			<persName><forename type="first">Zhan-Hui</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tao-Tao</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhi-Jian</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jian-Yi</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao-Yan</forename><surname>Xiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao-Lang</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="670" to="682" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">PredictiveNet: An Energy-Efficient Convolutional Neural Network via Zero Prediction</title>
		<author>
			<persName><forename type="first">Yingyan</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charbel</forename><surname>Sakr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongjune</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naresh</forename><surname>Shanbhag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Symposium on Circuits and Systems (ISCAS)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">Towards Program Optimization through Automated Analysis of Numerical Precision</title>
		<author>
			<persName><forename type="first">D</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Linderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">L</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Teresa</forename><forename type="middle">H</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Garry</forename><forename type="middle">P</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><surname>Nolan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Int&apos;l. Symposium on Code Generation and Optimization</title>
		<imprint>
			<biblScope unit="page" from="230" to="237" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Statistically Certified Approximate Logic Synthesis</title>
		<author>
			<persName><forename type="first">Gai</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiru</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Int&apos;l. Conference on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page" from="344" to="351" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Use of Imprecise Computation to Enhance Dependability of Real-Time Systems</title>
		<author>
			<persName><forename type="first">Jane Ws</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kwei-Jay</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Bettati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Springer Foundations of Dependable Computing</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="157" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Flikker: Saving DRAM Refresh-Power through Critical Data Partitioning</title>
		<author>
			<persName><forename type="first">Song</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karthik</forename><surname>Pattabiraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Moscibroda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">G</forename><surname>Zorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Int&apos;l. Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="213" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Combining Restoring Array and Logarithmic Dividers into an Approximate Hybrid Design</title>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jing</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tao</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chenghua</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Computer Arithmetic (ARITH)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="92" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Design of Approximate Radix-4 Booth Multipliers for Error-Tolerant Computing</title>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liangyu</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chenghua</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Honglan</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="page" from="1435" to="1441" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Design and Evaluation of Approximate Logarithmic Multipliers for Low Power Error-Tolerant Applications</title>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiahua</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danye</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chenghua</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems I: Regular Papers</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="page" from="2856" to="2868" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Computation Error Analysis in Digital Signal Processing Systems With Overscaled Supply Voltage</title>
		<author>
			<persName><forename type="first">Yang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tong</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshab</forename><forename type="middle">K</forename><surname>Parhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="517" to="526" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">AxMemo: Hardware-Compiler Co-Design for Approximate Code Memoization</title>
		<author>
			<persName><forename type="first">Zhenhong</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Yazdanbakhsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hadi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nam</forename><forename type="middle">Sung</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE Int&apos;l. Symposium on Computer Architecture (ISCA)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="685" to="697" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Workload-Aware Approximate Computing Configuration</title>
		<author>
			<persName><forename type="first">Dongning</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rahul</forename><surname>Thapa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xingjian</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xun</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cong</forename><surname>Hao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="920" to="925" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">DEVoT: Dynamic Delay Modeling of Functional Units Under Voltage and Temperature Variations</title>
		<author>
			<persName><forename type="first">Dongning</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xinqiao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ke</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wanli</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xun</forename><surname>Jiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="827" to="839" />
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">Design of Approximate Booth Squarer for Error-Tolerant Computing</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Manikantta</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Vasantha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">B</forename><surname>Nithin Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Devesh</forename><surname>Dwivedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1230" to="1241" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<monogr>
		<title level="m" type="main">Venture: A Higher-Order Probabilistic Programming Platform with Programmable Inference</title>
		<author>
			<persName><forename type="first">K</forename><surname>Vikash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daneil</forename><surname>Mansinghka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yura</forename><forename type="middle">N</forename><surname>Selsam</surname></persName>
		</author>
		<author>
			<persName><surname>Perov</surname></persName>
		</author>
		<idno>CoRR abs/1404.0099</idno>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="1" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">Best-Effort Parallel Execution Framework for Recognition and Mining Applications</title>
		<author>
			<persName><forename type="first">Jiayuan</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srimat</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Symposium on Parallel Distributed Processing (IPDPS)</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Exploiting the Forgiving Nature of Applications for Scalable Parallel Execution</title>
		<author>
			<persName><forename type="first">Jiayuan</forename><surname>Mengt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srimat</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Surendra</forename><surname>Byna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Symposium on Parallel Distributed Processing (IPDPS)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">ADAPT: Algorithmic Differentiation Applied to Floating-Point Precision Tuning</title>
		<author>
			<persName><forename type="first">Harshitha</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">O</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Osei-Kuffuor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Schordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathryn</forename><surname>Mohror</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Hittinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE SC, Int&apos;l. Conference for High Performance Computing, Networking, Storage and Analysis</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="614" to="626" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Approximate Logic Synthesis under General Error Magnitude and Frequency Constraints</title>
		<author>
			<persName><forename type="first">Jin</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Gerstlauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Orshansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Int&apos;l. Conference on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page" from="779" to="786" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">Load Value Approximation</title>
		<author>
			<persName><forename type="first">Joshua</forename><surname>San</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miguel</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Badr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Natalie</forename><forename type="middle">Enright</forename><surname>Jerger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Int&apos;l. Symposium on Microarchitecture</title>
		<imprint>
			<biblScope unit="page" from="127" to="139" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">Chisel: Reliability-and Accuracy-Aware Optimization of Approximate Computational Kernels</title>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sara</forename><surname>Achour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zichao</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Int&apos;l. Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="309" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">Parallelizing Sequential Programs with Statistical Accuracy Tests</title>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deokhwan</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Embedded Computing Systems</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="26" />
			<date type="published" when="2013">2013. 2s (2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<analytic>
		<title level="a" type="main">Quality of Service Profiling</title>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stelios</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE Int&apos;l. Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<analytic>
		<title level="a" type="main">Dancing with Uncertainty</title>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stelios</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Workshop on Relaxing Synchronization for Multicore and Manycore Scalability (RACES)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="51" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<analytic>
		<title level="a" type="main">iACT: A Software-Hardware Framework for Understanding the Scope of Approximate Computing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Asit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajkishore</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Somnath</forename><surname>Barik</surname></persName>
		</author>
		<author>
			<persName><surname>Paul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Approximate Computing Across the System Stack</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title level="a" type="main">Computer Multiplication and Division Using Binary Logarithms</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">N</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRE Trans. on Electronic Computers EC</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="512" to="517" />
			<date type="published" when="1962">1962. 1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<analytic>
		<title level="a" type="main">Phase-Aware Optimization in Approximate Computing</title>
		<author>
			<persName><forename type="first">Subrata</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manish</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saurabh</forename><surname>Bagchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Int&apos;l. Symposium on Code Generation and Optimization</title>
		<imprint>
			<biblScope unit="page" from="185" to="196" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<analytic>
		<title level="a" type="main">A Survey of Techniques for Approximate Computing</title>
		<author>
			<persName><forename type="first">Sparsh</forename><surname>Mittal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">Design of Voltage-Scalable Meta-Functions for Approximate Computing</title>
		<author>
			<persName><forename type="first">Debabrata</forename><surname>Mohapatra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vinay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Chippa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaushik</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design</title>
		<meeting><address><addrLine>Europe (DATE</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b128">
	<analytic>
		<title level="a" type="main">Design and Analysis of Approximate Compressors for Multiplication</title>
		<author>
			<persName><forename type="first">Amir</forename><surname>Momeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Montuschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="984" to="994" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<analytic>
		<title level="a" type="main">Cramming More Components onto Integrated Circuits</title>
		<author>
			<persName><forename type="first">Gordon</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Solid-State Circuits Society Newsletter</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="1965">1965. 1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<analytic>
		<title level="a" type="main">A Taxonomy of General Purpose Approximate Computing Techniques</title>
		<author>
			<persName><forename type="first">Thierry</forename><surname>Moreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">San</forename><surname>Miguel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Wyse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Bornholt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Armin</forename><surname>Alaghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Natalie</forename><forename type="middle">Enright</forename><surname>Jerger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Sampson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Embedded Systems Letters</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="2" to="5" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">EvoApprox8b: Library of Approximate Adders and Multipliers for Circuit Design and Benchmarking of Approximation Methods</title>
		<author>
			<persName><forename type="first">Vojtech</forename><surname>Mrazek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radek</forename><surname>Hrbacek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zdenek</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukas</forename><surname>Sekanina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="258" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<analytic>
		<title level="a" type="main">Automated High-Level Generation of Low-Power Approximate Computing Circuits</title>
		<author>
			<persName><forename type="first">Kumud</forename><surname>Nepal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soheil</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Iris</forename><surname>Hokchhay Tann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherief</forename><surname>Bahar</surname></persName>
		</author>
		<author>
			<persName><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Emerging Topics in Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="18" to="30" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b133">
	<analytic>
		<title level="a" type="main">ABACUS: A Technique for Automated Behavioral Synthesis of Approximate Computing Circuits</title>
		<author>
			<persName><forename type="first">Kumud</forename><surname>Nepal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yueting</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Iris</forename><surname>Bahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherief</forename><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b134">
	<analytic>
		<title level="a" type="main">GraphTuner: An Input Dependence Aware Loop Perforation Scheme for Efficient Execution of Approximated Graph Algorithms</title>
		<author>
			<persName><forename type="first">Hamza</forename><surname>Omar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masab</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omer</forename><surname>Khan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Conference on Computer Design (ICCD)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="201" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b135">
	<analytic>
		<title level="a" type="main">GreenTPU: Improving Timing Error Resilience of a Near-Threshold Tensor Processing Unit</title>
		<author>
			<persName><forename type="first">Pramesh</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prabal</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanghamitra</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b136">
	<analytic>
		<title level="a" type="main">FlexJava: Language Support for Safe and Modular Approximate Programming</title>
		<author>
			<persName><forename type="first">Jongse</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hadi</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Harris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGSOFT Symposium and European Conference on Foundations of Software Engineering (FSE)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="745" to="757" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b137">
	<monogr>
		<title level="m" type="main">ExpAX: A Framework for Automating Approximate Programming</title>
		<author>
			<persName><forename type="first">Jongse</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kangqi</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hadi</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
		<idno>GT-CS-14-05</idno>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
		<respStmt>
			<orgName>Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b138">
	<analytic>
		<title level="a" type="main">BlinkML: Efficient Maximum Likelihood Estimation with Probabilistic Guarantees</title>
		<author>
			<persName><forename type="first">Yongjoo</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jingyi</forename><surname>Qing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaoyang</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barzan</forename><surname>Mozafari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGMOD Int&apos;l. Conference on Management of Data (MOD</title>
		<imprint>
			<biblScope unit="page" from="1135" to="1152" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b139">
	<analytic>
		<title level="a" type="main">Approximate Reverse Carry Propagate Adder for Energy-Efficient DSP Applications</title>
		<author>
			<persName><forename type="first">Masoud</forename><surname>Pashaeifar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massoud</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="2530" to="2541" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b140">
	<monogr>
		<title level="m" type="main">Failure-Tolerant Computer Design</title>
		<author>
			<persName><forename type="first">H</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Academic Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b141">
	<analytic>
		<title level="a" type="main">A Two-Stage Operand Trimming Approximate Logarithmic Multiplier</title>
		<author>
			<persName><forename type="first">Ratko</forename><surname>Pilipović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patricio</forename><surname>Bulić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uroš</forename><surname>Lotrič</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems I: Regular Papers</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="2535" to="2545" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b142">
	<monogr>
		<title level="m" type="main">Computers May Need More Power than the World Can Generate by</title>
		<author>
			<persName><surname>Powermag</surname></persName>
		</author>
		<ptr target="https://www.powermag.com/computers-may-need-more-power-than-the-world-can-generate-by-2040/" />
		<imprint>
			<date type="published" when="2016">2016. 2040</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b143">
	<analytic>
		<title level="a" type="main">PrivApprox: Privacy-Preserving Stream Analytics</title>
		<author>
			<persName><forename type="first">Le</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Quoc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pramod</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruichuan</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christof</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Fetzer</surname></persName>
		</author>
		<author>
			<persName><surname>Strufe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference (ATC)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="659" to="672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b144">
	<analytic>
		<title level="a" type="main">StreamApprox: Approximate Computing for Stream Analytics</title>
		<author>
			<persName><forename type="first">Le</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruichuan</forename><surname>Quoc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pramod</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christof</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName><surname>Fetzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Volker Hilt</surname></persName>
		</author>
		<author>
			<persName><surname>Strufe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IFIP/USENIX Int&apos;l. Middleware Conference</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="185" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b145">
	<analytic>
		<title level="a" type="main">Pushing the Limits of Voltage Over-Scaling for Error-Resilient Applications</title>
		<author>
			<persName><forename type="first">Rengarajan</forename><surname>Ragavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Barrois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cedric</forename><surname>Killian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Sentieys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="476" to="481" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b146">
	<analytic>
		<title level="a" type="main">Adaptive Overclocking and Error Correction Based on Dynamic Speculation Window</title>
		<author>
			<persName><forename type="first">Rengarajan</forename><surname>Ragavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cedric</forename><surname>Killian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Sentieys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Society Annual Symposium on VLSI (ISVLSI)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="325" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b147">
	<analytic>
		<title level="a" type="main">qLUT: Input-Aware Quantized Table Lookup for Energy-Efficient Approximate Accelerators</title>
		<author>
			<persName><forename type="first">Arnab</forename><surname>Raha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Embedded Computing Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">23</biblScope>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b148">
	<analytic>
		<title level="a" type="main">Quality Configurable Reduce-and-Rank for Energy Efficient Approximate Computing</title>
		<author>
			<persName><forename type="first">Arnab</forename><surname>Raha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swagath</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="665" to="670" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b149">
	<analytic>
		<title level="a" type="main">Spatial Memoization: Concurrent Instruction Reuse to Correct Timing Errors in SIMD Architectures</title>
		<author>
			<persName><forename type="first">Abbas</forename><surname>Rahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Benini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajesh</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="847" to="851" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
	<note>Express Briefs</note>
</biblStruct>

<biblStruct xml:id="b150">
	<analytic>
		<title level="a" type="main">Relax-and-Retime: A Methodology for Energy-Efficient Recovery Based Design</title>
		<author>
			<persName><forename type="first">Swagath</forename><surname>Shankar Ganesh Ramasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adithya</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Parandhaman</surname></persName>
		</author>
		<author>
			<persName><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b151">
	<analytic>
		<title level="a" type="main">ASLAN: Synthesis of Approximate Sequential Circuits</title>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Ranjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnab</forename><surname>Raha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swagath</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaushik</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b152">
	<analytic>
		<title level="a" type="main">Programming with Relaxed Synchronization</title>
		<author>
			<persName><forename type="first">Lakshminarayanan</forename><surname>Renganarayana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijayalakshmi</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ravi</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Prener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Workshop on Relaxing Synchronization for Multicore and Manycore Scalability (RACES)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b153">
	<analytic>
		<title level="a" type="main">Probabilistic Accuracy Bounds for Fault-Tolerant Computations That Discard Tasks</title>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Int&apos;l. Conference on Supercomputing (ICS)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="324" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b154">
	<analytic>
		<title level="a" type="main">Using Early Phase Termination to Eliminate Load Imbalances at Barrier Synchronization Points</title>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Int&apos;l. Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="369" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b155">
	<analytic>
		<title level="a" type="main">Unsynchronized Techniques for Approximate Parallel Computing</title>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Workshop on Relaxing Synchronization for Multicore and Manycore Scalability (RACES)</title>
		<imprint>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b156">
	<analytic>
		<title level="a" type="main">Predicting Timing Violations through Instruction-Level Path Sensitization Analysis</title>
		<author>
			<persName><forename type="first">Sanghamitra</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Chakraborty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1074" to="1081" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b157">
	<analytic>
		<title level="a" type="main">Floating-Point Precision Tuning Using Blame Analysis</title>
		<author>
			<persName><forename type="first">Cindy</forename><surname>Rubio-González</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cuong</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Mehne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Demmel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Kahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Costin</forename><surname>Iancu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Lavrijsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">H</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Hough</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Int&apos;l. Conference on Software Engineering</title>
		<imprint>
			<biblScope unit="page" from="1074" to="1085" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b158">
	<analytic>
		<title level="a" type="main">Precimonious: Tuning Assistant for Floating-Point Precision</title>
		<author>
			<persName><forename type="first">Cindy</forename><surname>Rubio-González</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cuong</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hong</forename><surname>Diep Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Demmel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Kahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">H</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Costin</forename><surname>Iancu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Hough</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC13: Int&apos;l. Conference on High Performance Computing, Networking, Storage and Analysis</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b159">
	<analytic>
		<title level="a" type="main">REALM: Reduced-Error Approximate Log-based Integer Multiplier</title>
		<author>
			<persName><forename type="first">Hassaan</forename><surname>Saadat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haris</forename><surname>Javaid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1366" to="1371" />
		</imprint>
	</monogr>
	<note>Aleksandar Ignjatovic, and Sri Parameswaran</note>
</biblStruct>

<biblStruct xml:id="b160">
	<analytic>
		<title level="a" type="main">Approximate Integer and Floating-Point Dividers with Near-Zero Error Bias</title>
		<author>
			<persName><forename type="first">Hassaan</forename><surname>Saadat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haris</forename><surname>Javaid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sri</forename><surname>Parameswaran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b161">
	<analytic>
		<title level="a" type="main">A Majority-Based Imprecise Multiplier for Ultra-Efficient Approximate Image Multiplication</title>
		<author>
			<persName><forename type="first">Farnaz</forename><surname>Sabetzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Hossein Moaiyeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Ahmadinejad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems I: Regular Papers</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="page" from="4200" to="4208" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b162">
	<analytic>
		<title level="a" type="main">Paraprox: Pattern-Based Approximation for Data Parallel Applications</title>
		<author>
			<persName><forename type="first">Mehrzad</forename><surname>Samadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davoud</forename><forename type="middle">Anoushe</forename><surname>Jamshidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janghaeng</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Mahlke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Int&apos;l. Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="35" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b163">
	<analytic>
		<title level="a" type="main">SAGE: Self-Tuning Approximation for Graphics Engines</title>
		<author>
			<persName><forename type="first">Mehrzad</forename><surname>Samadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janghaeng</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Anoushe</forename><surname>Jamshidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Hormati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Mahlke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Int&apos;l. Symposium on Microarchitecture</title>
		<imprint>
			<biblScope unit="page" from="13" to="24" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b164">
	<monogr>
		<title level="m" type="main">Hardware and Software for Approximate Programming</title>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Sampson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="1" to="212" />
		</imprint>
		<respStmt>
			<orgName>University of Washington PhD Dissertation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b165">
	<monogr>
		<title level="m" type="main">AC-CEPT: A Programmer-Guided Compiler Framework for Practical Approximate Computing</title>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">André</forename><surname>Baixo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Ransford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thierry</forename><surname>Moreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joshua</forename><surname>Yip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Oskin</surname></persName>
		</author>
		<idno>UW-CSE-15-01-01</idno>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
		<respStmt>
			<orgName>University of Washington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b166">
	<analytic>
		<title level="a" type="main">EnerJ: Approximate Data Types for Safe and General Low-Power Computation</title>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Dietl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emily</forename><surname>Fortuna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danushen</forename><surname>Gnanapragasam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="164" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b167">
	<analytic>
		<title level="a" type="main">Expressing and Verifying Probabilistic Assertions</title>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavel</forename><surname>Panchekha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Mytkowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathryn</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="112" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b168">
	<analytic>
		<title level="a" type="main">Approximate Logic Synthesis: A Survey</title>
		<author>
			<persName><forename type="first">Ilaria</forename><surname>Scarabottolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Ansaloni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">A</forename><surname>Constantinides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laura</forename><surname>Pozzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherief</forename><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="2195" to="2213" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b169">
	<analytic>
		<title level="a" type="main">Circuit Carving: A Methodology for the Design of Approximate Hardware</title>
		<author>
			<persName><forename type="first">Ilaria</forename><surname>Scarabottolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Ansaloni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laura</forename><surname>Pozzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="545" to="550" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b170">
	<analytic>
		<title level="a" type="main">Stochastic Optimization of Floating-Point Programs with Tunable Precision</title>
		<author>
			<persName><forename type="first">Eric</forename><surname>Schkufza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rahul</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="53" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b171">
	<analytic>
		<title level="a" type="main">Design and Applications of Approximate Circuits by Gate-Level Pruning</title>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Schlachter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Camus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krishna</forename><forename type="middle">V</forename><surname>Palem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Enz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1694" to="1702" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b172">
	<analytic>
		<title level="a" type="main">Approximate Circuit Design by Means of Evolvable Hardware</title>
		<author>
			<persName><forename type="first">Lukas</forename><surname>Sekanina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zdenek</forename><surname>Vasicek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Conference on Evolvable Systems (ICES)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="21" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b173">
	<analytic>
		<title level="a" type="main">A Low Latency Generic Accuracy Configurable Adder</title>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Waqas</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rehan</forename><surname>Hafiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b174">
	<analytic>
		<title level="a" type="main">Cross-Layer Approximate Computing: From Logic to Architectures</title>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shafique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rehan</forename><surname>Hafiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semeen</forename><surname>Rehman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Walaa</forename><surname>El-Harouni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b175">
	<analytic>
		<title level="a" type="main">Accuracy-Performance Tradeoffs on an FPGA through Overclocking</title>
		<author>
			<persName><forename type="first">Kan</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Boland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">A</forename><surname>Constantinides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Symposium on Field-Programmable Custom Computing Machines (FCCM)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="29" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b176">
	<analytic>
		<title level="a" type="main">Datapath Synthesis for Overclocking: Online Arithmetic for Latency-Accuracy Trade-offs</title>
		<author>
			<persName><forename type="first">Kan</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Boland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><surname>Stott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Bayliss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">A</forename><surname>Constantinides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b177">
	<analytic>
		<title level="a" type="main">A Cross-Layer Multicore Architecture to Tradeoff Program Accuracy and Resilience Overheads</title>
		<author>
			<persName><forename type="first">Qingchuan</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omer</forename><surname>Khan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="85" to="89" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b178">
	<analytic>
		<title level="a" type="main">Managing Performance vs. Accuracy Trade-Offs with Loop Perforation</title>
		<author>
			<persName><forename type="first">Stelios</forename><surname>Sidiroglou-Douskos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGSOFT Symposium and European Conference on Foundations of Software Engineering (FSE)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="124" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b179">
	<analytic>
		<title level="a" type="main">Eon: A Language and Runtime System for Perpetual Systems</title>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Sorber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Kostadinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Garber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Brennan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">D</forename><surname>Corner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Int&apos;l. Conference on Embedded Networked Sensor Systems (SenSys)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="161" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b180">
	<analytic>
		<title level="a" type="main">Exploiting Approximate Value Locality for Data Synchronization on Multi-Core Processors</title>
		<author>
			<persName><forename type="first">Jaswanth</forename><surname>Sreeram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santosh</forename><surname>Pande</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Symposium on Workload Characterization (IISWC)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b181">
	<analytic>
		<title level="a" type="main">Exploiting Errors for Efficiency: A Survey from Circuits to Applications</title>
		<author>
			<persName><forename type="first">Phillip</forename><surname>Stanley-Marbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="1" to="39" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b182">
	<analytic>
		<title level="a" type="main">PANDORA: An Architecture-Independent Parallelizing Approximation-Discovery Framework</title>
		<author>
			<persName><forename type="first">Greg</forename><surname>Stitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Campbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Embedded Computing Systems</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b183">
	<analytic>
		<title level="a" type="main">Comparison and Extension of Approximate 4-2 Compressors for Low-Power Approximate Multipliers</title>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Giuseppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maria</forename><surname>Strollo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ettore</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><forename type="middle">De</forename><surname>Caro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Petra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gennaro</forename><surname>Di</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meo</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems I: Regular Papers</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="3021" to="3034" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b184">
	<analytic>
		<title level="a" type="main">Approximation-Aware Scheduling on Heterogeneous Multi-Core Architectures</title>
		<author>
			<persName><forename type="first">Cheng</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thannirmalai</forename><surname>Somu Muthukaruppan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tulika</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ju</forename><surname>Lei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asia and South Pacific Design Automation Conference (ASP-DAC</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="618" to="623" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b185">
	<analytic>
		<title level="a" type="main">ApproxMA: Approximate Memory Access for Dynamic Precision Scaling</title>
		<author>
			<persName><forename type="first">Ye</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ting</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Great Lakes Symposium on VLSI (GLSVLSI)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="337" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b186">
	<analytic>
		<title level="a" type="main">Design and Implementation of Probabilistic Programming Language Anglican</title>
		<author>
			<persName><forename type="first">David</forename><surname>Tolpin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan-Willem</forename><surname>Van De Meent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongseok</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Implementation and Application of Functional Programming Languages (IFL</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b187">
	<analytic>
		<title level="a" type="main">Temporal Approximate Function Memoization</title>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Tziantzioulis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikos</forename><surname>Hardavellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simone</forename><surname>Campanoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="60" to="70" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b188">
	<analytic>
		<title level="a" type="main">SMApproxLib: Library of FPGA-based Approximate Multipliers</title>
		<author>
			<persName><forename type="first">Salim</forename><surname>Ullah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjeev</forename><surname>Sripadraj Murthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Akash</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b189">
	<analytic>
		<title level="a" type="main">TOSAM: An Energy-Efficient Truncation-and Rounding-Based Scalable Approximate Multiplier</title>
		<author>
			<persName><forename type="first">Shaghayegh</forename><surname>Vahdat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massoud</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1161" to="1173" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b190">
	<analytic>
		<title level="a" type="main">TruncApp: A Truncation-Based Approximate Divider for Energy Efficient DSP Applications</title>
		<author>
			<persName><forename type="first">Shaghayegh</forename><surname>Vahdat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massoud</forename><surname>Pedram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zainalabedin</forename><surname>Navabi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1635" to="1638" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b191">
	<analytic>
		<title level="a" type="main">Automated Circuit Approximation Method Driven by Data Distribution</title>
		<author>
			<persName><forename type="first">Zdenek</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vojtech</forename><surname>Mrazek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukas</forename><surname>Sekanina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="96" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b192">
	<analytic>
		<title level="a" type="main">Evolutionary Approach to Approximate Digital Circuits Design</title>
		<author>
			<persName><forename type="first">Zdenek</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukas</forename><surname>Sekanina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="432" to="444" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b193">
	<analytic>
		<title level="a" type="main">Search-based Synthesis of Approximate Circuits Implemented into FPGAs</title>
		<author>
			<persName><forename type="first">Zdenek</forename><surname>Vasicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukas</forename><surname>Sekanina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int&apos;l. Conference on Field Programmable Logic and Applications (FPL)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b194">
	<analytic>
		<title level="a" type="main">A Programming Model and Runtime System for Significance-Aware Energy-Efficient Computing</title>
		<author>
			<persName><forename type="first">Vassilis</forename><surname>Vassiliadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantinos</forename><surname>Parasyris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charalambos</forename><surname>Chalios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><forename type="middle">D</forename><surname>Antonopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Spyros</forename><surname>Lalis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolaos</forename><surname>Bellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans</forename><surname>Vandierendonck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><forename type="middle">S</forename><surname>Nikolopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="275" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b195">
	<analytic>
		<title level="a" type="main">Towards Automatic Significance Analysis for Approximate Computing</title>
		<author>
			<persName><forename type="first">Vassilis</forename><surname>Vassiliadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Riehme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Deussen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantinos</forename><surname>Parasyris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><forename type="middle">D</forename><surname>Antonopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Nikolaos Bellas, Spyros Lalis, and Uwe Naumann</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="182" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b196">
	<analytic>
		<title level="a" type="main">Design and Analysis of Area and Power Efficient Approximate Booth Multipliers</title>
		<author>
			<persName><forename type="first">Suganthi</forename><surname>Venkatachalam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elizabeth</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyuk</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Jae</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seok-Bum</forename><surname>Ko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="1697" to="1703" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b197">
	<analytic>
		<title level="a" type="main">Efficient AI System Design With Cross-Layer Approximate Computing</title>
		<author>
			<persName><forename type="first">Swagath</forename><surname>Venkataramani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="2232" to="2250" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b198">
	<analytic>
		<title level="a" type="main">Approximate Computing and the Quest for Computing Efficiency</title>
		<author>
			<persName><forename type="first">Swagath</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Srimat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaushik</forename><surname>Chakradhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b199">
	<analytic>
		<title level="a" type="main">Substitute-and-Simplify: A Unified Design Paradigm for Approximate and Quality Configurable Circuits</title>
		<author>
			<persName><forename type="first">Swagath</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaushik</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1367" to="1372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b200">
	<analytic>
		<title level="a" type="main">SALSA: Systematic Logic Synthesis of Approximate Circuits</title>
		<author>
			<persName><forename type="first">Swagath</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sabne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vivek</forename><surname>Kozhikkottu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaushik</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="796" to="801" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b201">
	<analytic>
		<title level="a" type="main">Enabling Energy-Efficient and Reliable Neural Network via Neuron-Level Voltage Scaling</title>
		<author>
			<persName><forename type="first">Jing</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shubo</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lan</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weigong</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="page" from="1460" to="1473" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b202">
	<analytic>
		<title level="a" type="main">Resilience-Aware Frequency Tuning for Neural-Network-Based Approximate Computing Chips</title>
		<author>
			<persName><forename type="first">Ying</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiachao</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuntan</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huawei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaowei</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2736" to="2748" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b203">
	<analytic>
		<title level="a" type="main">Hybrid Low Radix Encoding-Based Approximate Booth Multipliers</title>
		<author>
			<persName><forename type="first">Haroon</forename><surname>Waris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chenghua</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="3367" to="3371" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
	<note>Express Briefs</note>
</biblStruct>

<biblStruct xml:id="b204">
	<analytic>
		<title level="a" type="main">AxBMs: Approximate Radix-8 Booth Multipliers for High-Performance FPGA-Based Accelerators</title>
		<author>
			<persName><forename type="first">Haroon</forename><surname>Waris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chenghua</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiqiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="1566" to="1570" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
	<note>Express Briefs</note>
</biblStruct>

<biblStruct xml:id="b205">
	<analytic>
		<title level="a" type="main">ApproxIoT: Approximate Analytics for Edge Computing</title>
		<author>
			<persName><forename type="first">Zhenyu</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Do</forename><surname>Le Quoc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pramod</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruichuan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Myungjin</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Conference on Distributed Computing Systems (ICDCS)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="411" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b206">
	<analytic>
		<title level="a" type="main">Approximate Computing: A Survey</title>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Mytkowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nam</forename><forename type="middle">Sung</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Design &amp; Test</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="8" to="22" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b207">
	<analytic>
		<title level="a" type="main">A Simple Yet Efficient Accuracy-Configurable Adder Design</title>
		<author>
			<persName><forename type="first">Wenbin</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sachin</forename><forename type="middle">S</forename><surname>Sapatnekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiang</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1112" to="1125" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b208">
	<analytic>
		<title level="a" type="main">Approximate XOR/XNOR-Based Adders for Inexact Computing</title>
		<author>
			<persName><forename type="first">Zhixi</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ajaypat</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinghang</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabrizio</forename><surname>Lombardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int&apos;l. Conference on Nanotechnology</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="690" to="693" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b209">
	<analytic>
		<title level="a" type="main">Axilog: Language Support for Approximate Hardware Design</title>
		<author>
			<persName><forename type="first">Amir</forename><surname>Yazdanbakhsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design</title>
		<meeting><address><addrLine>Europe (DATE</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="812" to="817" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b210">
	<analytic>
		<title level="a" type="main">RFVP: Rollback-Free Value Prediction with Safe-to-Approximate Loads</title>
		<author>
			<persName><forename type="first">Amir</forename><surname>Yazdanbakhsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gennady</forename><surname>Pekhimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bradley</forename><surname>Thwaites</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hadi</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Architecture and Code Optimization</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="26" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b211">
	<analytic>
		<title level="a" type="main">On Reconfiguration-Oriented Approximate Adder Design and Its Application</title>
		<author>
			<persName><forename type="first">Rong</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ting</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Int&apos;l. Conference on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page" from="48" to="54" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b212">
	<analytic>
		<title level="a" type="main">Toward Dynamic Precision Scaling</title>
		<author>
			<persName><forename type="first">Serif</forename><surname>Yesil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ismail</forename><surname>Akturk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulya</forename><forename type="middle">R</forename><surname>Karpuzcu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="30" to="39" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b213">
	<analytic>
		<title level="a" type="main">RoBA Multiplier: A Rounding-Based Approximate Multiplier for High-Speed yet Energy-Efficient Digital Signal Processing</title>
		<author>
			<persName><forename type="first">Reza</forename><surname>Zendegani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Milad</forename><surname>Bahadori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massoud</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="393" to="401" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b214">
	<analytic>
		<title level="a" type="main">SEERAD: A High Speed yet Energy-Efficient Rounding-Based Approximate Divider</title>
		<author>
			<persName><forename type="first">Reza</forename><surname>Zendegani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arash</forename><surname>Fayyazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Afzali-Kusha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saeed</forename><surname>Safari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massoud</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1481" to="1484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b215">
	<analytic>
		<title level="a" type="main">VOSsim: A Framework for Enabling Fast Voltage Overscaling Simulation for Approximate Computing Circuits</title>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Zervakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fotios</forename><surname>Ntouskas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sotirios</forename><surname>Xydis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiamal</forename><surname>Pekmestzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1204" to="1208" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b216">
	<analytic>
		<title level="a" type="main">Multi-Level Approximate Accelerator Synthesis Under Voltage Island Constraints</title>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Zervakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sotirios</forename><surname>Xydis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Soudris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiamal</forename><surname>Pekmestzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="607" to="611" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
	<note>Express Briefs</note>
</biblStruct>

<biblStruct xml:id="b217">
	<analytic>
		<title level="a" type="main">Leveraging Hardware Caches for Memoization</title>
		<author>
			<persName><forename type="first">Guowei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Sanchez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="59" to="63" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b218">
	<analytic>
		<title level="a" type="main">ThUnderVolt: Enabling Aggressive Voltage Underscaling and Timing Error Resilience for Energy Efficient Deep Learning Accelerators</title>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kartheek</forename><surname>Rangineni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zahra</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siddharth</forename><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b219">
	<analytic>
		<title level="a" type="main">ApproxANN: An Approximate Computing Framework for Artificial Neural Network</title>
		<author>
			<persName><forename type="first">Qian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ting</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ye</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe (DATE)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="701" to="706" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b220">
	<analytic>
		<title level="a" type="main">Sapprox: Enabling Efficient and Accurate Approximations on Sub-Datasets with Distribution-Aware Online Sampling</title>
		<author>
			<persName><forename type="first">Xuhong</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiangling</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="109" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b221">
	<analytic>
		<title level="a" type="main">Design of Approximate Radix-256 Booth Encoding for Error-Tolerant Computing</title>
		<author>
			<persName><forename type="first">Feiyu</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shaowei</forename><surname>Zhen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xilin</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haoran</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bowen</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yajuan</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="2286" to="2290" />
			<date type="published" when="2022-07-18">2022. 2022. 18 July 2023. 13 September 2024. 4 February 2025. March 2025</date>
		</imprint>
	</monogr>
	<note>Express Briefs Received Published 5</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
