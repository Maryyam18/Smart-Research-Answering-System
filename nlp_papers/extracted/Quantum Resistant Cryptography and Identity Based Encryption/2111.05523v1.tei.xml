<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Anonymous communication system provides a secure environment without leaking metadata, which has many application scenarios in IoT</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2021-11-10">10 Nov 2021</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ngoc</forename><forename type="middle">Ai</forename><surname>Van Nguyen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Physics</orgName>
								<orgName type="institution" key="instit1">University of Information Technology</orgName>
								<orgName type="institution" key="instit2">Vietnam National University</orgName>
								<address>
									<settlement>Ho Chi Minh city</settlement>
									<country key="VN">Vietnam</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Minh</forename><surname>Thuy</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Truc</forename><surname>Pham</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Institute of Cybersecurity and Cryptology School of Computing and Information Technology</orgName>
								<orgName type="institution">University of Wollongong</orgName>
								<address>
									<addrLine>Northfields Avenue</addrLine>
									<postCode>2522</postCode>
									<settlement>Wollongong</settlement>
									<region>NSW</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Anonymous communication system provides a secure environment without leaking metadata, which has many application scenarios in IoT</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2021-11-10">10 Nov 2021</date>
						</imprint>
					</monogr>
					<idno type="MD5">F4B1BBD876406A3A31554798EB39BA3D</idno>
					<idno type="arXiv">arXiv:2111.05523v1[cs.CR]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2" ident="GROBID" when="2025-11-28T12:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<label type="revision">a91ee48</label>
					<label type="parameters">startPage=-1, endPage=-1, consolidateCitations=0, consolidateHeader=0, consolidateFunders=0, includeRawAffiliations=false, includeRawCitations=false, includeRawCopyrights=false, generateTeiIds=false, generateTeiCoordinates=[], sentenceSegmentation=false, flavor=null</label>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Anonymous Identity Based Encryption (AIBET) scheme allows a tracer to use the tracing key to reveal the recipient's identity from the ciphertext while keeping other data anonymous. This special feature makes AIBET a promising solution to distributed IoT data security. In this paper, we construct an efficient quantum-safe Hierarchical Identity-Based cryptosystem with Traceable Identities (AHIBET) with fully anonymous ciphertexts. We prove the security of the AHIBET scheme under the Learning with Errors (LWE) problem in the standard model.</p><p>* Oracle O TskGen (id) takes input an identity id different from id * , returns the output of TskGen(MPK, MSK, id).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Internet of Things (IoT) has emerged as a set of interconnected technologies like Wireless Sensors Networks (WSN) and Radio Frequency Identification (RFID), that provide identification, computation, and mutual information exchange among the connected devices all over the world. The key idea of the IoT is to obtain information about our environment to understand and control and act on it <ref type="bibr" target="#b10">[DMR16]</ref>.</p><p>Identity-Based Encryption (IBE) is a type of public-key encryption where the public key is an arbitrary string that uniquely defined the user (for example an email address or a telephone number). The Private-key Generator (PKG) who has knowledge of a master secret key generates the private key for the corresponding identities. This concept was first introduced by Shamir [Sha84] and then in 2001, Boneh and Franklin <ref type="bibr" target="#b5">[BF01]</ref> proposed the first practical IBE scheme based on bilinear map. The idea of Hierarchical Identity-Based Encryption (HIBE), which is an extension of IBE where each level can issue private keys for identites of the next level, was first proposed in the work of Gentry and Silverberg [GS02]. Since then, there have been many efficient constructions of HIBE, ranging from classical setting [BB04, <ref type="bibr" target="#b3">BBG05,</ref><ref type="bibr">Wat05]</ref> to post-quantum setting [ABB10a,CHKP10,SRB14] just to name a few.</p><p>The concept of "Anonymous" IBE offers an additional privacy guarantee to standard IBE schemes where the ciphertexts do not leak the identity of the recipients. AIBE is a promising solution to anonymous communications and it can be applied to many realistic scenarios that provide privacy-preserving and security under cloud environment. It can also bring a secure environment without leaking metadata which has many application scenarios in the aforementioned distributed IoT system [JLL + 18]. However, the first AIBE construction of Boneh and Frankl in <ref type="bibr" target="#b5">[BF01]</ref> is just anonymous in the random oracle model and it was a challenging problem to achieve anonymous IBE in the standard model until <ref type="bibr" target="#b8">[BW06b]</ref>. In [BW06a], Boyen and Waters proposed the first secure anonymous HIBE scheme without random oracles. More recently, the HIBE constructions in the post-quantum setting [ABB10a,SRB14] are proven to be anonymous secure in the standard model in the mean of a ciphertext encrypted for a target identity is indistinguishable from a random element in the ciphertext space which helps hide this identity from any malicious attacker.</p><p>Although this strong unconditional privacy seems very attractive from the user's point of view, it can potentially be a dangerous tool against public safety if there is no way to revoke such privacy when illegal behavior is detected. For example, in the case where the email filtering system has to filter out all encrypted email from members are suspected of illegal activity, standard anonymous IBE and HIBE prevent the system reveal the recipients of those ciphertexts. Traceability can provide a solution to this problem in which an additional traceability function can detect specific identities in ciphertexts and all the others remain anonymous.</p><p>In 2019, Blazy et al. <ref type="bibr" target="#b4">[BBP19]</ref> first considered the traceability for identity-based encryption and constructed an Anonymous Identity Based Encryption (AIBET) scheme in the standard model but under the matrix Diffie Hellman (MDDH) assumption. Two security notions are formally defined in <ref type="bibr">[4]</ref> are anonymity and ciphertext indistinguishability. Anonymity requires that someone without an associated user secret key or tracing key should not be able to guess the targeted identity. The notion of indistinguishability requires that no one can distinguish between a valid ciphertext and a random string from the ciphertext space even having access to the tracing key of the target identity. Recent, in [LTT + 21], Liu et al. proposed a lattice-based construction for AIBET which is based on the anonymous IBE by Katsumata and Yamada <ref type="bibr" target="#b13">[KY16]</ref>. However, they do not address the notion of indistinguishability which is the main difference between an AIBET and a standard anonymous IBE. Note that the role of the tracer and the Private-key Generator PKG are distinguishable where the tracer has less power than the PKG. For example, it could be a gateway that checks whether an email for a suspected illegal user is passed. Even if the tracers are corrupted, the privacy and the confidentiality of the system will still remain intact.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Our contribution:</head><p>We propose a concrete construction of an Anonymous Lattice Hierarchical Identity-Based Encryption with Traceable Identities (AHIBET) scheme which is secure in the standard model based on the hardness assumption of lattices. In particular, our AHIBET construction is anonymous across all the levels of hierarchy, i.e., ciphertexts conceal recipients' identities from everyone which does not know the corresponding keys for decryption or tracing. Traceability cannot be extended down the hierarchy, i.e., knowing the tracing key for identity id doesn't imply knowing tracing key for any of its descendants. Besides, our construction is ciphertext indistinguishable, i.e., even having the tracing key for identity id, one cannot distinguish the ciphertexts of message m from the one of random messages for identity id.</p><p>An instance of our AHIBET yields a lattice-based construction of AIBET that can be easily converted to a construction over ideal lattices using the techniques in <ref type="bibr" target="#b6">[BFRS18]</ref>, which outperforms the AIBET by Liu et al. [LTT + 21]<ref type="foot" target="#foot_0">foot_0</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Technical Overview:</head><p>The first main idea is that an AHIBET system must be controlled by three levels of trapdoors:</p><p>-The master secret key MPK can be used to generate secret key SK id and tracing key Tsk id for each identity id of any level. -The secret keys SK id enable recipients to decrypt the corresponding ciphertexts. Each secret key SK id can be used to generate the secret keys for identities of the next level and thus control all descendants of id. -The tracing keys Tsk id enable tracers to detect only the ciphertexts sent to identities id without leaking information of the messages.</p><p>To achieve the identity traceability property, we attach each ciphertext a random tag and its encapsulation whereas tracing keys are the trapdoors for decapsulation. We exploit the power of lattice trapdoors in <ref type="bibr" target="#b15">[MP12,</ref><ref type="bibr" target="#b9">CHKP10]</ref> combining with the HIBE construction by Agrawal et al. [ABB10a] to achieve our AHIBET.</p><p>In [ABB10a], each identity id is assigned a matrix F id and message m is encrypted following the dual-Regev scheme:</p><formula xml:id="formula_0">c T = s T F id + e T , c ′T = s T U + e ′T + m T q 2 .</formula><p>In our scheme, we use one dual-Regev part to encrypt the message and another one to encapsulate the random tag to allow the ciphertext to reveal the recipients' identity from the tracing key holder.</p><p>In <ref type="bibr" target="#b15">[MP12]</ref>, the authors introduced a so-called G-trapdoor where G is a gadget matrix in Z n×ω q . A G-trapdoor for matrix F is a matrix R ∈ Z (m-ω)×ω such that F = [A|AR + HG] for some invertible matrix H ∈ Z n×n q where A ∈ Z n×(m-ω) q</p><p>. The authors called it "strong trapdoor" since a good basis T F ∈ Z m×m for Λ ⊥ q (F) can be obtained from the knowledge of the matrix R but the reverse is hard. Moreover, with either R or T F , one can easily generate a low norm matrix D F ∈ Z n×t q satisfying F.D F = U with respect to a given random matrix U ∈ Z n×t q using the sampling algorithms from [ABB10a] and <ref type="bibr" target="#b15">[MP12]</ref>. Since D F is a kind of weaker trapdoor than T F , we can use such matrices R, T F and D F as the three levels of trapdoors MSK, SK id , Tsk id respectively for a traceable identity-based encryption where the matrix F is associated to an identity id = (id 1 , . . . , id ℓ ), namely, F = F id = [A|A 1 + FRD(id 1 )G| . . . |A ℓ + FRD(id ℓ )G] for the public matrices A, A 1 , . . . , A ℓ and the full-rank difference encoding function FRD. However, such trapdoors do not guarantee the anonymity and even the secrecy of messages across the hierarchy of identities. For example, knowing D F id 1 and D F [id 1 |id 2 ] , one can easily find a low norm matrix T of the same size as D F id 1 |id 2 such that F [id 1 |id 2 ] T = 0, which reveals information of the messages. Therefore, we use a collision resistance hash function H to construct a matrix F ′ id = [A|A 0 + FRD(H(id))G] and use the sampling algorithms to generate the tracing key D F ′ id of the identity id such that F ′ id D F ′ id = U. Such tracing keys are determined uniquely by the identities and independent of the secret keys, which ensures the anonymity and secrecy of the messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Anonymous Lattice Hierarchical Identity-Based Encryption with Traceable</head><p>Identities (AHIBET)</p><p>In this section, we describe the model of Anonymous Lattice Hierarchical Identity-Based Encryption with Traceable Identities (AHIBET) based on the Anonymous Lattice Identity-Based Encryption with Traceable Identities (AIBET) from <ref type="bibr" target="#b4">[BBP19]</ref> and its security model.</p><p>Definition 1 (AHIBET). An AHIBET scheme consists of the following seven algorithms:</p><p>-Setup(λ, d) takes as input the security parameter λ and the maximal hierarchy depth d of the scheme and outputs the master public key MPK and the master secret key MSK. -Extract(MPK, MSK, id) uses the master public key MPK and the master secret key MSK to generate the secret key SK id for an identity id at depth 1. -Derive(MPK, SK id ), (id|id ℓ ) takes as input the master public key MPK and a secret key SK id corresponding to an identity id at depth ℓ -1, outputs the secret key SK id|id ℓ for the identity (id|id ℓ ) at depth ℓ.</p><p>-TskGen(MPK, MSK, id) uses the master public key MPK and the master secret key MSK to generate the tracing key Tsk id for a given identity id. -Encrypt(MPK, id, m) takes as input the master public key MPK, a given identity id and a message m, outputs the ciphertext CT. -Decrypt(MPK, CT, SK id ) takes as input the master public key MPK, a ciphertext CT and a secret key SK id . The algorithm outputs the message m if CT is encrypted for id; otherwise, it outputs the rejection symbol ⊥. -TkVer(MPK, id, Tsk id , CT) takes as input the master public key MPK, an identity id and a ciphertext CT, uses the tracing key Tsk id to check whether a ciphertext CT is encrypted for id.</p><p>TkVer outputs 1 if CT is for the user with identity id; otherwise, it outputs 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Correctness and soundness.</head><p>The correctness of AHIBET scheme requires that if for all key pairs (MPK, MSK) output by Setup, all 1 ≤ ℓ ≤ d, all identities id = (id 1 , . . . , id ℓ ) where id i ∈ Z n q \ {0} and all messages m ∈ {0, 1} λ , it holds that</p><formula xml:id="formula_1">Pr      Decrypt(MPK, SK id , CT) = m (MPK, MSK) ← Setup(λ, d) SK id ← Derive(MPK, MSK, id) CT ← Encrypt(MPK, id, m) 1 ← TkVer(MPK, id, Tsk id , CT)      = 1</formula><p>and the soundness of AHIBET requires</p><formula xml:id="formula_2">Pr      Decrypt(MPK, SK id , CT) =⊥ (MPK, MSK) ← Setup(λ, d) SK id ← Derive(MPK, MSK, id) CT ← Encrypt(MPK, id, m) 0 ← TkVer(MPK, id, Tsk id , CT)      = 1</formula><p>Security models of AHIBET. For the security models, we give the definition of anonymity and ciphertext indistinguishability for the AHIBET scheme.</p><p>-Anonymity is the property that the adversary can not distinguish the encryption of a chosen message for a first chosen identity from the encryption on the same message for a second chosen identity. Similarly, the adversary can not decide whether a ciphertext it received from the challenger was encrypted for a chosen challenge identity, or for a random identity in the identity space. The anonymity game, denoted ANON-sID-CPA, is played between an adversary A and a challenger C, provided that the adversary A does not have the corresponding tracing key of the challenge identity, is defined through the following game:</p><p>• Init: The adversary A is given the maximum depth of the hierarchy d and then A decides a target pattern id * = (id * 1 , . . . , id * ℓ ), ℓ ≤ d. </p><formula xml:id="formula_3">Adv IND-sID-CPA A,AHIBET := Pr[b = b ′ ] - 1 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Lattices</head><p>A lattice Λ in Z m is a set of all integer linear combinations of (linearly independent) basis vectors</p><formula xml:id="formula_4">B = {b 1 , • • • , b n } ∈ Z m , i.e., Λ := n i=1 b i x i |x i ∈ Z ∀i = 1, • • • , n ⊆ Z m .</formula><p>We call n the rank of Λ and if n = m we say that Λ is a full rank lattice. In this paper, we mainly consider full rank lattices containing qZ m , called q-ary lattices, Λ q (A) := e ∈ Z m s.t. ∃s ∈ Z n q where A T s = e mod q Λ ⊥ q (A) := {e ∈ Z m s.t. Ae = 0 mod q} and translations of lattice Λ ⊥ q (A) defined as follows</p><formula xml:id="formula_5">Λ u q (A) := {e ∈ Z m s.t. Ae = u mod q} for given matrices A ∈ Z n×m and u ∈ Z n q . Let S = {s 1 , • • • , s k } be a set of vectors in R m .</formula><p>We denote by S := max 1≤i≤k s i the maximum ℓ 2 length of the vectors in S. We also denote S := {s 1 , • • • , sk } the Gram-Schmidt orthogonalization of the vectors s 1 , • • • , s k in that order. We refer to S the Gram-Schmidt norm of S.</p><p>Note that for any matrix B ∈ Z n×m , there exists a singular value decomposition B = QDP T , where Q ∈ R n×n , P ∈ R m×m are orthogonal matrices, and D ∈ R n×m is a diagonal matrix with nonnegative entries s i ≥ 0 on the diagonal, in non-increasing order. The s i are called the singular values of B. Under this convention, D is uniquely determined and s 1 (B) = max u Bu = max u B T u ≥ B , B T where the maxima are taken over all unit vectors u ∈ R m . Note that the singular values of B and B T are the same.</p><p>Gaussian distribution. We will use the following definitions of the discrete Gaussian distributions.</p><p>Definition 2. Let Λ ⊆ Z m be a lattice. For a vector c ∈ R m and a positive parameter σ ∈ R, define:</p><formula xml:id="formula_6">ρ σ,c (x) = exp -π x -c 2 σ 2 and ρ σ,c (Λ) = x∈Λ ρ σ,c (x).</formula><p>The discrete Gaussian distribution over Λ with center c and parameter σ is</p><formula xml:id="formula_7">∀y ∈ Λ , D Λ,σ,c (y) = ρ σ,c (y) ρ σ,c (Λ) .</formula><p>For convenience, we will denote by ρ σ and D Λ,σ for ρ σ,0 and D Λ,σ,0 respectively. When σ = 1 we will write ρ instead of ρ 1 .</p><p>It is well-known that for a vector x sampled from D m Z,σ , one has that x ≤ σ √ m with overwhelming probability.</p><formula xml:id="formula_8">Lemma 3. For x ← D Λ u q (A),σ , Pr[ x &gt; σ √ m] ≤ negl(n).</formula><p>Lemma 4. For a prime q and a positive integer n, let m ≥ n⌈log q⌉.</p><formula xml:id="formula_9">For A ← Z n×m q , r ← D m Z,σ</formula><p>with σ ≥ ω( √ log n), the distribution of u = Ar ∈ Z n q is statistically close to the uniform distribution over Z n q . Furthermore, fix u ∈ Z n q , the distribution of r conditioned on Ar = u is D Λ u q (A),σ . The security of our construction reduces to the LWE (Learning With Errors) problem introduced by Regev <ref type="bibr">[Reg09]</ref>.</p><p>Definition 5 (Learning With Errors -LWE problem). Consider a prime q, a positive integer n, and a distribution χ over Z q . An LWE n,m,q,χ problem instance consists of access to an unspecified challenge oracle O, being either a noisy pseudorandom sampler O s associated with a secret s ∈ Z n q , or a truly random sampler O $ who behaviors are as follows:</p><p>O s : samples of the form (a i , b i ) = (a i , s T a i + e i ) ∈ Z n q × Z q where s ∈ Z n q is a uniform secret key, a i ∈ Z n q is uniform and e i ∈ Z q is a noise withdrawn from χ. O $ : samples are uniform pairs in Z n q × Z q .</p><p>The LWE n,m,q,χ problem allows respond queries to the challenge oracle O. We say that an algorithm A decides the LWE n,m,q,χ problem if</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adv</head><p>LWEn,m,q,χ A</p><formula xml:id="formula_10">:= Pr[A Os = 1] -Pr[A O $ = 1]</formula><p>is non-negligible for a random s ∈ Z n q .</p><p>Regev <ref type="bibr">[Reg09]</ref> showed that (see Theorem 6 below) when χ is a distribution Ψ α with α ∈ (0, 1), the LWE problem is hard. Theorem 6. If there exists an efficient, possibly quantum, algorithm for deciding the LWE n,m,q,Ψα problem for q &gt; 2 √ n/α then there is an efficient quantum algorithm for approximating the SIVP and GapSVP problems, to within Õ(n/α) factors in the ℓ 2 norm, in the worst case.</p><p>The theorem implies, for n/α is a polynomial in n, the LWE problem is as hard as approximating the SIVP and GapSVP problems in lattices of dimension n to within polynomial (in n) factors.</p><p>In this paper, we will use the discrete Gaussian distribution D m Z,σ and denote LWE n,m,q,σ instead of LWE n,m,q,D m Z,σ for convenience. We use the following lemma which was introduced by Katsumata and Yamada in <ref type="bibr" target="#b13">[KY16]</ref> to rerandomize LWE instances: Lemma 7. Let ℓ, q, m be positive integers and let r be a positive real number satisfying r ≥ max{ω( √ log m), ω( √ log ℓ)}. Let b ∈ Z m q be arbitrary and z ← D m Z,r . Then there exists an efficient algorithm ReRand such that for any D ∈ Z m×ℓ and positive real σ ≥ s 1 (D), the output of</p><formula xml:id="formula_11">ReRand(D, b T + z T , r, σ) is distributed as b ′T = b T D + z ′T ∈ Z ℓ</formula><p>q where the distribution of z ′ is close to D ℓ Z,2rσ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lattice trapdoors</head><p>Our work heavily bases on the notion G-trapdoor introduced in [MP12]. In the following, we recap this notion as well as some usefull algorithms.</p><p>As in <ref type="bibr" target="#b15">[MP12]</ref>, let n ≥ 1, q ≥ 2 and let ω = n⌈log q⌉ = nk, we will use the vector g T = (1, 2, 4, . . . , 2 k-1 ) and extend it to get the gadget matrix</p><formula xml:id="formula_12">G = I n ⊗ g T ∈ Z n×ω q such that the lattice Λ ⊥ q (G) has a public known matrix T G ∈ Z ω×ω with T G ≤ √ 5 and T G ≤ max( √ 5, √ k). Definition 8. (G-trapdoor) Let n ≥ 1, q ≥ 2 and ω = n⌈log q⌉, m ≥ ω. Let A ∈ Z n×m q , G ∈ Z n×ω q . Let H ∈ Z n×n q be some invertible matrix. A matrix R ∈ Z (m-ω)×ω is called a G-trapdoor for A with tag H if it holds that A -R I ω = HG mod q.</formula><p>The quality of the trapdoor is measured by its largest singular value s 1 (R).</p><p>[MP12] also presented an algorithm to generate a pseudorandom matrix F ∈ Z n×(m+ω) q together with a "strong" G-trapdoor for the lattice Λ ⊥ q (F):</p><formula xml:id="formula_13">1. Sample A ← Z n×m q , R ← D m×ω Z,ω( √ log n</formula><p>) and an invertible matrix H ← Z n×n q 2. Return F = [A|AR + HG] and the G-trapdoor R.</p><p>The matrix R ← D m×ω Z,ω( √ log n) can do everything that a low-norm basis of Λ ⊥ q (F) does. Moreover, R can be used to efficiently generate low-norm basis T F ∈ Z (m+ω)×(m+ω) for Λ ⊥ q (F).</p><p>Next, we recall the following lemma from [GPV08]:</p><p>Lemma 9. Let q, k, n, m be integers with q &gt; 2, k &gt; 1, m &gt; n and let A ∈ Z n×m q , U ∈ Z n×k q . Let T A be a basis for Λ ⊥ q (A). For σ ≥ T A •ω( √ log m), there is a PPT algorithm SamplePre(A, T A , U, σ) that returns a matrix D ∈ Z n×k q sampled from a distribution statistically close to D Λ U q (A),σ , whenever Λ U q (A) is not empty such that AD = U.</p><p>The following lemma consists of algorithms for generating bases for lattices collected from the sampling technique in the work of Agrawal et al. [ABB10a] and the SamplePre algorithm from the work of Micciancio et al. [MP12, Theorem 5.1] which will be used in our construction. Note that the SamplePre algorithm in <ref type="bibr" target="#b15">[MP12]</ref> is different from the SamplePre algorithm from [ABB10a] in Lemma 9 above.</p><formula xml:id="formula_14">Lemma 10. Let n ≥ 1, q ≥ 2, ω = n⌈log q⌉, m ≥ ω. Let A ← Z n×m q .</formula><p>-Let T A be a basis for Λ ⊥ q (A), M ← Z n×m 1 q and σ ≥ T A • ω( log(m + m 1 )). Then there exists a PPT algorithm SampleBasisLeft(A, M, T A , σ) that outputs a basis of</p><formula xml:id="formula_15">Λ ⊥ q ([A|M]). -Let R ← D m×ω Z,ω( √ log n) , U ← Z n×ω q</formula><p>, and let H ← Z n×n q be an invertible matrix.</p><formula xml:id="formula_16">Let F = [A|AR + HG]. Then for σ ≥ 5•s 1 (R)•ω( √ log n)</formula><p>, there exists a PPT algorithm SampleRight(R, F, H, U, σ) that outputs a matrix D ∈ Z (m+ω)×ω distributed statistically close to D Λ U q (F),σ s.t. FD = U. In particular, there exits a PPT algorithm SampleBasisRight(R, F, H, U, σ) that outputs a basis T ∈ Z (m+ω)×(m+ω) of Λ ⊥ q (F) which distributes statistically close to D Λ ⊥ q (F),σ , i.e., FT = 0. Here, we note that the algorithm SampleBasisRight basically runs SampleRight(R, F, H, 0, σ) many times until there are enough linearly independent output vectors to form a basis of Λ ⊥ q (F). According to [ABB10b], 2(m + ω) samples are needed in expectation to get the basis T for Λ ⊥ q (F). Peikert [Pei09] shows how to construct a basis for Λ ⊥ q (A 1 |A 2 |A 3 ) from a basis for Λ ⊥ q (A 2 ). Theorem 11. For i = 1, 2, 3, let A i be a matrix in Z n×m i and let A = (A 1 |A 2 |A 3 ). Let T 2 be a basis of Λ ⊥ q (A 2 ). There is a deterministic polynomial time algorithm ExtendBasis that outputs a basis T for Λ ⊥ q (A) such that T = T 2 . We will also use the following lemma in the decryption algorithm to recover the message.</p><p>Lemma 12. Let A be a uniformly random matrix in Z n×m q where m &gt; 2n. Let T ∈ Z m×m be a basis of Λ ⊥ q (A). Given y = s T A + e T where s ∈ Z n q , e ∈ Z m with e T T ∞ &lt; q/4, there exists an algorithm Invert(A, T, y) that outputs s and e with overwhelming probability.</p><p>It can be easily seen that the lemma is true since the algorithm works by computing y T T mod q = e T T mod q. We have e T T ∞ &lt; q/4, so e T T mod q = e T ∈ Z m . Since T ∈ Z m×m is a basis of lattice Λ ⊥ q (A), T has linearly independent columns, one can simply use the Gaussian elimination to recover e and then get s T A. Finally, s can be recovered by Gaussian elimination because A ∈ Z n×m has at least n linearly independent column vectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">AHIBET Construction over Integer Lattices</head><p>-Let λ be the security parameter, d be the hierarchy depth and identities are vector id = (id 1 , . . . , id ℓ ) (1 ≤ ℓ ≤ d) where all components id i are in Z n \ {0}.</p><p>-Let FRD : Z n q -→ Z n×n q be a full-rank difference encoding (FRD) from [ABB10a] s.t. for all distinct u, v ∈ Z n q , FRD(u) -FRD(v) ∈ Z n×n q is an invertible matrix. -Let H : (Z n q ) * -→ Z n q be a collision resistant hash function.</p><p>-For an integer q &gt; 2, x ∈ Z q , the algorithm Round(x) returns 0 if x is closer to 0 than to q 2 modulo q; otherwise, it returns 1.</p><p>In the construction of the AHIBET scheme, we assume each identity id can only be given exactly one tracing key Tsk id .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Setup(λ, d)</head><p>On input security parameter λ and a maximum hierarchy depth d, set the parameters (n, m, q, ω, σ, τ, α, r) as in section 3.1, the algorithm does: 1. Sample uniformly random matrices</p><formula xml:id="formula_17">A ← Z n×m q , A 2 , . . . , A d ← Z n×ω q and R 0 , R 1 ← D m×ω Z,ω( √ log n) . 2. Set A 0 ← AR 0 ∈ Z n×ω q , A 1 ← AR 1 ∈ Z n×ω q and choose U 1 , U 2 ← Z n×λ q</formula><p>uniformly at random. 3. Output the master public key and the master secret key</p><formula xml:id="formula_18">MPK = (A, A 0 , A 1 , . . . , A d , U 1 , U 2 ) , MSK = (R 0 , R 1 ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Extract(MPK, MSK, id)</head><p>On input the master pubic key MPK, the master secret key MSK and an identity id of level 1, the algorithm generates secret key for id as follows:</p><formula xml:id="formula_19">1. Compute F id = [A|A 1 + FRD(id)G] ∈ Z n×(m+ω) q . 2. Sample T id ← SampleBasisRight(F id , R 1 , FRD(id), σ 1 ) ∈ Z (m+ω)×(m+ω) q s.t. F id T id = 0. 3. Output SK id ← T id .</formula><p>Derive(MPK, SK id , (id|id ℓ ))</p><p>On input the master pubic key MPK, a secret key SK id corresponding to an identity id = (id 1 , . . . , id ℓ-1 ) at depth ℓ -1 and an identity id|id ℓ = (id 1 , . . . , id ℓ-1 , id ℓ ) of level ℓ &gt; 1, the algorithm generates secret key for id as follows:</p><formula xml:id="formula_20">1. Set F id|id ℓ = [F id |A ℓ + FRD(id ℓ )G] ∈ Z n×(m+ℓω) q with F id = [A|A 1 + FRD(id 1 )G| . . . |A ℓ-1 + FRD(id ℓ-1 )G]. 2. Sample T id|id ℓ ← SampleBasisLeft(F id , A ℓ + FRD(id ℓ )G, SK id , σ ℓ ) s.t. F id|id ℓ T id|id ℓ = 0. 3. Output SK id|id ℓ ← T id|id ℓ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TskGen(MPK, MSK, id)</head><p>On input the master pubic key MPK, the master secret key MSK and an identity id = (id 1 , . . . , id ℓ ), the algorithm generates the tracing key for id as follows:</p><formula xml:id="formula_21">1. Compute F ′ id = [A|A 0 + FRD(H(id))G] ∈ Z n×(m+ω) q . 2. Sample D ′ id ← SampleBasisRight(F ′ id , R 0 , FRD(H(id)), σ 1 ) ∈ Z (m+ω)×(m+ω) q s.t. F ′ id D ′ id = 0. 3. Sample D id ← SamplePre(F ′ id , D ′ id , U 2 , σ 1 ) ∈ Z (m+ω)×λ q . 4. Output Tsk id ← D id .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Encrypt(MPK, id, m)</head><p>On input the master pubic key MPK, the algorithm encrypts the message m ∈ {0, 1} λ for identity id = (id 1 , . . . , id ℓ ) at depth ℓ as follows:</p><formula xml:id="formula_22">1. Compute F id = [A|B id ] = [A|A 1 + FRD(id 1 )G| . . . |A ℓ + FRD(id ℓ )G] ∈ Z n×(m+ℓω) q . 2. Sample k ← {0, 1} λ . 3. Sample a uniformly random vector s ← Z n q . 4. Choose noise vectors e 0 ← D m Z,r , e 1 ← D ℓω Z,2rτ e 2 ← D λ Z,r , e 3 ← D λ Z,2rτ , e 4 ← D ω Z,2rτ . 5. Set c T 0 = s T A + e T 0 , c T 1 = s T B id + e T 1 , c T 2 = s T U 1 + e T 2 + m T q 2 ,</formula><formula xml:id="formula_23">and c T 3 = s T U 2 + e T 3 + k T q 2 , c T 4 = s T (A 0 + FRD(H(id))G) + e T 4 . 6. Output CT = (c 0 , c 1 , c 2 , c 3 , c 4 , k).</formula><p>Decrypt(MPK, CT, SK id ) On input the master pubic key MPK, a ciphertext CT and a secret key SK id where id = (id 1 , . . . , id ℓ ) is an identity at depth ℓ, the algorithm does:</p><formula xml:id="formula_24">1. Parse CT = (c 0 , c 1 , c 2 , c 3 , c 4 , k); Output ⊥ if CT doesn't parse. 2. Set F id = [A|A 1 +FRD(id 1 )G| . . . |A ℓ +FRD(id ℓ )G] and recover s via Invert(SK id , F id , [c T 0 |c T 1 ]). 3. Recover k ← Round(c T 3 -s T U 2 ); Return ⊥ if k = k. 4. Compute m ← Round(c T 2 -s T U 1 ). 5. Output m.</formula><p>TkVer(MPK, id, Tsk id , CT)</p><p>On input the master pubic key MPK, the algorithm uses the tracing key Tsk id = D id corresponding to the identity id to check whether a ciphertext CT is encrypted for the given identity id:</p><formula xml:id="formula_25">1. Parse CT = (c 0 , c 1 , c 2 , c 3 , c 4 , k); Output ⊥ if CT doesn't parse. 2. Compute k ← Round(c T 3 -[c T 0 |c T 4 ]D id ). 3. If k = k then output 1; else output 0.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Parameters</head><p>Let λ be the security parameter, d is the maximum hierarchical depth of the scheme, 1 ≤ ℓ ≤ d. We assume that all parameters are functions of λ. Now for the system to work correctly, we need to ensure:</p><formula xml:id="formula_26">-σ ℓ is large enough for SampleBasisLeft and SampleBasisRight, i.e., σ ℓ &gt; O(m)•ω(log n)•ω( log(ℓ + 1)m), -τ is large enough for ReRand, i.e. τ ≥ O(m 3/2 ) • ω(log 3/2 n),</formula><p>the error term in decryption is less than q/4 with high probability, i.e. α &lt; (8σ ℓ τ (m + ℓω)) -1 , Hence the following choice of parameters (n, m, q, ω, σ, τ, α, r) satisfies all of the above conditions, taking λ to be the security parameter:</p><formula xml:id="formula_27">n ≥ 2 , q ≥ 2 , ω = n⌈log q⌉ , 1 ≤ ℓ ≤ d m ≥ n log q + ω(log n) , r = αq , σ 1 = O( √ m) • ω(log n) σ ℓ = O(m) • ω(log n) • ω( log(ℓ + 1)m), τ = O(m 3/2 ) • ω(log 3/2 n), α = [(ℓ + 1) • O(m 7/2 ) • ω(log 5/2 n) • ω( log(ℓ + 1)m)] -1 .</formula><p>(1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Correctness and soundness</head><p>When the cryptosystem is operated as specified, during decryption of a correctly generated ciphertext encrypted a message m to an identity id = (id 1 , . . . , id ℓ ) at depth ℓ ≤ d, with the parameters as specified in 3.1, we have:</p><p>-Since e 0 ← D m Z,r , e 1 ← D ℓω Z,2rτ , by applying Lemma 3 and the parameters set up, we get</p><formula xml:id="formula_28">[e T 0 |e T 1 ] ≤ 2rτ • √ m + ℓω, which means [e T 0 |e T 1 ]T id ∞ ≤ [e T 0 |e T 1 ] • T id ≤ (2rτ • (m + ℓω))• (σ ℓ • √ m + ℓω) ≤ 2rτ σ ℓ • (m + ℓω) ≤ q/4. Using Lemma 12, it is sufficient to show that the algorithm Invert(T id , F id , [c T 0 |c T<label>1</label></formula><p>]) will output s with overwhelming probability.</p><p>-Since e 2 ← D λ Z,r , e 3 ← D λ Z,2rτ , by applying Lemma 3 and the parameters set up we get e 2 ≤ e 3 ≤ 2rτ √ λ &lt; q/4.</p><formula xml:id="formula_29">Hence Round(c T 3 -s T U 2 ) = Round k q 2 T + e T 3 and Round(c 2 -s T U 1 ) = Round m q 2 T + e T 2</formula><p>will correctly recover k and m.</p><p>In the algorithm TkVer, Round(c</p><formula xml:id="formula_30">T 3 -[c T 0 |c T 4 ]D id ) = Round k q 2 T + e T 3 + [e T 0 |e T 4 ]D id where D id ≤ σ 1 √ m + ω.</formula><p>Hence by the parameters set up, TkVer will correctly recover the key k.</p><p>4 Security analysis</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Proof of Anonymity</head><p>In this part, we will prove that our proposed AHIBET scheme is ANON-sID-CPA secure in the standard model.</p><p>Theorem 1. The AHIBET scheme Π := (Setup, Extract, Derive, Encrypt, Decrypt, TskGen, TkVer) with parameters (λ, n, m, q, ω, σ, τ, α, r) as in (1) is ANON-sID-CPA secure for the maximal hierarchy depth d provided that the hardness of the LWE n,m+λ,q,r problem holds.</p><p>Proof. We will proceed the proof via a sequence of games where the Game 0 is identical to the original ANON-sID-CPA game and the adversary in the last game has advantage at most the advantage of an efficient LWE adversary.</p><p>Let A be a PPT adversary that attacks the AHIBET scheme Π and has advantage Adv ANON-sID-CPA A,Π = ǫ. We will then construct a simulator B that solves the LWE problem using A. Let G i denote the event that the adversary A wins Game i. The adversary's advantage in Game</p><formula xml:id="formula_31">i is Pr[G i ] - 1 2 .</formula><p>Game 0. This is the original ANON-sID-CPA game between the adversary A against our scheme and an ANON-sID-CPA challenger.</p><formula xml:id="formula_32">Adv ANON-sID-CPA A,Π = Pr[G 0 ] - 1 2 = Pr[b ′ = b] - 1 2 .</formula><p>Game 1. Game 1 is analogous to Game 0 except that we slightly modify the way that the challenger C generates the master public key MPK and responds to the key derivation oracles O Derive as well as the tracing key oracles O TskGen . Let id * = (id * 1 , . . . , id * ℓ ) (ℓ ≤ d) be the target identity that A intends to attack. After receiving id * , C does:</p><formula xml:id="formula_33">1. Sample A ← Z n×m q , R 0 , R 1 , . . . , R d ← D m×ω Z,ω( √ log n) and R ← D m×λ Z,ω( √ log n) . 2. Set A 0 ← AR 0 -FRD(H(id * ))G. 3. Set A i ← AR i -FRD(id * i )G for i = 1, . . . , ℓ and A i ← AR i for ℓ &lt; i ≤ d. 4. Set U 2 ← AR and sample U 1 ← Z n×λ q .</formula><p>5. Send master public key</p><formula xml:id="formula_34">MPK = (A, A 0 , A 1 , . . . , A d , U 1 , U 2 ) to A and keep R 0 , R 1 , . . . , R d , R secret.</formula><p>-Recall that the adversary A is not allowed to use the challenge identity id * or its prefixes for its key derivation queries. To respond to the key derivation queries O Derive for id = (id 1 , . . . ,</p><formula xml:id="formula_35">id k ) = id * = (id * 1 , . . . , id * ℓ ) (1 ≤ k ≤ d), C<label>sets</label></formula><formula xml:id="formula_36">F id = [A|A 1 + FRD(id 1 )G| . . . |A k + FRD(id k )G] ∈ Z n×(m+kω) q .</formula><p>• If k ≤ ℓ, then</p><formula xml:id="formula_37">F id = [A|AR 1 + (FRD(id 1 ) -FRD(id * 1 ))G| . . . |AR k + (FRD(id k ) -FRD(id * k ))G].</formula><p>Let h be the sallowest level where id h = id * h (h ≤ k). By the property of the full-rank difference encoding FRD, FRD(id h ) -FRD(id * h ) ∈ Z n×n q is an invertible matrix, C then samples</p><formula xml:id="formula_38">T id h ← SampleBasisRight([A|AR h +(FRD(id h )-FRD(id * h ))G], R h , FRD(id h )-FRD(id * h ), σ 1 ). If h = k = 1, C returns SK id = T id 1 . If k &gt; 1, C uses algorithm ExtendBasis to extend the basis T id h of Λ ⊥ q ([A|AR h + (FRD(id h ) -FRD(id * h ))G]) to a basis T id of Λ ⊥ q (F id ) then returns SK id = T id . • If k &gt; ℓ, then F id = [A|AR 1 | . . . |AR ℓ |AR ℓ+1 + FRD(id ℓ+1 )G| . . . |AR k + FRD(id k )G]</formula><p>and FRD(id ℓ+1 ) ∈ Z n×n q is an invertible matrix. The challenger C samples</p><formula xml:id="formula_39">T id ℓ+1 ← SampleBasisRight([A|AR ℓ+1 + FRD(id ℓ+1 )G], R ℓ+1 , FRD(id ℓ+1 ), σ 1 )</formula><p>and uses algorithm ExtendBasis to extend the basis T id ℓ+1 of Λ ⊥ q ([A|AR ℓ+1 +FRD(id ℓ+1 )G]) to a basis T id of Λ ⊥ q (F id ). Finally, C returns SK id = T id . -To respond to the tracing key query O TskGen for id = (id 1 , . . . ,</p><formula xml:id="formula_40">id k ) = id * = (id * 1 , . . . , id * ℓ ), C sets F ′ id = [A|A 0 + FRD(H id )G] = [A|AR 0 + (FRD(H(id)) -FRD(H(id * )))G].</formula><p>Since H is a collision resistant hash function, H(id) = H(id * ) even if id is a prefix of id * and thus FRD(H(id)) -FRD(H(id * )) is an invertible matrix in Z n×n q . Challenger C samples</p><formula xml:id="formula_41">D ′ id ← SampleBasisRight(F ′ id , R 0 , FRD(H(id)) -FRD(H(id * ))G, σ 1 )</formula><p>then invokes the algorithm SamplePre</p><formula xml:id="formula_42">D id ← SamplePre(F ′ id , D ′ id , U 2 , σ 1 ) ∈ Z (m+ω)×λ q</formula><p>and returns Tsk id = D id .</p><p>Using Lemma 4, we can easily prove that the matrices A i (0 ≤ i ≤ d) are statistically close to uniform. Hence, in the adversary's point of view, A 0 , A 1 , . . . , A d in Game 0 and Game 1 are computationally indistinguishable.</p><p>Next, we consider the responses to the secret key derivation queries O Derive and the tracing key queries O TskGen . For secret key derivation queries O Derive , Theorem 10 shows that when</p><formula xml:id="formula_43">σ 1 ≥ 5 • s 1 (R) • ω( √ log n), σ ℓ ≥ T id h • ω( log(m + ℓω))</formula><p>, the algorithms SampleBasisRight and ExtendBasis generate a basis T id for Λ ⊥ q (F id ) which is statistically close to the one generated in the original game. Similarly, the tracing keys generate by SampleBasisRight and SamplePre in Game 1 have distribution statistically close to ones in Game 0. Since the master public key MPK and responses to key derivation queries and tracing key queries in Game 1 are statistically close to those in Game 0, these games are statistically indistinguishable in the view of the adversary. Thus we have</p><formula xml:id="formula_44">| Pr[G 1 ] -Pr[G 0 ]| ≤ negl(λ). Game 2.</formula><p>In this game, we change the way the challenge ciphertext CT * for the challenge identity id * is created. Recall that, after receiving a message m ∈ {0, 1} λ from the adversary A, the challenger C then selects a random bit b ∈ {0, 1}. If b = 1, C chooses a random identity id ′ in the identity space which is not identical to any query identities in Phase 1. C then runs Encrypt(MPK, id, m) and sends the resulting ciphertext CT * 1 to A. If b = 0, the challenger C does the following steps to generate CT * 0 and sends it to A.</p><formula xml:id="formula_45">1. Sample k ← {0, 1} λ . 2. Sample s ← Z n q . 3. Choose noise vectors e 0 ← D m Z,r , e 2 ← D λ Z,r . 4. Set c T 0 = s T A + e T 0 , c T 2 = s T U 1 + e T 2 + m T q 2 and c T 1 ← ReRand(R, c T 0 , r, τ ) c T 3 ← ReRand(R, c T 0 , r, τ ) + k q 2 T c T 4 ← ReRand(R 0 , c T 0 , r, τ ) where R = [R 1 | . . . |R ℓ ]. 5. Output CT * 0 = (c 0 , c 1 , c 2 , c 3 , c 4 , k).</formula><p>Observe that c 0 and c 3 are distributed exactly as they as in the previous game. Since</p><formula xml:id="formula_46">F id * = [A|A 1 + FRD(id * 1 )G| . . . |A ℓ + FRD(id * ℓ )G] ∈ Z n×(m+ℓω) q = [A|AR 1 | . . . |AR ℓ ] = [A|AR]</formula><p>by Lemma 7, we get</p><formula xml:id="formula_47">c T 1 = ReRand(R = [R 1 | . . . |R ℓ ], c T 0 = s T A + e T 0 , r, τ ) = s T AR + e T 1 , c T 3 = ReRand(R, c T 0 = s T A + e T 0 , r, τ ) + k q 2 T = s T AR + e T 3 = s T U 2 + e T 3 + k T q 2 , c T 4 = ReRand(R 0 , c T 0 = s T A + e T 0 , r, τ ) = s T AR 0 + e T 4 = s T (A 0 + FRD(H(id * ))G) + e T Adv Game2 A ≤ Adv LWE n,q,m+λ,r B<label>(λ)</label></formula><p>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Proof of Ciphertext Indistinguishability</head><p>Finally, we will prove that our proposed AHIBET scheme is IND-sID-CPA secure in the standard model. Recall that indistinguishable from random meaning that the challenge ciphertext encrypted for a given message m * is computationally indistinguishable from a challenge ciphertext encrypted for a random message m in the message space on the same challenge identity id * .</p><p>Theorem 2. The AHIBET scheme Π := (Setup, Extract, Derive, Encrypt, Decrypt, TskGen, TkVer) with parameters (λ, n, m, q, ω, σ, τ, α, r) as in (1) is IND-sID-CPA secure for the maximal hierarchy depth d provided that the hardness LWE n,q,m+λ,r assumption holds.</p><p>Proof. We will proceed the proof via a sequence of games where the Game 0 is identical to the original IND-sID-CPA game and the adversary has no advantage in winning the last game. Let A be a PPT adversary that attacks the AHIBET scheme Π and has advantage Adv IND-sID-CPA A,Π = ǫ. We will then construct a simulator B that solves the LWE problem using A. In Game i, let G i denote the event that the adversary A win the game. The adversary's advantage</p><formula xml:id="formula_48">in Game i is | Pr[G i ] -1 2 |.</formula><p>Game 0. This is the original IND-sID-CPA game between the adversary A against our scheme and an IND-sID-CPA challenger.</p><formula xml:id="formula_49">Adv IND-sID-CPA A,Π = Pr[G 0 ] - 1 2 = Pr[b ′ = b] - 1 2 . Game 1.</formula><p>Game 1 is similar to Game 0 except that we slightly modify the way that the challenger C generates the master public key MPK and responds to the key derivation oracles O Derive and tracing key oracles O TskGen . Let id * = (id * 1 , . . . , id * ℓ ) (ℓ ≤ d) be the identity that A intends to attack. After receiving id * , C does: 1. Sample A ← Z n×m q , R 0 , R 1 , . . . , R d ← D m×ω Z,ω( √ log n) and D 0 ← D m×λ Z,σ 1 , D 1 ← D ω×λ Z,σ 1 . 2. Set A i ← AR i -FRD(id * )G for i = 1, . . . , ℓ and A i ← AR i for ℓ &lt; i ≤ d. -The adversary A is not allowed to ask for the key derivation queries of the challenge identity id * and its prefixes. To respond to a key derivation query O Derive for an identity id = (id 1 , . . . , id k ), C sets:</p><formula xml:id="formula_50">F id = [A|A 1 + FRD(id 1 )G| . . . |A k + FRD(id k )G] ∈ Z n×(m+kω) q .</formula><p>• If k ≤ ℓ, then</p><formula xml:id="formula_51">F id = [A|AR 1 + (FRD(id 1 ) -FRD(id * 1 ))G| . . . |AR k + (FRD(id k ) -FRD(id * k ))G].</formula><p>Let h be the sallowest level where id h = id * h (h ≤ k). By the property of the full-rank difference encoding FRD, FRD(id h ) -FRD(id * h ) ∈ Z n×n q is an invertible matrix, C then samples </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•-</head><figDesc>Setup: At the beginning of the game, the challenger C runs Setup(λ, d) to obtain (MPK, MSK) and gives the resulting master public key MPK to the adversary A.• Phase 1: A may adaptively make queries polynomial many times to the key derivation oracle O Derive and the tracing key oracle O TskGen where:* Oracle O Derive (id) takes input an identity id different from id * and its prefixes, returns the output of Derive(MPK, MSK, id).• Challenge: The adversary A chooses a message m ∈ {0, 1} λ and gives it to the challenger C. C then selects a random bit b ∈ {0, 1} and a random identity id ′ in the identity space which has the same depth with the challenge identity id * . If b = 0, C runsCT * 0 ← Encrypt(MPK, id * , m); otherwise, it runs CT * 1 ← Encrypt(MPK, id ′ , m).Finally, C passes (MPK, CT * b ) through to the adversary A. • Phase 2: A continues to issue additional key derivation and tracing key queries and C responds as in Phase 1. • Guess: A outputs its guess b ′ ∈ {0, 1} and wins if b ′ = b. The advantage of A is defined as Adv ANON-sID-CPA A,AHIBET := Pr[b = b ′ ] -1 2 . In the ciphertext indistinguishability game, we use a privacy property called indistinguishable from random which means that the challenge ciphertext encrypted for a given message m * is computationally indistinguishable from a the challenge ciphertext encrypted for a random message m on the same challenge identity id * , even the adversary A has the corresponding tracing key Tsk id * of id * . The IND-sID-CPA security model is defined through the following game, played between an adversary A and a challenger C: • Init: The adversary A is given the maximum depth of the hierarchy d and then A decides a target pattern id * = (id * 1 , . . . , id * l ), ℓ ≤ d. • Setup: At the beginning of the game, the challenger C runs Setup(λ, d) to obtain (MPK, MSK) and gives the resulting master public key MPK to the adversary A. • Phase 1: A may adaptively make queries polynomial many times to the key derivation oracle O Derive and the tracing key oracle O TskGen where: * Oracle O Derive (id) takes input an identity id different from id * and its prefixes, returns the output of Derive(MPK, MSK, id). * Oracle O TskGen (id) takes input an identity id different from id * , returns the output of TskGen(MPK, MSK, id). • Challenge: The adversary A chooses a message m * ∈ {0, 1} λ and gives it to the challenger C. C sets m 0 = m * and chooses a random message m 1 in the message space. C then selects a random bit b ∈ {0, 1}. If b = 0, C runs CT * 0 ← Encrypt(MPK, id * , m 0 ); otherwise, it runs CT * 1 ← Encrypt(MPK, id * , m 1 ). Finally, C passes (MPK, CT * b ) through to the adversary A. • Phase 2: A continues to issue additional key derivation and tracing key queries and C responds as in Phase 1. • Guess: A outputs its guess b ′ ∈ {0, 1} and wins if b ′ = b. The advantage of A is defined as</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><figDesc>3. Set R ← D 0 + R 0 D 1 . 4. Set A 0 ← AR 0 -FRD(H(id * ))G, U 2 ← AR and sample U 1 ← Z n×λ q .5. Output the master public keyMPK = (A, A 0 , A 1 , . . . , A d , U 1 , U 2 ) and keep R 0 , R 1 , . . . , R d , R secret.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>T</head><figDesc>id h ← SampleBasisRight([A|AR h +(FRD(id h )-FRD(id * h ))G], R h , FRD(id h )-FRD(id * h ), σ 1 ).If h = k = 1, C returns SK id = T id 1 . If k &gt; 1, C uses algorithm ExtendBasis to extend the basis T id h of Λ ⊥ q ([A|AR h + (FRD(id h ) -FRD(id * h ))G]) to a basis T id of Λ ⊥ q (F id ) then returns SK id = T id . • If k &gt; ℓ, then F id = [A|AR 1 | . . . |AR ℓ |AR ℓ+1 + FRD(id ℓ+1 )G| . . . |AR k + FRD(id k )G]and FRD(id ℓ+1 ) ∈ Z n×n q is an invertible matrix. The challenger C samplesT id ℓ+1 ← SampleBasisRight([A|AR ℓ+1 + FRD(id ℓ+1 )G], R ℓ+1 , FRD(id ℓ+1 ), σ 1 )and uses algorithm ExtendBasis to extend the basis T id ℓ+1 of Λ ⊥ q ([A|AR ℓ+1 +FRD(id ℓ+1 )G]) to a basis T id of Λ ⊥ q (F id ). Finally, C returns SK id = T id . -To respond to the tracing key query O TskGen for id = (id 1 , . . . , id k ) = id * = (id * 1 , . . . , id * ℓ ), C sets:F ′ id = [A|AR 0 + (FRD(H(id)) -FRD(H(id * )))G]Since H is a collision resistant hash function, H(id) = H(id * ) even if id is a prefix of id * and thus FRD(H(id)) -FRD(H(id * )) is an invertible matrix in Z n×n q . The challenger C samples D ′ id ← SampleBasisRight(F ′ id , R 0 , FRD(H(id)) -FRD(H(id * ))G, σ 1 )</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>In fact, the public parameter in Liu et al. [LTT + 21] will be a factor of dl greater than ours where d is some fixed constant (e.g., d=2 or 3) and l = ⌈n 1/d ⌉ for n the security parameter.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>where the distribution of e 1 , e 3 and e 4 are statistically close to D ℓω Z,2rτ , D λ Z,2rτ and D ω Z,2rτ , respectively. So we yields that Game 1 and Game 2 are statistically close in the adversary's point of view, the adversary's advantage against Game 2 will be the same as Game 1.</p><p>Theorem 1 then follows from the reduction from the LWE problem by the following lemma.</p><p>Lemma 13. If there exists an adversary A that wins the Game 2 with non-negligible advantage then there is an adversary B that solves the LWE problem, i.e., Adv Game2 A ≤ Adv LWE n,m+λ,q,r B (λ) for some LWE adversary B.</p><p>Proof of Lemma 13. Recall that an LWE problem instance is provided as a sampling oracle O. B requests from oracle O and receives a decisional LWE n,m+λ,q,r problem sample (C, c T = u T + e T ) where C is a random matrix in Z n×(m+λ) q , c ∈ Z m+λ and e is sampled from the distribution D m+λ Z,r . B needs to decide whether u is truly random O $ or a noisy pseudo-random O s for some secret random s ∈ Z n q such that u T = s T C. B simulates Game 2 with adversary A and uses the guess from A to respond LWE challenges.</p><p>After receiving the challenge identity id * = (id * 1 , . . . , id * ℓ ) (ℓ ≤ d) from A, B constructs the simulator as follows:</p><p>-Send the master public key</p><p>-Respond to the key derivation queries and tracing key queries as in Game 2.</p><p>-Split c T = (c T |c T ) ∈ Z m+λ q where cT = ūT + ēT ∈ Z m q and cT = ũT</p><p>, meaning that CT * is a valid challenge ciphertext that encrypts challenge message m for the target identity id * .</p><p>When LWE oracle is a random oracle (i.e. O = O $ ), c T is uniformly random in Z m+λ q and thus CT * distributes as a ciphertext encrypted for a random identity in the identity space. Indeed, we have</p><p>where e 1 , e 3 and e 4 are statistically close to D ℓω Z,2rτ , D λ Z,2rτ and D ω Z,2rτ , respectively. Since u = (ū|ũ) is a random vector, the following distributions are negligibly close by using Lemma 4:</p><p>where</p><p>for a random identity id ′ = (id ′ 1 , . . . , id ′ ℓ ) of level ℓ, and u 1 ∈ Z ℓω q , u 2 ∈ Z λ q , u 3 ∈ Z ω q are uniformly random vectors. Therefore, in the view of the adversary A, when the LWE oracle is random, CT * distributes as a ciphertext encrypted message m for a random identity. This implies that then invokes the algorithm SamplePre</p><p>q and returns Tsk id = D id .</p><p>To respond to the tracing key query of id * = (id * 1 , . . . , id * ℓ ), the challenger C sets:</p><p>Using Lemma 4 with σ 1 ≥ O( √ m) • ω(log n) we have: the distribution of U 2 is statistically close to uniform over Z λ q and D id * has the distribution D (m+ω)×λ Z,σ 1</p><p>. Since the master public key MPK and responses to key derivation queries and the tracing key queries are statistically close to those in Game 0, the adversary's advantage in Game 1 is at most negligibly different form its advantage in Game 0. </p><p>Note that R &lt; τ by the way that the game generates the matrices R 0 , D 0 and D 1 . 5. Output CT * 0 = (c 0 , c 1 , c 2 , c 3 , c 4 , k). We have that c 0 , c 2 are distributed exactly as in the previous game, besides</p><p>where the distribution of e 1 , e 3 and e 4 are statistically close to D ℓω Z,2rτ , D λ Z,2rτ and D ω Z,2rτ , respectively. So we yields that Game 1 and Game 2 are statistically close in the adversary's point of view, the adversary's advantage against Game 2 will be the same as Game 1.</p><p>Game 3. In this game, we keep changing how the challenge ciphertext is created. The challenger C does:</p><p>in Game 3 is uniformly random over Z λ q . Therefore, the ciphertext is independent from m b in the adversary A's view. Hence, both CT * 0 and CT * 1 is statistically close to the uniform distribution over the ciphertext space, and the adversary A has no advantage in winning the game. We have</p><p>Moreover, using the same reduction technique as in the Anonymity Game in the previous subsection, we can construct a simulator B that solves LWE problem if adversary A is able to distinguish between Game 2 and Game 3. Therefore we have</p><p>which completes the proof of Theorem 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>In this paper, we propose a Lattice-based Anonymous Hierarchical Identity-Based Encryption scheme with Traceable Identities (AHIBET) and prove that our scheme is secure in the standard model based on the decisional LWE assumption.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Efficient lattice (H)IBE in the standard model</title>
		<author>
			<persName><forename type="middle">Shweta</forename><surname>Abb10a</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2010, 29th Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Henri</forename><surname>Gilbert</surname></persName>
		</editor>
		<meeting><address><addrLine>Monaco / French Riviera</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-06-03">May 30 -June 3, 2010. 2010</date>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="553" to="572" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Lattice basis delegation in fixed dimension and shorterciphertext hierarchical ibe</title>
		<author>
			<persName><forename type="middle">Shweta</forename><surname>Abb10b</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2010</title>
		<editor>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="98" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient selective-id secure identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2004, International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Interlaken, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">May 2-6, 2004. 2004</date>
			<biblScope unit="volume">3027</biblScope>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
	<note>Christian Cachin and Jan Camenisch</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hierarchical identity based encryption with constant size ciphertext</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eu-Jin</forename><surname>Goh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2005, 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Ronald</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Aarhus, Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">May 22-26, 2005. 2005</date>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="440" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Anonymous identity based encryption with traceable identities</title>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Blazy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laura</forename><surname>Brouilhet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Duong</forename><surname>Hieu Phan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Availability, Reliability and Security, ARES &apos;19</title>
		<meeting>the 14th International Conference on Availability, Reliability and Security, ARES &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the weil pairing</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2001, 21st Annual International Cryptology Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Joe</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Santa Barbara, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">August 19-23, 2001. 2001</date>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="213" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Practical implementation of ring-sis/lwe based signature and IBE</title>
		<author>
			<persName><forename type="first">Pauline</forename><surname>Bert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre-Alain</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adeline</forename><surname>Roux-Langlois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohamed</forename><surname>Sabt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Post-Quantum Cryptography -9th International Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Tanja</forename><surname>Lange</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Rainer</forename><surname>Steinwandt</surname></persName>
		</editor>
		<meeting><address><addrLine>PQCrypto; Fort Lauderdale, FL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018-04-09">2018. April 9-11, 2018. 2018</date>
			<biblScope unit="volume">10786</biblScope>
			<biblScope unit="page" from="271" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Anonymous hierarchical identity-based encryption (without random oracles)</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Bw06a</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Boyen</surname></persName>
		</author>
		<author>
			<persName><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2006</title>
		<editor>
			<persName><forename type="first">Cynthia</forename><surname>Dwork</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="290" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Compact group signatures without random oracles</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2006</title>
		<editor>
			<persName><forename type="first">Serge</forename><surname>Vaudenay</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="427" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Bonsai trees, or how to delegate a lattice basis</title>
		<author>
			<persName><forename type="first">David</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eike</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="523" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">State-of-the-art, challenges, and open issues in the integration of internet of things and cloud computing</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Díaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Martín</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bartolomé</forename><surname>Rubio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Netw. Comput. Appl</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="99" to="117" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">GS02. Craig Gentry and Alice Silverberg. Hierarchical id-based cryptography</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vinod</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2002, 8th International Conference on the Theory and Application of Cryptology and Information Security</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Yuliang</forename><surname>Zheng</surname></persName>
		</editor>
		<meeting><address><addrLine>Victoria, British Columbia, Canada; Queenstown, New Zealand</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">May 17-20, 2008. 2008. December 1-5, 2002. 2002</date>
			<biblScope unit="volume">2501</biblScope>
			<biblScope unit="page" from="548" to="566" />
		</imprint>
	</monogr>
	<note>Trapdoors for hard lattices and new cryptographic constructions Proceedings of the 40th Annual ACM Symposium on Theory of Computing</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Anonymous communication via anonymous identity-based encryption and its application in iot</title>
		<author>
			<persName><surname>Jll + 18. Liaoliang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tong</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammed</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haseeb</forename><surname>Atiquzzaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xianmin</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wireless Communications and Mobile Computing</title>
		<imprint>
			<date type="published" when="2018">2018:1-8, 11 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Partitioning via non-linear polynomial functions: More compact ibes from ideal lattices and bilinear maps</title>
		<author>
			<persName><forename type="first">Shuichi</forename><surname>Katsumata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shota</forename><surname>Yamada</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Quantum-resistant anonymous IBE with traceable identities</title>
		<author>
			<persName><surname>Ltt + 21</surname></persName>
		</author>
		<author>
			<persName><surname>Zi-Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi-Fan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raylin</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masahiro</forename><surname>Tso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu-Chi</forename><surname>Mambo</surname></persName>
		</author>
		<author>
			<persName><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptol. ePrint Arch</title>
		<imprint>
			<biblScope unit="page">33</biblScope>
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Trapdoors for lattices: Simpler, tighter, faster, smaller</title>
		<author>
			<persName><forename type="first">Daniele</forename><surname>Micciancio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="700" to="718" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Chris Peikert. Bonsai trees (or, arboriculture in lattice-based cryptography)</title>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
	<note>Pei09</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On lattices, learning with errors, random linear codes, and cryptography</title>
		<author>
			<persName><forename type="middle">Oded</forename><surname>Reg09</surname></persName>
		</author>
		<author>
			<persName><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">34</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Identity-based cryptosystems and signature schemes</title>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology, Proceedings of CRYPTO &apos;84</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Blakley</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Chaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Santa Barbara, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1984">August 19-22, 1984. 1984</date>
			<biblScope unit="volume">196</biblScope>
			<biblScope unit="page" from="47" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient lattice hibe in the standard model with shorter public parameters</title>
		<author>
			<persName><forename type="middle">Kunwar</forename><surname>Srb14</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Pandu Rangan</surname></persName>
		</author>
		<author>
			<persName><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information and Communication Technology</title>
		<editor>
			<persName><forename type="first">Made</forename><forename type="middle">Sudiana</forename><surname>Linawati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Erich</forename><forename type="middle">J</forename><surname>Mahendra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">Min</forename><surname>Neuhold</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ilsun</forename><surname>Tjoa</surname></persName>
		</editor>
		<editor>
			<persName><surname>You</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="542" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient identity-based encryption without random oracles</title>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2005, 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Ronald</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Aarhus, Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">May 22-26, 2005. 2005</date>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="114" to="127" />
		</imprint>
	</monogr>
	<note>Wat05. Brent Waters</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
