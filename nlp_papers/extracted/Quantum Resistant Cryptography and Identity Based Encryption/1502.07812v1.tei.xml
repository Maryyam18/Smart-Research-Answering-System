<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Anonymous HIBE with Short Ciphertexts: Full Security in Prime Order Groups *</title>
				<funder>
					<orgName type="full">MSIP (Ministry of Science, ICT &amp; Future Planning)</orgName>
				</funder>
				<funder>
					<orgName type="full">Korea</orgName>
				</funder>
				<funder ref="#_Mh3N24A">
					<orgName type="full">ITRC</orgName>
				</funder>
				<funder ref="#_GaU3qwK">
					<orgName type="full">NIPA (National IT Industry Promotion Agency)</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2015-02-27">27 Feb 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kwangsu</forename><surname>Lee</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Korea University</orgName>
								<address>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jong</forename><surname>Hwan</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Columbia University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Park</forename><forename type="middle">‡</forename><surname>Dong</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Hoon</forename><surname>Lee</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Sangmyung University</orgName>
								<address>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Korea University</orgName>
								<address>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Korea University</orgName>
								<address>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Anonymous HIBE with Short Ciphertexts: Full Security in Prime Order Groups *</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2015-02-27">27 Feb 2015</date>
						</imprint>
					</monogr>
					<idno type="MD5">A5A64B265F345871A43F2AFBBA606CAB</idno>
					<idno type="arXiv">arXiv:1502.07812v1[cs.CR]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2" ident="GROBID" when="2025-11-28T12:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<label type="revision">a91ee48</label>
					<label type="parameters">startPage=-1, endPage=-1, consolidateCitations=0, consolidateHeader=0, consolidateFunders=0, includeRawAffiliations=false, includeRawCitations=false, includeRawCopyrights=false, generateTeiIds=false, generateTeiCoordinates=[], sentenceSegmentation=false, flavor=null</label>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Identity-based encryption</term>
					<term>Hierarchical identity-based encryption</term>
					<term>Anonymity</term>
					<term>Full model security</term>
					<term>Bilinear maps</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Anonymous Hierarchical Identity-Based Encryption (HIBE) is an extension of Identity-Based Encryption (IBE), and it provides not only a message hiding property but also an identity hiding property. Anonymous HIBE schemes can be applicable to anonymous communication systems and public key encryption systems with keyword searching. However, previous anonymous HIBE schemes have some disadvantages that the security was proven in the weaker model, the size of ciphertexts is not short, or the construction was based on composite order bilinear groups. In this paper, we propose the first efficient anonymous HIBE scheme with short ciphertexts in prime order (asymmetric) bilinear groups, and prove its security in the full model with an efficient reduction. To achieve this, we use the dual system encryption methodology of Waters. We also present the benchmark results of our scheme by measuring the performance of our implementation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Hierarchical Identity-Based Encryption (HIBE) is an extension of Identity-Based Encryption (IBE) that uses an identity as a public key. In HIBE, a user's identity is represented as a hierarchical tree structure and an upper level user can delegate the private key generation capability to a lower level user. Horwitz and Lynn introduced the concept of HIBE to reduce the burden of the private-key generator of IBE <ref type="bibr" target="#b26">[27]</ref>. After the introduction of HIBE, it was shown that HIBE can have various applications like identity-based signature <ref type="bibr" target="#b24">[25]</ref>, public-key broadcast encryption <ref type="bibr" target="#b19">[20]</ref>, forward-secure public key encryption <ref type="bibr" target="#b13">[14]</ref>, and chosenciphertext secure HIBE <ref type="bibr" target="#b14">[15]</ref>.</p><p>Recently, as a result of the increasing concern with users' privacy, the need for cryptographic systems that protect users' privacy also increases. Anonymous HIBE can provide users' privacy by supporting not only the message hiding property but also the identity hiding property that hides identity information in ciphertexts. Abdalla et al. formalized the concept of anonymous HIBE <ref type="bibr" target="#b0">[1]</ref>. After that, Boyen and Waters proposed the first secure anonymous HIBE scheme without random oracles <ref type="bibr" target="#b12">[13]</ref>. The main applications of anonymous HIBE are anonymous communication systems that provide anonymity between a received message and a true sender and public key encryption systems with keyword searching that enable keyword searches on encrypted data <ref type="bibr" target="#b7">[8]</ref>.</p><p>The security model of anonymous HIBE is defined as a game between a challenger and an adversary. In this game, the adversary adaptively requests private keys in the private key query step and selects two hierarchical identities ID 0 , ID 1 and two messages M 0 , M 1 in the challenge step. Next, the adversary is given a challenge ciphertext of ID γ , M γ where γ is a random bit chosen by the challenger. The adversary wins the game if he can correctly guess γ. The security model is divided as a selective model where the adversary should commit the target hierarchical identities in the initial step and a full model where the adversary can select the target hierarchical identities in the challenge step. Generally a selectively secure HIBE scheme is converted to a fully secure HIBE scheme, but the reduction is inefficient <ref type="bibr" target="#b4">[5]</ref>. The efficiency of the reduction is important not only for theoretical reasons but also for practical reasons.</p><p>Let Adv A be the advantage of an adversary A that breaks a scheme and Adv B be the advantage of an algorithm B that breaks an assumption using the adversary A. Suppose that Adv A ≤ L • Adv B where L is a reduction loss. Let λ , k be the security level of the scheme and the assumption, respectively. If the assumption provides the k-bit security, then it guarantees that Adv B ≤ 1/2 k for any PPT algorithm B. Then we can derive Adv A ≤ L • 1/2 k from two inequalities Adv A ≤ L • Adv B and Adv B ≤ 1/2 k . To construct the scheme that provides the λ -bit security, it should be guaranteed that Adv A ≤ 1/2 λ for any PPT adversary A. It is easy to achieve this by setting L • 1/2 k ≤ 1/2 λ since Adv A ≤ L • 1/2 k . Thus we can derive a relation k ≥ λ + log 2 (L). This relation says that the bit size k of a group order for the assumption should be larger than λ + log 2 (L) to construct the scheme with the λ -bit security. For example, if there is a selectively secure scheme with a hierarchical depth l = 10, then we should select k = 880 since λ = 80 and L = 2 λ l . Therefore, an ideal anonymous HIBE scheme should be fully secure with a reduction loss less than c•q for a polynomial value q and a constant c.</p><p>To construct a fully secure HIBE scheme with an efficient reduction, the new proof methodology named the dual system encryption method was proposed by Waters <ref type="bibr" target="#b44">[45]</ref>. In the dual system encryption method, ciphertexts and private keys can be a normal type or a semi-functional type, and the semi-functional types of ciphertexts and private keys are only used in security proofs. Additionally, the normal type and the semi-functional type are indistinguishable, and the semi-functional ciphertexts are not decrypted by using the semi-functional private keys. The proof of the dual system encryption method consists of hybrid games that change a normal ciphertext and normal private keys to a semi-functional ciphertext and semi-functional private keys. Using this methodology, Waters proposed a fully secure HIBE scheme with linear-size ciphertexts and a fully secure HIBE scheme with constant-size ciphertexts <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b44">45]</ref>. The dual system encryption method can be used to prove the security of fully secure attribute-based encryption <ref type="bibr" target="#b30">[31]</ref>, fully secure predicate encryption <ref type="bibr" target="#b36">[37]</ref>, and leakage-resilient cryptography <ref type="bibr" target="#b31">[32]</ref>.</p><p>The first secure anonymous HIBE scheme was proposed by Boyen and Waters <ref type="bibr" target="#b12">[13]</ref>, and it was proven to be selectively secure without random oracles. After the first construction of anonymous HIBE, several anonymous HIBE schemes were presented, but they were only proved to be secure in the selective model <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b40">41]</ref>. Recently, De Caro et al. proposed a fully secure anonymous HIBE scheme with short ciphertexts by using the dual system encryption method <ref type="bibr" target="#b15">[16]</ref>. However, their scheme is inefficient since the scheme is based on composite order groups where the group order is a product of four prime numbers. One may use the conversion method of Freeman <ref type="bibr" target="#b21">[22]</ref> to construct a scheme in prime order groups from a scheme in composite order groups, but this method can not be applied to the dual system encryption method of Lewko and Waters <ref type="bibr" target="#b32">[33]</ref> since it does not provide the parameter hiding property in composite order groups <ref type="foot" target="#foot_0">1</ref> . Lewko recently devised another conversion method for the dual system encryption method and constructed a (nonanonymous) unbounded HIBE scheme with linear-size ciphertexts in prime order groups <ref type="bibr" target="#b29">[30]</ref>. However, this method is not known to be applicable for the construction of an anonymous HIBE scheme with constant-size ciphertexts since it uses dual pairing vector spaces (DPVS) <ref type="foot" target="#foot_1">2</ref> .</p><p>Anonymous HIBE can also be constructed from Predicate Encryption (PE) with the delegation capability. Shi and Waters constructed an anonymous HIBE scheme with linear-size ciphertexts from a delegatable Hidden Vector Encryption (dHVE) scheme <ref type="bibr" target="#b41">[42]</ref> and Okamoto and Takashima constructed an anonymous HIBE scheme with linear-size ciphertexts from a Hierarchical Inner Product Encryption (HIPE) scheme <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b38">39]</ref>. However, currently known anonymous HIBE schemes from PE schemes with the delegation capability only have linear-size ciphertexts. It is also possible to derive anonymous HIBE from anonymous Spatial Encryption (SE) <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b18">19]</ref>. However, there is no known anonymous SE scheme with constant-size ciphertexts. Thus the construction of efficient and fully secure anonymous HIBE with short ciphertexts is an unsolved problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contributions</head><p>Motivated by the above challenge, we propose the first fully secure and anonymous HIBE scheme with short ciphertexts in prime order (asymmetric) bilinear groups. The comparison between previous HIBE schemes and ours is given in Table <ref type="table">1</ref>. To construct a fully secure and anonymous HIBE scheme, we use the IBE scheme in prime order (asymmetric) bilinear groups of Lewko and Waters <ref type="bibr" target="#b32">[33]</ref>. Note that their IBE scheme does not even converted to a (non-anonymous) HIBE scheme with short ciphertexts since it does not support private key re-randomization 3 .</p><p>To construct an anonymous HIBE scheme, we should devise techniques for private key re-randomization and ciphertext anonymization. The private key re-randomization process is required in the delegation algo-SKOS-HIBE <ref type="bibr" target="#b40">[41]</ref> Yes</p><formula xml:id="formula_0">Ω(2 λ l ) No O(lλ ) O(lλ ) 3k + k T q-Type Ducas-HIBE [21] Yes Ω(2 λ l ) Yes O(lλ ) O(lλ ) 3k + k T q-Type LL-HIBE [29] Yes Ω(2 λ l ) Yes O(lλ ) O(lλ ) 6k + k T q-Type DIP-HIBE [16] Yes Ω(q) No O(lλ ) O(lλ ) 2k + k T Static LOSTW-HIPE [31] Yes Ω(lq) Yes O(l 4 λ ) O(l 3 λ ) O(l 2 λ ) q-Type OT-HIPE [37] Yes Ω(l 2 q) Yes O(l 3 λ ) O(l 4 λ ) O(l 2 λ ) DLIN OT-HIPE [39] Yes Ω(lq) Yes O(l 2 λ ) O(l 2 λ ) O(lλ ) DLIN Ours Yes Ω(q) Yes O(lλ ) O(lλ ) 6k + k T Static</formula><p>ANON = anonymity, R.L. = reduction loss, Prime = prime order bilinear groups λ = security parameter, l = hierarchical depth, q = polynomial value, k, k T = the bit size of group G and G T rithm of HIBE and anonymous HIBE. In HIBE, private keys are simply re-randomized using the public elements of public parameters. However, private keys of anonymous HIBE cannot be simply re-randomized using the public elements because an attacker can break anonymity using the public elements. To solve this problem, we may use the private re-randomization technique of Boyen and Waters <ref type="bibr" target="#b12">[13]</ref> that re-randomizes private keys using the private elements of private keys. Nevertheless, if the private re-randomization technique is used in the dual system encryption method, then additional random values in semi-functional private keys are not completely randomized in the proof that distinguishes a normal private key from a semifunctional private key.</p><p>To resolve this difficulty, we define two types of semi-functional private keys as semi-functional type-1 and semi-functional type-2, and we show that it is hard to distinguish these two types of semi-functional private keys. The main idea to provide ciphertext anonymity is that the Decisional Diffie-Hellman (DDH) assumption still holds in asymmetric bilinear groups of prime order. We prove the anonymity property of our scheme by introducing a new assumption since the simple DDH assumption is not enough for the security proof. Furthermore, we implemented our anonymous HIBE scheme using the PBC library to support our claim of efficiency and we measured the performance of our scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>IBE was introduced to solve the certificate management problem in public key encryption systems, but it additionally requires a Private-Key Generator (PKG) <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. HIBE was invented to reduce the burden of the IBE's PKG by re-arranging an identity as a hierarchical tree structure and by allowing the delegation of private key generation from upper level users to lower level users <ref type="bibr" target="#b26">[27]</ref>. Gentry and Silverberg proposed the first HIBE scheme in the random oracle model <ref type="bibr" target="#b24">[25]</ref>. Canetti et al. constructed the first HIBE scheme without random oracles and introduced a selective model to prove the security of their scheme <ref type="bibr" target="#b13">[14]</ref>. The selective model was widely used in the security proof of IBE and HIBE even though it is weaker than the full model. For instance, Boneh and Boyen proposed an efficient HIBE scheme with linear-size ciphertexts <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>, and Boneh et al. proposed an HIBE scheme with constant-size ciphertexts <ref type="bibr" target="#b6">[7]</ref>.</p><p>To construct a fully secure HIBE scheme, Boneh and Boyen showed that a selectively secure HIBE scheme is naturally converted to a fully secure HIBE scheme with exponential loss of a reduction efficiency <ref type="bibr" target="#b4">[5]</ref>. However, this approach has a serious problem -that is, the efficiency of the reduction is 1/Ω(2 λ l ) where λ is a security parameter and l is the maximum hierarchical depth. To remedy this situation, Waters proposed an HIBE scheme by extending his fully secure IBE scheme with an efficient reduction to a HIBE scheme <ref type="bibr" target="#b43">[44]</ref>, and Chatterjee and Sarkar improved the efficiency of Waters' scheme <ref type="bibr" target="#b17">[18]</ref>. However, these schemes also have the problem of an inefficient reduction 1/Ω(q l ) in the hierarchical setting where q is a polynomial value. Gentry and Halevi proposed another fully secure HIBE scheme with an efficient reduction by using complex assumptions <ref type="bibr" target="#b23">[24]</ref>. Recently, Waters introduced the dual system encryption method that can be used to construct a fully secure HIBE scheme with an efficient reduction under simple assumptions <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b44">45]</ref>.</p><p>Anonymous IBE is related to public key encryption with keyword search (PEKS) <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b22">23]</ref>, and the concept of anonymous HIBE was introduced by Abdalla et al. <ref type="bibr" target="#b0">[1]</ref> by extending the concept of anonymous IBE. Boyen and Waters proposed the first anonymous HIBE scheme without random oracles and proved its security in the selective model <ref type="bibr" target="#b12">[13]</ref>. For the construction of anonymous HIBE, they devised a linear splitting technique for ciphertext anonymity and a private re-randomization technique for private key randomization. Seo et al. proposed the first anonymous HIBE scheme with short ciphertexts in composite order bilinear groups <ref type="bibr" target="#b40">[41]</ref>. Ducas constructed anonymous HIBE schemes using asymmetric bilinear groups of prime order <ref type="bibr" target="#b20">[21]</ref>. Lee and Lee proposed an efficient anonymous HIBE scheme with short ciphertexts that is secure in all types of bilinear groups of prime order <ref type="bibr" target="#b28">[29]</ref>. De Caro et al. proposed the first fully secure and anonymous HIBE scheme with short ciphertexts using the dual system encryption method in composite order bilinear groups <ref type="bibr" target="#b15">[16]</ref>.</p><p>HIBE schemes also can be constructed from Attribute Based Encryption (ABE) schemes <ref type="bibr" target="#b25">[26]</ref> and Predicate Encryption (PE) schemes with delegation capabilities <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b41">42]</ref>. PE schemes with linear-size ciphertexts that have the delegation capability include the dHVE scheme of Shi and Waters in composite order bilinear groups <ref type="bibr" target="#b41">[42]</ref> and HIPE schemes of Okamoto and Takashima based on dual pairing vector spaces <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b38">39]</ref>. A non-anonymous HIPE scheme based on dual pairing vector spaces can have constant-size ciphertexts, but the ciphertext should contain a linear-size identity vector <ref type="bibr" target="#b37">[38]</ref>. Though bilinear groups were widely used in the construction of HIBE, some HIBE schemes were designed in lattices <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b16">17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We define anonymous HIBE and give the formal definition of its full model security. Let I be an identity space and M be a message space. A hierarchical identity ID of depth c is defined as an identity vector (I 1 , . . . , I c ) ∈ I c . A hierarchical identity ID = (I 1 , . . . , I c ) of depth c is a prefix of a hierarchical identity</p><formula xml:id="formula_1">ID ′ = (I ′ 1 , . . . , I ′ d ) of depth d if c ≤ d and for all i ∈ {1, . . . , c}, I i = I ′ i .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Anonymous HIBE</head><p>An anonymous HIBE scheme consists of five algorithms (Setup, KeyGen, Delegate, Encrypt, Decrypt).</p><p>Formally it is defined as:</p><formula xml:id="formula_2">Setup(1 λ , l).</formula><p>The setup algorithm takes as input a security parameter 1 λ and a maximum hierarchical depth l. It outputs a master key MK and public parameters PP. KeyGen(ID, MK, PP). The key generation algorithm takes as input a hierarchical identity ID of depth m where m ≤ l, the master key MK, and the public parameters PP. It outputs a private key SK ID for ID. Delegate(ID ′ , SK ID , PP). The delegation algorithm takes as input a hierarchical identity ID ′ of depth m + 1 where m+1 ≤ l, a private key SK ID for a hierarchical identity ID of depth m, and the public parameters PP. If ID is a prefix of ID ′ , then it outputs a delegated private key SK ID ′ for ID ′ . Encrypt(ID, M, PP). The encryption algorithm takes as input a hierarchical identity ID of depth n where n ≤ l, a message M ∈ M, and the public parameters PP. It outputs a ciphertext CT for ID and M. Decrypt(CT, SK ID , PP). The decryption algorithm takes as input a ciphertext CT for a hierarchical identity ID ′ , a private key SK ID for a hierarchical identity ID, and the public parameters PP. If ID = ID ′ , then it outputs an encrypted message M.</p><p>The correctness property of anonymous HIBE is defined as follows: For all MK, PP generated by Setup, all ID, ID ′ ∈ I n , any SK ID generated by KeyGen, and any M, it is required that</p><formula xml:id="formula_3">• If ID = ID ′ , then Decrypt(Encrypt(ID ′ , M, PP), SK ID , PP) = M.</formula><p>• If ID = ID ′ , then Decrypt(Encrypt(ID ′ , M, PP), SK ID , PP) =⊥ with all but negligible probability.</p><p>The second condition of the correctness property is not a trivial one to satisfy since the decryption algorithm of anonymous HIBE cannot easily check whether ID = ID ′ or not because of anonymity. One possible relaxation is to use a computational condition instead of a statistical condition. For a computational condition, we can use weak robustness of Abdalla et al. <ref type="bibr" target="#b1">[2]</ref>.</p><p>The security property of anonymous HIBE under a chosen plaintext attack is defined in terms of the following experiment between a challenger C and a PPT adversary A:</p><p>1. Setup: C runs Setup(1 λ , l) to generate a master key MK and public parameters PP. It keeps MK to itself and gives PP to A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Query 1:</head><p>A may adaptively request a polynomial number of private keys for hierarchical identities ID 1 , . . . , ID q 1 of arbitrary depths. In response, C gives the corresponding private keys SK ID 1 , . . . , SK ID q 1 to A by running KeyGen(ID i , MK, PP).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Challenge:</head><p>A submits two hierarchical identities ID * 0 , ID * 1 ∈ I n and two messages M * 0 , M * 1 with equal length subject to the restriction: for all ID i of private key queries, ID i is not a prefix of ID * 0 and ID * 1 . C flips a random coin γ ∈ {0, 1} and gives the challenge ciphertext CT * to A by running Encrypt(ID * γ , M * γ , PP).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Query 2:</head><p>A may continue to request a polynomial number of private keys for hierarchical identities ID q 1 +1 , . . . , ID q subject to the restriction as before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>Guess: A outputs a guess γ ′ ∈ {0, 1} of γ, and wins the game if γ ′ = γ.</p><p>The advantage of A is defined as</p><formula xml:id="formula_4">Adv AHIBE A (λ ) = Pr[γ = γ ′ ] -1/2</formula><p>where the probability is taken over all the randomness of the experiment. An anonymous HIBE scheme is fully secure under a chosen plaintext attack if for all PPT adversary A, the advantage of A in the above experiment is negligible in the security parameter λ .</p><p>The security experiment of anonymous HIBE can be relaxed to complete one introduced by Shi and Waters <ref type="bibr" target="#b41">[42]</ref> that traces the path of delegation. Our definition of the security experiment that does not trace the path of delegation is stronger than the complete one of Shi and Waters. Thus if an anonymous HIBE scheme is secure in the security experiment of this section, then the scheme is also secure in the complete one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Asymmetric Bilinear Groups</head><p>Let G, Ĝ and G T be multiplicative cyclic groups of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ. The bilinear map e : G × Ĝ → G T has the following properties:</p><formula xml:id="formula_5">1. Bilinearity: ∀u ∈ G, ∀ v ∈ Ĝ and ∀a, b ∈ Z p , e(u a , vb ) = e(u, v) ab .</formula><p>2. Non-degeneracy: ∃g, ĝ such that e(g, ĝ) has order p, that is, e(g, ĝ) is a generator of G T .</p><p>We say that G, Ĝ, G T are bilinear groups with no efficiently computable isomorphisms if the group operations in G, Ĝ, and G T as well as the bilinear map e are all efficiently computable, but there are no efficiently computable isomorphisms between G and Ĝ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Complexity Assumptions</head><p>We introduce five assumptions under asymmetric bilinear groups of prime order. Assumptions 1 and 2 were introduced in Lewko and Waters <ref type="bibr" target="#b32">[33]</ref>, and Assumptions 3 and 4 are well-known. Assumption 5 (Asymmetric 3-Party Diffie-Hellman) is an asymmetric version of the Composite 3-Party Diffie-Hellman assumption introduced by Boneh and Waters <ref type="bibr" target="#b11">[12]</ref> with a slight modification by augmenting one additional element, and it is secure in the generic group model. Assumption 1 (LW1) Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ respectively. The assumption is that if the challenge values D = ((p, G, Ĝ, G T , e), g, g a , g b , g ab 2 , g b 2 , g b 3 , g c , g ac , g bc , g b 2 c , g b 3 c , ĝ, ĝb ) and T are given, no PPT algorithm B can distinguish T = T 0 = g ab 2 c from T = T 1 = g d with more than a negligible advantage. The advantage of B is defined as</p><formula xml:id="formula_6">Adv A1 B (λ ) = Pr[B(D, T 0 ) = 0] -Pr[B(D, T 1 ) = 0]</formula><p>where the probability is taken over the random choice of a, b, c, d ∈ Z p . Assumption 2 (LW2) Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ respectively. The assumption is that if the challenge values D = ((p, G, Ĝ, G T , e), g, g a , g a 2 , g bx , g abx , g a 2 x , ĝ, ĝa , ĝb , ĝc ) and T are given, no PPT algorithm B can distinguish T = T 0 = ĝbc from T = T 1 = ĝd with more than a negligible advantage. The advantage of B is defined as Adv The assumption is that if the challenge values D = ((p, G, Ĝ, G T , e), g, g a , g b , g c , g ab , g a 2 b , ĝ, ĝa , ĝb ) and T are given, no PPT algorithm B can distinguish T = T 0 = g abc from T = T 1 = g d with more than a negligible advantage. The advantage of B is defined as</p><formula xml:id="formula_7">Adv A5 B (λ ) = Pr[B(D, T 0 ) = 0] -Pr[B(D, T 1 ) = 0]</formula><p>where the probability is taken over the random choice of a, b, c, d ∈ Z p .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Anonymous HIBE</head><p>We construct an anonymous HIBE scheme in prime order (asymmetric) bilinear groups and prove its full model security under static assumptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Construction</head><p>Let I = Z * p . Our anonymous HIBE scheme is described as follows:</p><p>Setup(1 λ , l): This algorithm first generates the asymmetric bilinear groups G, Ĝ, G T of prime order p of bit size Θ(λ ). It chooses random elements g ∈ G and ĝ ∈ Ĝ. It also chooses random exponents ν, φ 1 , φ 2 ∈ Z p and sets τ = φ 1 + νφ 2 . Next, it selects random exponents y h , {y u i } l i=1 , y w , α ∈ Z p and sets h = g y h , ĥ = ĝy h , {u i = g y u i , ûi = ĝy u i } l i=1 , ŵ = ĝy w . It outputs a master key MK = ( ĝ, ĝα , ĥ, { ûi } l i=1 ) and public parameters as</p><formula xml:id="formula_8">PP = g, g ν , g -τ , h, h ν , h -τ , {u i , u ν i , u -τ i } l i=1 , ŵφ 1 , ŵφ 2 , ŵ, Ω = e(g, ĝ) α .</formula><p>KeyGen(ID, MK, PP): This algorithm takes as input a hierarchical identity ID = (I 1 , . . . , I m ) ∈ I m and the master key MK. It first selects random exponents r 1 , c 1 , c 2 , {c 3,i } l i=m+1 ∈ Z p and creates the decryption and delegation components of a private key as</p><formula xml:id="formula_9">K 1,1 = ĝα ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 , K 1,2 = ( ŵφ 2 ) c 1 , K 1,3 = ŵc 1 , K 2,1 = ĝr 1 ( ŵφ 1 ) c 2 , K 2,2 = ( ŵφ 2 ) c 2 , K 2,3 = ŵc 2 , L 3,i,1 = ûr 1 i ( ŵφ 1 ) c 3,i , L 3,i,2 = ( ŵφ 2 ) c 3,i , L 3,i,3 = ŵc 3,i l i=m+1 .</formula><p>Next, it selects random exponents r 2 , c 4 , c 5 , {c 6,i } l i=m+1 ∈ Z p and creates the randomization components of the private key as</p><formula xml:id="formula_10">R 1,1 = ( ĥ m ∏ i=1 ûI i i ) r 2 ( ŵφ 1 ) c 4 , R 1,2 = ( ŵφ 2 ) c 4 , R 1,3 = ŵc 4 , R 2,1 = ĝr 2 ( ŵφ 1 ) c 5 , R 2,2 = ( ŵφ 2 ) c 5 , R 2,3 = ŵc 5 , R 3,i,1 = ûr 2 i ( ŵφ 1 ) c 6,i , R 3,i,2 = ( ŵφ 2 ) c 6,i , R 3,i,3 = ŵc 6,i l i=m+1 .</formula><p>Finally, it outputs a private key as</p><formula xml:id="formula_11">SK ID = K 1,1 , K 1,2 , K 1,3 , K 2,1 , K 2,2 , K 2,3 , {L 3,i,1 , L 3,i,2 , L 3,i,3 } l i=m+1 , R 1,1 , R 1,2 , R 1,3 , R 2,1 , R 2,2 , R 2,3 , {R 3,i,1 , R 3,i,2 , R 3,i,3 } l i=m+1 .</formula><p>Delegate(ID ′ , SK ID , PP): This algorithm takes as input a hierarchical identity ID ′ = (I 1 , . . . , I m+1 ) ∈ I m+1 and a private key SK ID for a hierarchical identity</p><formula xml:id="formula_12">ID = (I 1 , . . . , I m ) ∈ I m where ID is a prefix of ID ′ . Let (W 1 ,W 2 ,W 3 ) = ( ŵφ 1 , ŵφ 2 , ŵ). It first selects random exponents γ 1 , δ 1 , δ 2 , {δ 3,i } l i=m+2</formula><p>∈ Z p and creates the decryption and delegation components of a delegated private key as</p><formula xml:id="formula_13">K ′ 1,k = K 1,k L I m+1 3,m+1,k • (R 1,k R I m+1 3,m+1,k ) γ 1 W δ 1 k 1≤k≤3 , K ′ 2,k = K 2,k • R γ 1 2,k W δ 2 k 1≤k≤3 , L ′ 3,i,k = L 3,i,k • R γ 1 3,i,k W δ 3,i k 1≤k≤3 l i=m+2 .</formula><p>Next, it selects random exponents γ 2 , δ 4 , δ 5 , {δ 6,i } l i=m+2 ∈ Z p and creates the randomization components of the delegated private key as</p><formula xml:id="formula_14">R ′ 1,k = (R 1,k R I m+1 3,m+1,k ) γ 2 W δ 4 k 1≤k≤3 , R ′ 2,k = R γ 2 2,k W δ 5 k 1≤k≤3 , R ′ 3,i,k = R γ 2 3,i,k W δ 6,i k 1≤k≤3 l i=m+2 .</formula><p>Finally, it outputs a delegated private key as</p><formula xml:id="formula_15">SK ID ′ = K ′ 1,1 , K ′ 1,2 , K ′ 1,3 , K ′ 2,1 , K ′ 2,2 , K ′ 2,3 , {L ′ 3,i,1 , L ′ 3,i,2 , L ′ 3,i,3 } l i=m+2 , R ′ 1,1 , R ′ 1,2 , R ′ 1,3 , R ′ 2,1 , R ′ 2,2 , R ′ 2,3 , {R ′ 3,i,1 , R ′ 3,i,2 , R ′ 3,i,3 } l i=m+2 .</formula><p>The distribution of the delegated private key is the same as the original private key since the random values are defined as r ′ 1 = r 1 + r 2 γ 1 , r ′ 2 = r 2 γ 2 where r 1 , r 2 are random exponents in the private key SK ID . Note that c 1 , c 2 , {c 3,i }, c 4 , c 5 , {c 6,i } are perfectly re-randomized since ŵφ 1 , ŵφ 2 , ŵ are publicly known and δ 1 , δ 2 , {δ 3,i }, δ 4 , δ 5 , {δ 6,i } are chosen randomly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Encrypt(ID, M, PP):</head><p>This algorithm takes as input a hierarchical identity ID = (I 1 , . . . , I n ) ∈ I n , a message M ∈ G T , and the public parameter PP. It selects a random exponent t ∈ Z p and outputs a ciphertext as</p><formula xml:id="formula_16">CT = C = Ω t M, C 1,1 = g t , C 1,2 = (g ν ) t , C 1,3 = (g -τ ) t , C 2,1 = (h n ∏ i=1 u I i i ) t , C 2,2 = (h ν n ∏ i=1 (u ν i ) I i ) t , C 2,3 = (h -τ n ∏ i=1 (u -τ i ) I i ) t .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Decrypt(CT, SK ID , PP):</head><p>This algorithm takes as input a ciphertext CT and a private key SK ID for a hierarchical identity ID = (I 1 , . . . , I n ). It outputs the encrypted message as</p><formula xml:id="formula_17">M ← C • 3 ∏ i=1 e(C 1,i , K 1,i ) -1 • 3 ∏ i=1 e(C 2,i , K 2,i ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Correctness</head><p>The first condition of the correctness property can be easily checked by the following equation as</p><formula xml:id="formula_18">3 ∏ i=1 e(C 1,i , K 1,i ) -1 • 3 ∏ i=1 e(C 2,i , K 2,i ) = e(g t , ĝα ( ĥ n ∏ i=1 ûI i i ) r 1 ) -1 • e((h n ∏ i=1 u I i i ) t , ĝr 1 ) = e(g, ĝ) -αt</formula><p>since the inner product of (1, ν, -τ) and (φ 1 , φ 2 , 1) are zero. The second condition of the correctness prop- erty can be satisfied by using the technique of Boneh and Waters <ref type="bibr" target="#b11">[12]</ref> that uses the limited message space.</p><p>If we use a computational condition instead of a statistical condition, then we can achieve weak robustness by using the transformation of Abdalla et al. <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Security Analysis</head><p>Theorem 3.1. The above anonymous HIBE scheme is fully secure under a chosen plaintext attack if Assumptions 1, 2, 3, 4 and 5 hold. That is, for any PPT adversary A, there exist PPT algorithms B 1 , B 2 , B 3 , B 4 , and B 5 such that</p><formula xml:id="formula_19">Adv AHIBE A (λ ) ≤ Adv A1 B 1 (λ ) + q Adv A2 B 2 (λ ) + Adv A3 B 3 (λ ) + Adv A4 B 4 (λ ) + Adv A5 B 5 (λ ).</formula><p>where q is the maximum number of private key queries of A.</p><p>Proof. To prove the security of our scheme, we use the dual system encryption technique of <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b44">45]</ref>. We first describe a semi-functional key generation algorithm and a semi-functional encryption algorithm. They are not used in a real system, but they are used in the security proof. For semi-functionality, we set f = g y f , f = ĝy f where y f is a random exponent in Z p .</p><p>KeyGenSF-1. The semi-functional type-1 key generation algorithm first creates a normal private key using the master key. Let</p><formula xml:id="formula_20">(K ′ 1,1 , . . . , {R ′ 3,i,1 , . . . , R ′ 3,i,3 } l i=m+1</formula><p>) be the normal private key of a hierarchical identity ID = (I 1 , . . . , I m ) with random exponents</p><formula xml:id="formula_21">r 1 , r 2 , c 1 , c 2 , {c 3,i }, c 4 , c 5 , {c 6,i } ∈ Z p . It selects random exponents s k,1 , z k,1 , {z k,2,i } l i=m+1 , s k,2</formula><p>∈ Z p and outputs a semi-functional type-1 private key as</p><formula xml:id="formula_22">K 1,1 = K ′ 1,1 ( f -ν ) s k,1 z k,1 , K 1,2 = K ′ 1,2 f s k,1 z k,1 , K 1,3 = K ′ 1,3 , K 2,1 = K ′ 2,1 ( f -ν ) s k,1 , K 2,2 = K ′ 2,2 f s k,1 , K 2,3 = K ′ 2,3 , L 3,i,1 = L ′ 3,i,1 ( f -ν ) s k,1 z k,2,i , L 3,i,2 = L ′ 3,i,2 f s k,1 z k,2,i , L 3,i,3 = L ′ 3,i,3 l i=m+1 , R 1,1 = R ′ 1,1 ( f -ν ) s k,2 z k,1 , R 1,2 = R ′ 1,2 f s k,2 z k,1 , R 1,3 = R ′ 1,3 , R 2,1 = R ′ 2,1 ( f -ν ) s k,2 , R 2,2 = R ′ 2,2 f s k,2 , R 2,3 = R ′ 2,3 , R 3,i,1 = R ′ 3,i,1 ( f -ν ) s k,2 z k,2,i , R 3,i,2 = R ′ 3,i,2 f s k,2 z k,2,i , R 3,i,3 = R ′ 3,i,3 l i=m+1 .</formula><p>Note that the randomization components should contain the semi-functional part since this semifunctional part enables the correct simulation of the security proof for anonymity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>KeyGenSF-2.</head><p>The semi-functional type-2 key generation algorithm first creates a normal private key using the master key. Let</p><formula xml:id="formula_23">(K ′ 1,1 , . . . , {R ′ 3,i,1 , . . . , R ′ 3,i,3 } l i=m+1 ) be the normal private key of a hierarchical identity ID = (I 1 , . . . , I m ). It selects random exponents s k,1 , z k,1 , {z k,2,i } l i=m+1 , s k,2 , z k,3 , {z k,4,i } l i=m+1 ∈ Z p</formula><p>and outputs a semi-functional type-2 private key the same as the semi-functional type-1 private key except that the randomization components are generated as</p><formula xml:id="formula_24">R 1,1 = R ′ 1,1 ( f -ν ) s k,2 z k,3 , R 1,2 = R ′ 1,2 f s k,2 z k,3 , R 1,3 = R ′ 1,3 , R 2,1 = R ′ 2,1 ( f -ν ) s k,2 , R 2,2 = R ′ 2,2 f s k,2 , R 2,3 = R ′ 2,3 , R 3,i,1 = R ′ 3,i,1 ( f -ν ) s k,2 z k,4,i , R 3,i,2 = R ′ 3,i,2 f s k,2 z k,4,i , R 3,i,3 = R ′ 3,i,3 l i=m+1 .</formula><p>Note that new random exponents z k,3 , {z k,4,i } l i=1 are chosen to generate the randomization components of the semi-functional type-2 private key, whereas the same exponents z k,1 , {z k,2,i } l i=1 of the decryption and delegation components are used to generate the randomization components in the semi-functional type-1 private key.</p><p>EncryptSF. The semi-functional encryption algorithm first creates a normal ciphertext using the public parameters. Let (C ′ ,C ′ 1,1 , . . . ,C ′ 2,3 ) be the normal ciphertext. It selects random exponents s c , z c ∈ Z p and outputs a semi-functional ciphertext as</p><formula xml:id="formula_25">C = C ′ , C 1,1 = C ′ 1,1 , C 1,2 = C ′ 1,2 f s c , C 1,3 = C ′ 1,3 ( f -φ 2 ) s c , C 2,1 = C ′ 2,1 , C 2,2 = C ′ 2,2 f s c z c , C 2,3 = C ′ 2,3 ( f -φ 2 ) s c z c .</formula><p>If we decrypt a semi-functional ciphertext by using a semi-functional type-2 private key, then the decryption fails since an additional element e( f , f ) s c ((s k,1 z k,1 +s k,2 z k,3 γ)-(s k,1 +s k,2 γ)z c ) remains. Note that the decryption can be done after re-randomizing the private key using a random exponent γ.</p><formula xml:id="formula_26">If (s k,1 z k,1 + s k,2 z k,3 γ) = (s k,1 + s k,2 γ)z c ,</formula><p>then the decryption algorithm succeeds. However, the probability of this is negligible since s k,1 , s k,2 , z k,1 , z k,3 , z c , γ are randomly chosen. In case of the semi-functional type-1 private key, the additional random element can be restated as e( f , f ) (s k,1 +s k,2 γ)s c (z k,1 -z c ) . If z k,1 = z c , then the decryption algorithm succeeds. In this case, we say that the private key is nominally semi-functional type-1.</p><p>The security proof consists of a sequence of games. The first game will be the original security game and the last one will be a game such that the adversary has no advantage. We define the games as follows: Game G 0 . This game is the original security game. That is, the private keys and the challenge ciphertext are normal.</p><p>Game G 1 . We first modify G 0 into a new game G 1 . This game is almost identical to G 0 except that the challenge ciphertext is semi-functional.</p><p>Game G 2 . Next, we modify G 1 into a game G 2 . In this game, the private keys are semi-functional type-2 and the challenge ciphertext is semi-functional. Suppose that an adversary makes at most q private key queries. For the security proof, we define a sequence of games</p><formula xml:id="formula_27">G 1,0 , . . . , G ′ 1,k , G 1,k , . . . , G 1,q where G 1,0 = G 1 . In G ′</formula><p>1,k and G 1,k , a normal private key is given to the adversary for all j-th private key queries such that j &gt; k and a semi-functional type-2 private key is given to the adversary for all j-th private key queries such that j &lt; k. However, for k-th private key query, a semi-functional type-1 private key is given to the adversary in G ′ 1,k where as a semi-functional type-2 private key is given in</p><formula xml:id="formula_28">G 1,k . It is obvious that G 1,q is equal to G 2 .</formula><p>Game G 3 . We now define a new game. This game differs from G 2 where the challenge ciphertext component C is replaced by a random element in G T .</p><p>Game G 4 . Finally, we change G 3 to a new game G 4 . In this game, the semi-functional ciphertext components (C 2,1 ,C 2,2 ,C 2,3 ) are formed as (P t , (P ν ) t f s c z c , (P -τ ) t ( f -φ 2 ) s c z c ) where P is a random element in G. In this game, the challenge ciphertext gives no information about the random coin γ. Therefore, the adversary can win this game with probability at most 1/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let Adv</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G j</head><p>A be the advantage of A in G j for j = 0, . . . , 4. Let Adv</p><formula xml:id="formula_29">G 1,k A and Adv G ′ 1,k A be the advantage of A in G 1,k and G ′ 1,k for k = 0, . . . , q. It is clear that Adv AHIBE A (λ ) = Adv G 0 A , Adv G 1,0 A = Adv G 1 A , Adv G 1,q A = Adv G 2</formula><p>A , and Adv G 4 A = 0. From the following five Lemmas, we obtain that it is hard to distinguish G i-1 from G i under the given assumptions. Therefore, we have that</p><formula xml:id="formula_30">Adv AHIBE A (λ ) = Adv G 0 A + 3 ∑ i=1 Adv G i A -Adv G i A -Adv G 4 A ≤ 4 ∑ i=1 Adv G i-1 A -Adv G i A = Adv A1 B 1 (λ ) + q ∑ k=1 Adv A2 B 2 (λ ) + Adv A3 B 3 (λ ) + Adv A4 B 4 (λ ) + Adv A5 B 5 (λ ).</formula><p>This completes our proof of Theorem 3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.2.</head><p>If Assumption 1 holds, then no PPT algorithm can distinguish between G 0 and G 1 with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm</p><formula xml:id="formula_31">B 1 such that Adv G 0 A - Adv G 1 A = Adv A1 B 1 (λ</formula><p>). Lemma 3.3. If Assumption 2 holds, then no PPT algorithm can distinguish between G 1,k-1 and G ′ 1,k with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm B 2 such that</p><formula xml:id="formula_32">Adv G 1,k-1 A -Adv G ′ 1,k A = Adv A2 B 2 (λ ).</formula><p>Lemma 3.4. If Assumption 3 holds, then no PPT algorithm can distinguish between G ′ 1,k and G 1,k with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm B 3 such that Adv</p><formula xml:id="formula_33">G ′ 1,k A - Adv G 1,k A = Adv A3 B 3 (λ ).<label>Lemma</label></formula><p>3.5. If Assumption 4 holds, then no PPT algorithm can distinguish between G 2 and G 3 with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm B 4 such that Adv G 2 A -Adv G 3 A = Adv A4 B 4 (λ ). Lemma 3.6. If Assumption 5 holds, then no PPT algorithm can distinguish between G 3 and G 4 with a non-negligible advantage. That is, for any adversary A, there exists a PPT algorithm B 5 such that Adv</p><formula xml:id="formula_34">G 3 A - Adv G 4 A = Adv A5 B 5 (λ ).</formula><p>The security proof of Lemmas 3.2, 3.3, 3.4, 3.5, and 3.6 are given in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Extensions</head><p>Relaxed Security Model. The original security experiment of anonymous HIBE requires that an adversary should select two hierarchical identities ID * 0 , ID * 1 ∈ I n with equal depth n <ref type="bibr" target="#b0">[1]</ref>. One possible relaxation of the security experiment of anonymous HIBE is to allow the adversary to select two hierarchical identities</p><formula xml:id="formula_35">ID * 0 ∈ I n 1 , ID * 1 ∈ I n 2 with different depths n 1 , n 2 .</formula><p>Our scheme is also fully secure in this relaxed security experiment since the ciphertext size is constant. The two challenge hierarchical identities with different depths only matter in the security proof that distinguishes G 3 from G 4 . In that proof, we showed that the adversary cannot distinguish the challenge hierarchical identity ID * γ from a random value. Thus our scheme is secure in this relaxed experiment since the ciphertext size does not reveal the depth of the hierarchical identity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Performance Analysis</head><p>In this section, we analyze the running time of our scheme, and then we measure the performance of the scheme by implementing it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Runtime Analysis</head><p>To analyze the efficiency of our scheme, we use the abstract cost of expensive mathematical operations. In bilinear groups, the expensive operations are exponentiation operations and pairing operations. Additionally, the efficiency of exponentiations and pairings can be improved by doing m-term exponentiations and m-term pairings respectively. The abstract cost of these operations is defined as follows:</p><p>• MPairCost(G, Ĝ, m): m-term pairing ∏ m i=1 e(g i , ĥi ) where g i ∈ G, h i ∈ Ĝ</p><p>• PairCost(G, Ĝ): pairing e(g, ĥ) where g ∈ G, h ∈ Ĝ</p><p>• MExpCost(G, m): m-term exponentiation ∏ m i=1 g a i i where g i ∈ G</p><p>• ExpCost(G): exponentiation g a where g ∈ G</p><p>Let l be the maximum number of hierarchical depth and d be the depth of ID. We define the abstract costs of the setup algorithm, the key generation algorithm, the delegation algorithm, the encryption algorithm, and the decryption algorithm as SetupCost, GenCost, DelCost, EncCost, DecCost respectively. The abstract costs of these algorithm are obtained as follows:</p><formula xml:id="formula_36">SetupCost(l) ≥ (2l + 4) * ExpCost(G) + 2 * ExpCost( Ĝ) + PairCost(G, Ĝ), GenCost(l, d) ≥ (4(l -d) + 4) * ExpCost( Ĝ) + (2(l -d) + 2) * MExpCost( Ĝ, 2) + d m * MExpCost( Ĝ, m), DelCost(l, d) ≥ (6(l -d) + 6) * MExpCost( Ĝ, 2) + 9 * ExpCost( Ĝ), EncCost(d) ≥ 3d m * MExpCost(G, m) + 6 * ExpCost(G) + ExpCost(G T ), DecCost ≥ 2 * MPairCost(G, Ĝ, 3).</formula><p>In asymmetric bilinear groups, the bit size of Ĝ and the bit size of G T increase proportionally to the embedding degree of asymmetric bilinear groups. Thus the cost of exponentiation in Ĝ is higher than the cost of exponentiation in G. In our scheme, the cost of the key generation algorithm and the cost of the delegation algorithm are higher than the cost of other algorithm since our scheme uses group elements in G for ciphertexts and group elements in Ĝ for private keys, and these costs decrease proportionally to the depth of ID. The cost of the encryption algorithm is small since it uses m-term exponentiations in G, and the cost of the decryption algorithm is constant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementation</head><p>To show the efficiency of our scheme, we present the implementation of our scheme and analyze the performance of it. We use the Pairing Based Cryptography (PBC) library <ref type="bibr" target="#b34">[35]</ref> to implement our scheme, and we use a notebook computer with an Intel Core i5 2.53 GHz CPU as a test machine. We select a 175-bit Miyaji-Nakabayashi-Takano (MNT) curve with embedding degree 6. In the 175-bit MNT curve, the group size of G is about 175 bits, the group size of Ĝ is about 525 bits, and the group size of G T is about 1050 bits. The PBC library on the test machine can compute an exponentiation of G in 1.6 ms, an exponentiation of Ĝ in 20.3 ms, an exponentiation of G T in 4.7 ms, and a pairing in 15.6 ms. Additionally, the PBC library can compute a three-term multi-exponentiation of G in 2.1 ms, a two-term multi-exponentiation of Ĝ in 27.3 ms, a three-term multi-exponentiation of Ĝ in 28.6 ms, and a three-term multi-pairing in 31.2 ms. Therefore, we can obtain the cost of our scheme using the 175-bit MNT curve on the test machine as follows: Let l = 30. The performance results of each algorithms are described in Figure <ref type="figure" target="#fig_2">1</ref>. The setup algorithm takes about 0.936 seconds to generate the public parameters and the master key. The key generation algorithm and the delegation algorithm for one depth take about 4.259 seconds and 5.257 seconds respectively. One method to improve the performance of the key generation algorithm is to preprocess the public parameters and the master key. If the preprocessing method is used, then the cost of the key generation algorithm is reduced to 1/5. This method also can be used in the delegation algorithm.</p><formula xml:id="formula_37">GenCost(l,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Proof of Lemmas</head><p>In this section, we give the security proofs of Lemmas for our HIBE scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Proof of Lemma 3.2 (Indistinguishability of G 0 and G 1 )</head><p>In this proof, private keys are normal and the challenge ciphertext should be normal or semi-functional depending on the T value of the given assumption. The main idea of this proof is that a simulator can only create normal private keys since an element for semi-functional private keys is not given in the assumption and the simulator embeds the T element of the assumption into the challenge ciphertext.</p><p>Simulator. Suppose there exists an adversary A that distinguishes between G 0 and G 1 with a nonnegligible advantage. A simulator B 1 that breaks Assumption 1 using A is given: a challenge tuple</p><formula xml:id="formula_38">D = ((p, G, Ĝ, G T , e), k, k a , k b , k ab 2 , k b 2 , k b 3 , k c , k ac , k bc , k b 2 c , k b 3 c , k, kb ) and T where T = T 0 = k ab 2 c or T = T 1 = k ab 2 c+d .</formula><p>Then B 1 that interacts with A is described as follows: B 1 first chooses random exponents φ 2 , B, {A i } l i=1 , α ∈ Z p and random blinding values y g , y h , {y u i } l i=1 , y w ∈ Z p . It implicitly sets ν = a, φ 1 = b, τ = b + aφ 2 and creates the public parameters as</p><formula xml:id="formula_39">g = k b 2 k y g , g ν = k ab 2 (k a ) y g , g -τ = (k b 3 (k b ) y g (k ab 2 ) φ 2 (k a ) y g φ 2 ) -1 , h = (k b 2 ) B k y h , h ν = (k ab 2 ) B (k a ) y h , h -τ = ((k b 3 ) B (k b ) y h (k ab 2 ) Bφ 2 (k a ) y h φ 2 ) -1 , u i = (k b 2 ) A i k y u i , u ν i = (k ab 2 ) A i (k a ) y u i , u -τ i = ((k b 3 ) A i (k b ) y u i (k ab 2 ) A i φ 2 (k a ) y u i φ 2 ) -1 l i=1 , ŵφ 1 = ( kb ) y w , ŵφ 2 = ky w φ 2 , ŵ = ky w , Ω = (e(k b 3 , kb ) • e(k b 2 , k) 2y g • e(k, k) y 2 g ) α .</formula><p>It also implicitly sets ĝ = kb 2 ky g , ĥ = kb 2 B ky h , ûi = kb 2 A i ky u i for the master key, but it cannot create these elements since kb 2 is not given. Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i and Γ(ID) = B + ∑ m i=1 A i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). To response the private key query, B 1 first selects random exponents r</p><formula xml:id="formula_40">1 , c ′ 1 , c ′ 2 , {c ′ 3,i } l i=m+1 ∈ Z p . It implicitly sets c 1 = -b(α + Γ(ID)r 1 )/y w + c ′ 1 , c 2 = -br 1 /y w + c ′ 2 , {c 3,i = -bA i r 1 /y w + c ′ 3,i } l i=m+1</formula><p>and creates the decryption and delegation components of a private key as</p><formula xml:id="formula_41">K 1,1 = ky g α+∆(ID)r 1 ( ŵφ 1 ) c ′ 1 , K 1,2 = (K 1,3 ) φ 2 , K 1,3 = ( kb ) -(α+Γ(ID)r 1 ) ŵc ′ 1 , K 2,1 = ky g r 1 ( ŵφ 1 ) c ′ 2 , K 2,2 = (K 2,3 ) φ 2 , K 2,3 = ( kb ) -r 1 ŵc ′ 2 , L 3,i,1 = ky u i r 1 ( ŵφ 1 ) c ′ 3,i , L 3,i,2 = (L 3,i,3 ) φ 2 , L 3,i,3 = ( kb ) -A i r 1 ŵc ′ 3,i l i=m+1 .</formula><p>It also creates the randomization components of a private key similarly by selecting random exponents</p><formula xml:id="formula_42">r 2 , c ′ 4 , c ′ 5 , {c ′ 6,i } l i=n+1 ∈ Z p except that R 1,</formula><p>1 does not have ĝα . We omit the detailed description of these. In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . , I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 . B 1 flips a random coin γ ∈ {0, 1} internally. It implicitly sets t = c and creates a challenge ciphertext as</p><formula xml:id="formula_43">C = (e(k b 3 c , kb ) • e(k b 2 c , k) 2y g • e(k c , k) y 2 g ) α • M * γ , C 1,1 = k b 2 c (k c ) y g , C 1,2 = T (k ac ) y g , C 1,3 = ((k b 3 c )(k bc ) y g (T ) φ 2 (k ac ) y g φ 2 ) -1 , C 2,1 = (k b 2 c ) Γ(ID * γ ) (k c ) ∆(ID * γ ) , C 2,2 = (T ) Γ(ID * γ ) (k ac ) ∆(ID * γ ) , C 2,3 = (k b 3 c ) Γ(ID * γ ) (k bc ) ∆(ID * γ ) (T ) φ 2 Γ(ID * γ ) (k ac ) φ 2 ∆(ID * γ ) -1 .</formula><p>Finally, A outputs a guess γ ′ . If γ = γ ′ , B 1 outputs 0. Otherwise, it outputs 1.</p><p>Analysis. We first show that the distribution of the simulation using D, T = T 0 = k ab 2 c is the same as G 0 . The public parameters are correctly distributed since the random blinding values y g , y h , {y u i }, y w are used. The private key is correctly distributed as</p><formula xml:id="formula_44">K 1,1 = ĝα ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 = ( kb 2 +y g ) α ( kb 2 B+y h m ∏ i=1 k(b 2 A i +y u i )I i ) r 1 ( kby w ) -b(α+Γ(ID)r 1 )/y w +c ′ 1 = ky g α+∆(ID)r 1 ( ŵφ 1 ) c ′ 1 , K 2,1 = ĝr 1 ( ŵφ 1 ) c 2 = ( kb 2 +y g ) r 1 ( kby w ) -br 1 /y w +c ′ 2 = ky g r 1 ( ŵφ 1 ) c ′ 2 , L 3,i,1 = ûr 1 i ( ŵφ 1 ) c 3,i = ( kb 2 A i +y u i ) r 1 ( kby w ) -bA i r 1 /y w +c ′ 3,i = ky u i r 1 ( ŵφ 1 ) c ′ 3,i .</formula><p>Note that it can create a normal private key since c 1 , c 2 , {c 3,i }, c 4 , c 5 , {c 6,i } enable the cancellation of kb 2 , but it cannot create a semi-functional private key since ka is not given. The challenge ciphertext is correctly distributed as</p><formula xml:id="formula_45">C 1,1 = g t = (k b 2 +y g ) c = k b 2 c (k c ) y g , C 1,2 = (g ν ) t = k (b 2 +y g )ac = T 0 (k ac ) y g , C 1,3 = (g -τ ) t = (k (b 2 +y g )(b+aφ 2 )c ) -1 = ((k b 3 c )(k bc ) y g (T 0 ) φ 2 (k ac ) y g φ 2 ) -1 , C 2,1 = (h n ∏ i=1 u I * γ,i i ) t = (k b 2 B+y h n ∏ i=1 k (b 2 A i +y u i )I * γ,i ) c = (k b 2 c ) Γ(ID * γ ) (k c ) ∆(ID * γ ) , C 2,2 = (h ν n ∏ i=1 (u ν i ) I * γ,i ) t = (k (b 2 B+y h )a n ∏ i=1 k (b 2 A i +y u i )aI * γ,i ) c = (T 0 ) Γ(ID * γ ) (k ac ) ∆(ID * γ ) , C 2,3 = (h -τ n ∏ i=1 (u -τ i ) I * γ,i ) t = ((k (b 2 B+y h )(b+aφ 2 ) n ∏ i=1 k (b 2 A i +y u i )(b+aφ 2 )I * γ,i ) c ) -1 = ((k b 3 c ) Γ(ID * γ ) (k bc ) ∆(ID * γ ) (T 0 ) φ 2 Γ(ID * γ ) (k ac ) φ 2 ∆(ID * γ ) ) -1 .</formula><p>We next show that the distribution of the simulation using D, T = T 1 = k ab 2 c+d is the same as G 1 . We only consider the distribution of the challenge ciphertext since T is only used in the challenge ciphertext. The only difference between T 0 and T 1 is that T 1 additionally has k d . Thus C 1,2 ,C 1,3 ,C 2,2 ,C 2,3 components that have T in the simulation additionally have</p><formula xml:id="formula_46">k d , (k d ) -φ 2 , (k d ) Γ(ID * γ ) , (k d ) -φ 2 Γ(ID * γ )</formula><p>respectively. If we implicitly set s c = d, z c = Γ(ID * γ ), then the challenge ciphertext is semi-functional. The distribution of this semifunctional challenge ciphertext is the same as G 1 since B, {A i } for z c are information theoretically hidden to A. We obtain Pr</p><formula xml:id="formula_47">[B 1 (D, T 0 ) = 0] -1/2 = Adv G 0 A and Pr[B 1 (D, T 1 ) = 0] -1/2 = Adv G 1</formula><p>A from the above analysis. Thus, we can easily derive the advantage of B 1 as</p><formula xml:id="formula_48">Adv A1 B 1 (λ ) = Pr[B 1 (D, T 0 ) = 0] -Pr[B 1 (D, T 1 ) = 0] = Adv G 0 A -Adv G 1 A .</formula><p>This completes our proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Proof of Lemma 3.3 (Indistinguishability of G 1,k-1 and G ′ 1,k )</head><p>In this proof, the challenge ciphertext is semi-functional and the k-th private key should be normal or semifunctional type-1 depending on the T value of the given assumption. However, the paradox of dual system encryption occurs in this proof since a simulator can create a semi-functional ciphertext to check the type of the k-th private key by decrypting the semi-functional ciphertext using the k-the private key. The main idea to solve this paradox is to use a nominally semi-functional type-1 private key. If the k-th private key is nominally semi-functional type-1, then z k,1 of the nominally semi-functional private key is the same as the z c of a semi-functional challenge ciphertext. Thus the simulator cannot distinguish the type of k-th private key since the decryption of the semi-functional ciphertext using the k-th private key always succeeds. Before proving this lemma, we introduce Assumption 2-A as follows: Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p. Let g, ĝ be generators of G, Ĝ respectively. Assumption 2-A is that if the challenge values D = ((p, G, Ĝ, G T , e), k, k a , k a 2 , k bx , k abx , k a 2 x , k, ka , kb , ky 1 , ky 2 ) and T = (D 1 , D 2 ) are given, no PPT algorithm can distinguish T = ( kby 1 , kby 2 ) from T = ( kd 1 , kd 2 ) with more than a negligible advantage. It is easy to show that if there exists an adversary that breaks Assumption 2-A, then an algorithm can break Assumption 2 with the same probability by setting ky 1 = ( kb ) r 1 ks 1 , ky 2 = ( kb ) r 2 ks 2 , D 1 = (T ) r 1 ( kc ) s 1 , D 2 = (T ) r 1 ( kc ) s 1 where kb , kc , T are given in Assumption 2 and r 1 , r 2 , s 1 , s 2 are random exponents in Z p . The simulated values are correctly distributed since there exists one-to-one correspondence between {r 1 , s 1 , r 2 , s 2 } and {y 1 , y 2 , d 1 , d 2 }.</p><p>Simulator. Suppose there exists an adversary A that distinguishes between G 1,k-1 and G ′ 1,k with a non-negligible advantage. A simulator B 2 that breaks Assumption 2-A using A is given: a challenge tuple</p><formula xml:id="formula_49">D = ((p, G, Ĝ, G T , e), k, k a , k a 2 , k bx , k abx , k a 2 x , k, ka , kb , ky 1 , ky 2 ) and T = (D 1 , D 2 ) where T = T 0 = (D 0 1 , D 0 2 ) = ( kby 1 , kby 2 ) or T = T 1 = (D 1 1 , D 1 2 ) = ( kby 1 +d 1 , kby 2 +d 2 )</formula><p>. Then B 2 that interacts with A is described as follows: B 2 first chooses random exponents ν, y τ , B, {A i } l i=1 , α ∈ Z p and random blinding values y h , {y u i } l i=1 , y w ∈ Z p . It implicitly sets φ 1 = -νb + (a + y τ ), φ 2 = b, τ = a + y τ and creates the public parameters as</p><formula xml:id="formula_50">g = k a , g ν = (k a ) ν , g -τ = (k a 2 (k a ) y τ ) -1 , h = (k a ) B k y h , h ν = (k a ) Bν k y h ν , h -τ = ((k a 2 ) B (k a ) y h +By τ k y h y τ ) -1 , u i = (k a ) A i k y u i , u ν i = (k a ) A i ν k y u i ν , u -τ i = ((k a 2 ) A i (k a ) y u i +A i y τ k y u i y τ ) -1 l i=1 , ŵφ 1 = (( kb ) -ν ka ky τ ) y w , ŵφ 2 = ( kb ) y w , ŵ = ky w , Ω = e(k a , ka ) α .</formula><p>It also sets ĝ = ka , ĝα = ( ka ) α , ĥ = ( ka ) B ky h , { ûi = ( ka ) A i ky u i } l i=1 for the master key. Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i and Γ(ID) = B + ∑ m i=1 A i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). If this is a j-th private key query, then B 2 handles this query as follows:</p><p>• Case j &lt; k : It creates a semi-functional private key by calling KeyGenSF-2 since it knows the master key and the tuple ( f -ν , f , 1) for the semi-functional private key.</p><formula xml:id="formula_51">• Case j = k : It first selects random exponents r ′ 1 , c ′ 1 , c ′ 2 , {c ′ 3,i } l i=m+1 ∈ Z p . It implicitly sets r 1 = -y 1 + r ′ 1 , c 1 = y 1 Γ(ID)/y w + c ′ 1 , c 2 = y 1 /y w + c ′ 2 , {c 3,i = y 1 A i /y w + c ′ 3,i } l i=m+1</formula><p>and creates the decryption and delegation components of a private key as</p><formula xml:id="formula_52">K 1,1 = ĝα ( ky 1 ) -∆(ID) ( ĥ m ∏ i=1 ûI i i ) r ′ 1 (D 1 ) -νΓ(ID) ( ky 1 ) y τ Γ(ID) ( ŵφ 1 ) c ′ 1 , K 1,2 = (D 1 ) Γ(ID) ( ŵφ 2 ) c ′ 1 , K 1,3 = ( ky 1 ) Γ(ID) ŵc ′ 1 , K 2,1 = ĝr ′ 1 (D 1 ) -ν ( ky 1 ) y τ ( ŵφ 1 ) c ′ 2 , K 2,2 = D 1 ( ŵφ 2 ) c ′ 2 , K 2,3 = ky 1 ŵc ′ 2 , L 3,i,1 = ( ky 1 ) -y u i ûr ′ 1 i (D 1 ) -νA i ( ky 1 ) y τ A i ( ŵφ 1 ) c ′ 3,i , L 3,i,2 = (D 1 ) A i ( ŵφ 2 ) c ′ 3,i , L 3,i,3 = ( ky 1 ) A i ŵc ′ 3,i l i=m+1 .</formula><p>It also creates the randomization components of a private key similarly by selecting random exponents r ′ 2 , c ′ 4 , c ′ 5 , {c ′ 6,i } l i=m+1 ∈ Z p except that it uses ky 2 , D 2 instead of ky 1 , D 1 . We omit the detailed description of these.</p><p>• Case j &gt; k : It creates a normal private key by calling KeyGen since it knows the master key.</p><p>In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . , I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 . B 2 flips a random coin γ ∈ {0, 1} internally and chooses a random exponent t ′ ∈ Z p . It implicitly sets t = bx + t ′ , s c = -a 2 x, z c = Γ(ID * γ ) and creates a semi-functional ciphertext as</p><formula xml:id="formula_53">C = e(k abx , ka ) α • e(k a , ka ) αt ′ • M * γ , C 1,1 = k abx g t ′ , C 1,2 = (k abx ) ν (g ν ) t ′ (k a 2 x ) -1 , C 1,3 = (k abx ) -y τ (g -τ ) t ′ , C 2,1 = (k abx ) Γ(ID * γ ) (k bx ) ∆(ID * γ ) (h n ∏ i=1 u I * γ,i i ) t ′ , C 2,2 = (k abx ) Γ(ID * γ )ν (k bx ) ∆(ID * γ )ν (h ν n ∏ i=1 (u ν i ) I * γ,i ) t ′ (k a 2 x ) -Γ(ID * γ ) , C 2,3 = (k abx ) -Γ(ID * γ )y τ (k abx ) -∆(ID * γ ) (k bx ) -∆(ID * γ )y τ (h -τ n ∏ i=1 (u -τ i ) I * γ,i ) t ′ .</formula><p>Finally, A outputs a guess γ ′ . If γ = γ ′ , B 2 outputs 0. Otherwise, it outputs 1.</p><p>Analysis. We first show that the distribution of the simulation using D, T 0 = (D 0 1 , D 0 2 ) = ( kby 1 , kby 2 ) is the same as G 1,k-1 . The public parameters are correctly distributed since the random blinding values y h , {y u i }, y w are used. The k-th private key is correctly distributed as</p><formula xml:id="formula_54">K 1,1 = ĝα ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 = ĝα ( kaB+y h m ∏ i=1 k(aA i +y u i )I i ) -y 1 +r ′ 1 ( ky w (-νb+a+y τ ) ) y 1 Γ(ID)/y w +c ′ 1 = ĝα ( ky 1 ) -∆(ID) ( ĥ m ∏ i=1 ûI i i ) r ′ 1 (D 0 1 ) -νΓ(ID) ( ky 1 ) y τ Γ(ID) ( ŵφ 1 ) c ′ 1 , K 2,1 = ĝr 1 ( ŵφ 1 ) c 2 = ( ka ) -y 1 +r ′ 1 ( ky w (-νb+a+y τ ) ) y 1 /y w +c ′ 2 = ĝr ′ 1 (D 0 1 ) -ν ( ky 1 ) y τ ( ŵφ 1 ) c ′ 2 , L 3,i,1 = ûr 1 i ( ŵφ 1 ) c 3,i = ( kaA i +y u i ) -y 1 +r ′ 1 ( ky w (-νb+a+y τ ) ) y 1 A i /y w +c ′ 3,i = ( ky 1 ) -y u i ûr ′ 1 i (D 0 1 ) -νA i ( ky 1 ) y τ A i ( ŵφ 1 ) c ′ 3,i .</formula><p>The semi-functional challenge ciphertext is correctly distributed as</p><formula xml:id="formula_55">C 1,1 = g t = (k a ) bx+t ′ = k abx g t ′ , C 1,2 = (g ν ) t f s c = (k aν ) bx+t ′ k -a 2 x = (k abx ) ν (g ν ) t ′ (k a 2 x ) -1 , C 1,3 = (g -τ ) t ( f -φ 2 ) s c = (k a(-a-y τ ) ) bx+t ′ k -b(-a 2 x) = (k abx ) -y τ (g -τ ) t ′ , C 2,1 = (h n ∏ i=1 u I * γ,i i ) t = (k aB+y h n ∏ i=1 (k aA i +y u i ) I * γ,i ) bx+t ′ = (k abx ) Γ(ID * γ ) (k bx ) ∆(ID * γ ) (h n ∏ i=1 u I * γ,i i ) t ′ , C 2,2 = (h ν n ∏ i=1 (u ν i ) I * γ,i ) t ( f s c ) z c = (k (aB+y h )ν n ∏ i=1 (k (aA i +y u i )ν ) I * γ,i ) bx+t ′ k -a 2 xΓ(ID * γ ) = (k abx ) Γ(ID * γ )ν (k bx ) ∆(ID * γ )ν (h ν n ∏ i=1 (u ν i ) I * γ,i ) t ′ (k a 2 x ) -Γ(ID * γ ) , C 2,3 = (h -τ n ∏ i=1 (u -τ i ) I * γ,i ) t ( f -φ 2 ) s c z c = (k (aB+y h )(-a-y τ ) n ∏ i=1 (k (aA i +y u i )(-a-y τ ) ) I * γ,i ) bx+t ′ k -b(-a 2 x)Γ(ID * γ ) = (k abx ) -Γ(ID * γ )y τ (k abx ) -∆(ID * γ ) (k bx ) -∆(ID * γ )y τ (h -τ n ∏ i=1 (u -τ i ) I * γ,i ) t ′ .</formula><p>Note that it can create the semi-functional ciphertext with only fixed z c = Γ(ID * γ ) since s c , z c enable the cancellation of k a 2 bx . Even though the simulator uses the fixed z c , the distribution of z c is correct since B, {A i } for z c are information theoretically hidden to A. We next show that the distribution of the simulation using</p><formula xml:id="formula_56">D, T 1 = (D 1 1 , D 1 2 ) = ( kby 1 +d 1 , kby 2 +d 2 )</formula><p>is the same as G ′ 1,k except the k-th private key is nominally semi-functional. We only consider the distribution of the k-th private key since T = (D 1 , D 2 ) is only used in the k-th private key. The only difference between</p><formula xml:id="formula_57">T 0 = (D 0 1 , D 0 2 ) and T 1 = (D 1 1 , D 1 2 ) is that T 1 = (D 1 1 , D<label>1</label></formula><p>2 ) additionally has ( kd 1 , kd 2 ). The decryption and delegation components</p><formula xml:id="formula_58">K 1,1 , K 1,2 , K 2,1 , K 2,2 , {L 3,i,1 , L 3,i,2 }</formula><p>that have D 1 in the simulation additionally have ( kd 1 ) -νΓ(ID) , ( kd 1 ) Γ(ID) , ( kd 1 ) -ν , kd 1 , {( kd 1 ) -νA i , ( kd 1 )</p><formula xml:id="formula_59">A i } re- spectively. The randomization components R 1,1 , R 1,2 , R 2,1 , R 2,2 , {R 3,i,1 , R 3,i,2 } that have D 2 in</formula><p>the simulation also have the additional values except that kd 2 is used instead of kd 1 . If we implicitly set</p><formula xml:id="formula_60">s k,1 = d 1 , z k,1 = Γ(ID), {z k,2,i = A i } l i=m+1 , s k,2 = d 2 ,</formula><p>then the distribution of the k-th private key is the same as G ′ 1,k except that the k-the private key is nominally semi-functional type-1.</p><p>Finally, we show that the adversary cannot distinguish the nominally semi-functional type-1 private key from the semi-functional type-1 private key. The main idea of this proof is that the adversary cannot request a private key for ID that is a prefix of a challenge identity ID * in the security model. Suppose there exists an unbounded adversary, then the adversary can gather the values</p><formula xml:id="formula_61">z k,1 = Γ(ID) = B + ∑ m i=1 A i I i , {z k,2,i = A i } l</formula><p>i=m+1 from the k-the private key query for ID = (I 1 , . . . , I m ) and z c = Γ(ID * γ ) = B + ∑ n i=1 A i I * γ,i from the challenge ciphertext for ID * γ = (I * γ,1 , . . . , I * γ,n ). In case of n ≥ m, the values that are revealed to the adversary are described as</p><formula xml:id="formula_62">       1 I * γ,1 • • • I * γ,m I * γ,m+1 • • • 0 1 I 1 • • • I m 0 • • • 0 0 0 • • • 0 1 • • • 0 . . . . . . . . . . . . . . . . . . . . . 0 0 • • • 0 0 • • • 1                    B A 1 . . . A m A m+1 . . . A l             =        z c z k,1 z k,2,m+1</formula><p>. . .</p><formula xml:id="formula_63">z k,2,l        .</formula><p>It is easy to show that the row rank of the above (lm + 2) × (l + 1) matrix is lm + 2 since there exists an index j such that I j = I * γ, j . It means that the above matrix is non-singular. In case of n &lt; m, the revealed values to the adversary also can be described as a similar matrix equation as the above one. The row rank of this (lm + 2) × (l + 1) matrix is lm + 2 since I m = 0. Therefore these values look random to the unbounded adversary since the matrixes for two cases are non-singular and B, A 1 , . . . , A l are chosen randomly. We obtain Pr</p><formula xml:id="formula_64">[B 2 (D, T 0 ) = 0] -1/2 = Adv G 1,k-1 A and Pr[B 2 (D, T 1 ) = 0] -1/2 = Adv G ′ 1,k</formula><p>A from the above analysis. Thus, we can easily derive the advantage of B 2 as</p><formula xml:id="formula_65">Adv A2 B 2 (λ ) = Pr[B 2 (D, T 0 ) = 0] -Pr[B 2 (D, T 1 ) = 0] = Adv G 1,k-1 A -Adv G ′ 1,k A .</formula><p>This completes our proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Proof of Lemma 3.4 (Indistinguishability of G ′ 1,k and G 1,k )</head><p>In this proof, the challenge ciphertext is semi-functional and the k-th private key should be semi-functional type-1 or semi-functional type-2 depending on the T value of the given assumption. The main idea of this proof is to show that the semi-functional type-1 and semi-functional type-2 private keys are computationally indistinguishable using the given assumption. Before proving this lemma, we introduce Assumption 3-A as follows: Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p. Let g, ĝ be generators of G, Ĝ respectively. Assumption 3-A is that if the challenge values D = ((p, G, Ĝ, G T , e), k, k, kx 1 , kx 2,1 , . . . , kx 2,l , ky ) and T = (D 1 , D 2,1 , . . . , D 2,l ) are given, no PPT algorithm can distinguish T = T 0 = ( kx 1 y , kx 2,1 y , . . . , kx 2,l y ) from T = T 1 = ( kd 1 , kd 2,1 , . . . , kd 2,l ) with more than a negligible advantage. It is easy to show that if there exists an adversary that breaks Assumption 3-A, then an algorithm can break Assumption 3 with the same probability by setting kx 1 = ( ka )</p><formula xml:id="formula_66">r 1 ks 1 , { kx 2,i = ( ka ) r 2,i ks 2,i } l i=1 , ky = kb , D 1 = (T ) r 1 ( kb ) s 1 , {D 2,i = (T ) r 2,i ( kb ) s 2,i } l i=1</formula><p>where ka , kb , T are given in Assumption 3 and r 1 , s 1 , {r 2,i , s 2,i } l i=1 are random exponents in Z p . The simulated values are correctly distributed since there exists one-to-one correspondence between {r 1 , s 1 , {r 2,i }, {s 2,i }} and {x 1 , {x 2,i }, d 1 , {d 2,i }}.</p><p>Simulator. Suppose there exists an adversary A that distinguishes between G ′ 1,k and G 1,k with a nonnegligible advantage. A simulator B 3 that breaks Assumption 3-A using A is given: a challenge tuple D = ((p, G, Ĝ, G T , e), k, k, kx 1 , kx 2,1 , . . . , kx 2,l , ky ) and T = (D 1 , . . . , D 2,l ) where T = T 0 = (D 0 1 , . . . , D 0 2,l ) = ( kx 1 y , kx 2,1 y , . . . , kx 2,l y ) or T = T 1 = (D 1 1 , . . . , D 1 2,l ) = ( kd 1 , kd 2,1 , . . . , kd 2,l ). Then B 3 that interacts with A is described as follows: B 3 first chooses random exponents ν, φ 1 , φ 2 , α ∈ Z p and random blinding values y g , y h , {y u i } l i=1 , y w ∈ Z p . It implicitly sets τ = φ 1 + νφ 2 and sets g = k y g , ĝ = ky g , h = k y h , ĥ = ky h , {u i = k y u i , ûi = ky u i } l i=1 , ŵ = ky w . It creates the public parameters as</p><formula xml:id="formula_67">PP = g, g ν , g -τ , h, h ν , h -τ , {u i , u ν i , u -τ i } l i=1 , ŵφ 1 , ŵφ 2 , ŵ, Ω = e(g, ĝ) α</formula><p>and the master key as MK = ( ĝ, ĝα , ĥ, { ûi } l i=1 ). Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). If this is a j-th private key query, then B 3 handles this query as follows:</p><p>• Case j &lt; k : It creates a semi-functional private key by calling KeyGenSF-2 since it knows the master key and the tuple ( f -ν , f , 1) for the semi-functional private key.</p><formula xml:id="formula_68">• Case j = k : It first selects random exponents r 1 , c 1 , c 2 , {c 3,i } l i=m+1 , s k,1 ∈ Z p . It implicitly sets z k,1 = x 1 , {z k,2,i = x 2,i } l</formula><p>i=m+1 and creates the decryption and delegation components of a private key as</p><formula xml:id="formula_69">K 1,1 = ĝα ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 ( kx 1 ) -νs k,1 , K 1,2 = ( ŵφ 2 ) c 1 ( kx 1 ) s k,1 , K 1,3 = ŵc 1 , K 2,1 = ĝr 1 ( ŵφ 1 ) c 2 k-νs k,1 , K 2,2 = ( ŵφ 2 ) c 2 ks k,1 , K 2,3 = ŵc 2 , L 3,i,1 = ûr 1 i ( ŵφ 1 ) c 3,i ( kx 2,i ) -νs k,1 , L 3,i,2 = ( ŵφ 2 ) c 3,i ( kx 2,i ) s k,1 , L 3,i,3 = ŵc 3,i l i=m+1 .</formula><p>Next, it selects random exponents r 2 , c 4 , c 5 , {c 6,i } l i=m+1 ∈ Z p . It implicitly sets s k,2 = y and creates the randomization components of a private key as</p><formula xml:id="formula_70">R 1,1 = ( ĥ m ∏ i=1 ûI i i ) r 2 ( ŵφ 1 ) c 4 (D 1 ) -ν , R 1,2 = ( ŵφ 2 ) c 4 D 1 , R 1,3 = ŵc 4 , R 2,1 = ĝr 2 ( ŵφ 1 ) c 5 ( ky ) -ν , R 2,2 = ( ŵφ 2 ) c 5 ky , R 2,3 = ŵc 5 , R 3,i,1 = ûr 2 i ( ŵφ 1 ) c 6,i (D 2,i ) -ν , R 3,i,2 = ( ŵφ 2 ) c 6,i D 2,i , R 3,i,3 = ŵc 6,i l i=m+1 .</formula><p>• Case j &gt; k : It creates a normal private key by calling KeyGen since it knows the master key.</p><p>In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . ,</p><formula xml:id="formula_71">I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 .</formula><p>B 3 flips a random coin γ ∈ {0, 1} internally. It creates a semi-functional challenge ciphertext by calling EncryptSF on the message M γ and the hierarchical identity ID * γ since it knows the tuple (1, f , f -φ 2 ) for the semi-functional ciphertext. Finally, A outputs a guess γ ′ . If γ = γ ′ , B 3 outputs 0. Otherwise, it outputs 1.</p><p>Analysis. We first show that the distribution of the simulation using D, T 0 = (D 0 1 , . . . , D 0 2,l ) is the same as G ′ 1,k . It is easy to check that the private key components are correctly distributed except the randomization components of the k-th private key. If we implicitly set z k,1 = x 1 , {z k,2,i = x 2,i } l i=m+1 , s k,2 = y, then the randomization components of the k-th private key have the same distribution as G ′ 1,k . We next show that the distribution of the simulation using D, T 1 = (D 1 1 , . . . , D 1 2,l ) is the same as G 1,k . We only consider the distribution of the randomization components of the k-th private key since T is only used in the randomization components of the k-th private key. If we implicitly set s k,2 = y, z k,3 = d 1 /y, {z k,4,i = d 2,i /y} l i=m+1 , then the randomization components are correctly distributed as</p><formula xml:id="formula_72">R 1,1 = ( ĥ m ∏ i=1 ûI i i ) r 2 ( ŵφ 1 ) c 4 ( f -ν ) s k,2 z k,3 = ( ĥ m ∏ i=1 ûI i i ) r 2 ( ŵφ 1 ) c 4 ( k-ν ) y•d 1 /y = ( ĥ m ∏ i=1 ûI i i ) r 2 ( ŵφ 1 ) c 4 (D 1 1 ) -ν , R 3,i,1 = ûr 2 i ( ŵφ 1 ) c 6,i ( f -ν ) s k,2 z k,4,i = ûr 2 i ( ŵφ 1 ) c 6,i ( k-ν ) y•d 2,i /y = ûr 2 i ( ŵφ 1 ) c 6,i (D 1 2,i ) -ν .</formula><p>From the above analysis, we can obtain Pr[B 3 (D,</p><formula xml:id="formula_73">T 0 ) = 0] -1/2 = Adv G ′ 1,k A and Pr[B 3 (D, T 1 ) = 0] -1/2 = Adv G 1,k</formula><p>A . Thus, we can easily derive the advantage of B 3 as</p><formula xml:id="formula_74">Adv A3 B 3 (λ ) = Pr[B 3 (D, T 0 ) = 0] -Pr[B 3 (D, T 1 ) = 0] = Adv G ′ 1,k A -Adv G 1,k A .</formula><p>This completes our proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Proof of Lemma 3.5 (Indistinguishability of G 2 and G 3 )</head><p>In this proof, private keys and the challenge ciphertext are semi-functional type-2 and semi-functional respectively, but a session key should be correct or random depending on the T value of the given assumption.</p><p>The main idea of this proof is to enforce a simulator to solve the Computational Diffie-Hellman (CDH) problem in order to create the normal types of private keys and ciphertexts. However, the simulator can generate the semi-functional types of private keys and ciphertexts since an additional random value in semi-functional types enables the cancellation of the CDH value.</p><p>Simulator. Suppose there exists an adversary A that distinguishes between G 2 and G 3 with a nonnegligible advantage. A simulator B 4 that breaks Assumption 4 using A is given: a challenge tuple D = ((p, G, Ĝ, G T , e), k, k a , k b , k c , k, ka , kb , kc ) and T where T = T 0 = e(k, k) abc or T = T 1 = e(k, k) d . Then B 4 that interacts with A is described as follows: B 4 first chooses random exponents φ 1 , φ 2 ∈ Z p and random blinding values y g , y h , {y u i } l i=1 , y w ∈ Z p . It sets g = k y g , h = k y h , {u i = k y u i } l i=1 , ĝ = ky g , ĥ = ky h , { ûi = ky u i } l i=1 , ŵ = ky w . It implicitly sets ν = a, τ = φ 1 + aφ 2 , α = ab and creates the public parameters as</p><formula xml:id="formula_75">g, g ν = (k a ) y g , g -τ = k -y g φ 1 (k a ) -y g φ 2 , h, h ν = (k a ) y h , h -τ = k -y h φ 1 (k a ) -y h φ 2 , u i , u ν i = (k a ) y u i , u -τ i = k -y u i φ 1 (k a ) -y u i φ 2 l i=1 , ŵφ 1 , ŵφ 2 , ŵ, Ω = e(k a , kb ) y 2 g .</formula><p>Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). To response the private key query, B 4 first selects random exponents</p><formula xml:id="formula_76">r 1 , c 1 , c 2 , {c 3,i } l i=m+1 , s k,1 , z ′ k,1 , {z k,2,i } l i=m+1 ∈ Z p . It implicitly sets z k,1 = by g /s k,1 + z ′</formula><p>k,1 and creates the decryption and delegation components of a semifunctional private key as</p><formula xml:id="formula_77">K 1,1 = ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 ( ka ) -s k,1 z ′ k,1 , K 1,2 = ( ŵφ 2 ) c 1 ( kb ) y g ks k,1 z ′ k,1 , K 1,3 = ŵc 1 , K 2,1 = ĝr 1 ( ŵφ 1 ) c 2 ( ka ) -s k,1 , K 2,2 = ( ŵφ 2 ) c 2 ks k,1 , K 2,3 = ŵc 2 , L 3,i,1 = ûr 1 i ( ŵφ 1 ) c 3,i ( ka ) -s k,1 z k,2,i , L 3,i,2 = ( ŵφ 2 ) c 3,i ks k,1 z k,2,i , L 3,i,3 = ŵc 3,i l i=m+1 .</formula><p>Next, it selects random exponents r 2 , c 4 , c 5 , {c 6,i } l i=m+1 , s k,2 , z k,3 , {z k,4,i } l i=m+1 ∈ Z p and creates the randomization components of a semi-functional private key. In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , .</p><p>. . , I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 . B 4 flips a random coin γ ∈ {0, 1} internally and chooses random exponents s ′ c , z ′ c ∈ Z p . It implicitly sets t = c, s c = -acy g + s ′ c , z c = -ac∆(ID * γ )/s c + z ′ c /s c and creates the semi-functional ciphertext as</p><formula xml:id="formula_78">C = (T ) y 2 g • M * γ , C 1,1 = (k c ) y g , C 1,2 = k s ′ c , C 1,3 = (k c ) -y g φ 1 k -φ 2 s ′ c , C 2,1 = (k c ) ∆(ID * γ ) , C 2,2 = k z ′ c , C 2,3 = (k c ) -∆(ID * γ )φ 1 k -φ 2 z ′ c .</formula><p>Finally, A outputs a guess γ ′ . If γ = γ ′ , B 4 outputs 0. Otherwise, it outputs 1.</p><p>Analysis. We first show that the distribution of the simulation using D, T 0 = e(k, k) abc is the same as G 2 . The public parameters are correctly distributed since the random blinding values y g , y h , {y u i }, y w are used. The semi-functional private key is correctly distributed as</p><formula xml:id="formula_79">K 1,1 = ĝα ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 ( f -ν ) s k,1 z k,1 = ky g ab ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 ( k-a ) s k,1 •(by g /s k,1 +z ′ k,1 ) = ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 ( ka ) -s k,1 z ′ k,1 .</formula><p>Note that it can only create a semi-functional private key since z k,1 = by g /s k,1 + z ′ k,1 enables the cancellation of kab . The semi-functional challenge ciphertext is correctly distributed as</p><formula xml:id="formula_80">C = e(g, ĝ) αt M * γ = e(k y g , ky g ) abc M * γ = (T ) y 2 g M * γ , C 1,1 = g t = (k y g ) c = (k c ) y g , C 1,2 = (g ν ) t f s c = (k y g a ) c k -acy g +s ′ c = k s ′ c , C 1,3 = (g -τ ) t ( f -φ 2 ) s c = (k -y g (φ 1 +aφ 2 ) ) c k -φ 2 (-acy g +s ′ c ) = (k c ) -y g φ 1 k -φ 2 s ′ c , C 2,1 = (h n ∏ i=1 u I * γ,i i ) t = (k y h n ∏ i=1 k y u i I * γ,i ) c = (k c ) ∆(ID * γ ) , C 2,2 = (h ν n ∏ i=1 (u ν i ) I * γ,i ) t f s c z c = (k y h a n ∏ i=1 k y u i aI * γ,i ) c k s c (-ac∆(ID * γ )/s c +z ′ c /s c ) = k z ′ c , C 2,3 = (h -τ n ∏ i=1 (u -τ i ) I * γ,i ) t ( f -φ 2 ) s c z c = (k -y h (φ 1 +aφ 2 ) n ∏ i=1 k -y u i (φ 1 +aφ 2 )I * γ,i ) c (k -φ 2 ) s c (-ac∆(ID * γ )/s c +z ′ c /s c ) = (k c ) -∆(ID * γ )φ 1 k -φ 2 z ′ c .</formula><p>Note that it can create a semi-functional ciphertext since s c , z c enable the cancellation of k ac . We next show that the distribution of the simulation using D, T 1 = e(k, k) d is the same as G 3 . It is obvious that C is a random element since T 1 = e(k, k) d . From the above analysis, we obtain Pr[B 4 (D,</p><formula xml:id="formula_81">T 0 ) = 0] -1/2 = Adv G 2 A and Pr[B 4 (D, T 1 ) = 0] -1/2 = Adv G 3</formula><p>A . Thus, we can easily derive the advantage of B 4 as</p><formula xml:id="formula_82">Adv A4 B 4 (λ ) = Pr[B 4 (D, T 0 ) = 0] -Pr[B 4 (D, T 1 ) = 0] = Adv G 2 A -Adv G 3</formula><p>A . This completes our proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Proof of Lemma 3.6 (Indistinguishability of G 3 and G 4 )</head><p>In this proof, private keys and the challenge ciphertext are semi-functional type-2 and semi-functional respectively, and the elements of the challenge ciphertext should be well-formed or random depending on the T value of the given assumption. The idea to generate semi-functional type-2 private keys and semifunctional ciphertexts is similar to Lemma 3.5, but it uses a different assumption. To prove anonymity, the simulator embeds the T value of the assumption into the all elements of the challenge ciphertext that contains an identity.</p><p>Simulator. Suppose there exists an adversary A that distinguishes between G 3 and G 4 with a nonnegligible advantage. A simulator B 5 that breaks Assumption 5 using A is given: a challenge tuple D = ((p, G, Ĝ, G T , e), k, k a , k b , k c , k ab , k a 2 b , k, ka , kb ) and T where T = T 0 = k abc or T = T 1 = k d . Then B 5 that interacts with A is described as follows: B 5 first chooses random exponents φ 1 , φ 2 , α ∈ Z p and random blinding values y g , y h , {y u i } l i=1 , y w ∈ Z p . It sets g = k y g , h = (k ab ) y h , {u i = (k ab ) y u i } l i=1 , ĝ = ky g , ŵ = ky w , ĝα = ky g α . It implicitly sets ν = a, τ = φ 1 + aφ 2 and publishes the public parameters as</p><formula xml:id="formula_83">g, g ν = (k a ) y g , g -τ = k -y g φ 1 (k a ) -y g φ 2 , h, h ν = (k a 2 b ) y h , h -τ = (k ab ) -y h φ 1 (k a 2 b ) -y h φ 2 , u i , u ν i = (k a 2 b ) y u i , u -τ i = (k ab ) -y u i φ 1 (k a 2 b ) -y u i φ 2 l i=1 , ŵφ 1 , ŵφ 2 , ŵ, Ω = e(k, k) y 2 g α .</formula><p>It also implicitly sets ĥ = ( kab ) y h , { ûi = ( kab ) y u i } for the master key, but it cannot create these values since kab is not given. Additionally, it sets f = k, f = k for the semi-functional ciphertext and private key. Let ∆(ID) = y h + ∑ m i=1 y u i I i where ID = (I 1 , . . . , I m ). A adaptively requests a private key for ID = (I 1 , . . . , I m ). To response the private key query, B 5 first selects random exponents r</p><formula xml:id="formula_84">1 , c 1 , c 2 , {c 3,i } l i=m+1 , s k,1 , z ′ k,1 , {z ′ k,2,i } l i=m+1 ∈ Z p . It implicitly sets z k,1 = b∆(ID)r 1 /s k,1 + z ′ k,1 , {z k,2,i = by u i r 1 /s k,1 + z ′ k,2,i } l i=m+1</formula><p>and creates the decryption and delegation components of a semi-functional private key as</p><formula xml:id="formula_85">K 1,1 = ĝα ( ŵφ 1 ) c 1 ( ka ) -s k,1 z ′ k,1 , K 1,2 = ( ŵφ 2 ) c 1 ( kb ) ∆(ID)r 1 ks k,1 z ′ k,1 , K 1,3 = ŵc 1 , K 2,1 = ĝr 1 ( ŵφ 1 ) c 2 ( ka ) -s k,1 , K 2,2 = ( ŵφ 2 ) c 2 ks k,1 , K 2,3 = ŵc 2 , L 3,i,1 = ( ŵφ 1 ) c 3,i ( ka ) -s k,1 z ′ k,2,i , L 3,i,2 = ( ŵφ 2 ) c 3,i ( kb ) y u i r 1 ks k,1 z ′ k,2,i , L 3,i,3 = ŵc 3,i l i=m+1 .</formula><p>Next, it selects random exponents r 2 , c 4 , c 5 , {c 6,i } l i=m+1 , s k,2 , z ′ k,3 , {z ′ k,4,i } l i=m+1 ∈ Z p and creates the randomization components of a semi-functional private key by implicitly setting z k,3 = b∆(ID)r 2 /s k,2 +z ′ k,3 , {z k,4,i = by u i r 2 /s k,2 + z ′ k,4,i } l i=m+1 . We omit the detailed description of these, since these are similar to the decryption and delegation components except that R 1,1 does not have ĝα . In the challenge step, A submits two challenge hierarchical identities ID * 0 = (I * 0,1 , . . . , I * 0,n ), ID * 1 = (I * 1,1 , . . . , I * 1,n ) and two messages M * 0 , M * 1 . B 5 flips a random coin γ ∈ {0, 1} internally and chooses random exponents δ , s ′ c , z ′ c ∈ Z p . It implicitly sets t = c, s c = -acy g + s ′ c , z c = -a 2 bc∆(ID * γ )/s c + abcz ′ c /s c and creates the semi-functional ciphertext as</p><formula xml:id="formula_86">C = Ω δ • M * γ , C 1,1 = (k c ) y g , C 1,2 = (k a ) s ′ c , C 1,3 = (k c ) -y g φ 1 k -φ 2 s ′ c , C 2,1 = (T ) ∆(ID * γ ) , C 2,2 = (T ) z ′ c , C 2,3 = (T ) -∆(ID * γ )φ 1 (T ) -z ′ c φ 2 .</formula><p>Finally, A outputs a guess γ ′ . If γ = γ ′ , B 5 outputs 0. Otherwise, it outputs 1.</p><p>Analysis. We first show that the distribution of the simulation using D, T 0 = k abc is the same as G 3 . The public parameters are correctly distributed since the random blinding values are used. The semi-functional private key is correctly distributed as</p><formula xml:id="formula_87">K 1,1 = ĝα ( ĥ m ∏ i=1 ûI i i ) r 1 ( ŵφ 1 ) c 1 ( f -ν ) s k,1 z k,1 = ĝα ( kab ) ∆(ID)r 1 ( ŵφ 1 ) c 1 ( k-a ) s k,1 (b∆(ID)r 1 /s k,1 +z ′ k,1 ) = ĝα ( ŵφ 1 ) c 1 ( ka ) -s k,1 z ′ k,1 , K 2,1 = ĝr 1 ( ŵφ 1 ) c 2 ( f -ν ) s k,1 = ĝr 1 ( ŵφ 1 ) c 2 ( ka ) -s k,1 , L 3,i,1 = ûr 1 i ( ŵφ 1 ) c 3,i ( f -ν ) s k,1 z k,2,i = ( kab ) y u i r 1 ( ŵφ 1 ) c 3,i ( ka ) -s k,1 •(by u i r 1 /s k,1 +z ′ k,2,i ) = ( ŵφ 1 ) c 3,i ( ka ) -s k,1 z ′ k,2,i .</formula><p>Note that it can only create a semi-functional type-2 private key since z k,1 , {z k,2,i }, z k,3 , {z k,4,i } enable the cancellation of kab . The semi-functional challenge ciphertext is correctly distributed as</p><formula xml:id="formula_88">C 1,1 = g t = (k y g ) c = (k c ) y g , C 1,2 = (g ν ) t f s c = (k y g a ) c k -acy g +s ′ c = k s ′ c , C 1,3 = (g -τ ) t ( f -φ 2 ) s c = (k -y g (φ 1 +aφ 2 ) ) c k -φ 2 (-acy g +s ′ c ) = (k c ) -y g φ 1 k -φ 2 s ′ c , C 2,1 = (h n ∏ i=1 u I * γ,i i ) t = (k ab ) ∆(ID * γ )c = (T 0 ) ∆(ID * γ ) , C 2,2 = (h n ∏ i=1 u I * γ,i i ) νt f s c z c = ((k ab ) ∆(ID * γ ) ) ac k s c (-a 2 bc∆(ID * γ )/s c +abcz ′ c /s c ) = (T 0 ) z ′ c , C 2,3 = (h n ∏ i=1 u I * γ,i i ) -τt ( f -φ 2 ) s c z c = ((k ab ) ∆(ID * γ ) ) -(φ 1 +aφ 2 )c k -φ 2 s c (-a 2 bc∆(ID * γ )/s c +abcz ′ c /s c ) = (T 0 ) -∆(ID * γ )φ 1 (T 0 ) -z ′ c φ 2 .</formula><p>Note that it can only create a semi-functional ciphertext since s c , z c enable the cancellation of k a 2 bc . We next show that the distribution of the simulation using D, T 1 = k d is the same as G 4 . We only consider C 2,1 ,C 2,2 ,C 2,3 components of the semi-functional challenge ciphertext since T is used for these components.</p><p>If we implicitly sets P = k ∆(ID * γ )d/c and z c = -ad∆(ID * γ )/s c + dz ′ c /s c , then the semi-functional challenge ciphertext is correctly distributed as</p><formula xml:id="formula_89">C 2,1 = P c = (k ∆(ID * γ )d/c ) c = (T 1 ) ∆(ID * γ ) , C 2,2 = P νc f s c z c = (k ∆(ID * γ )d/c ) ac k s c (-ad∆(ID * γ )/s c +dz ′ c /s c ) = (T 1 ) z ′ c , C 2,3 = P -τc ( f -φ 2 ) s c z c = (k ∆(ID * γ )d/c ) -(φ 1 +aφ 2 )c k -φ 2 s c (-ad∆(ID * γ )/s c +dz ′ c /s c ) = (T 1 ) -∆(ID * γ )φ 1 (T 1 ) -z ′ c φ 2 .</formula><p>From the above analysis, we obtain Pr[B 5 (D, T</p><formula xml:id="formula_90">0 ) = 0] -1/2 = Adv G 3 A and Pr[B 5 (D, T 1 ) = 0] -1/2 = Adv G 4</formula><p>A . Thus, we can easily derive the advantage of B 5 as</p><formula xml:id="formula_91">Adv A5 B 5 (λ ) = Pr[B 5 (D, T 0 ) = 0] -Pr[B 5 (D, T 1 ) = 0] = Adv G 3 A -Adv G 4</formula><p>A . This completes our proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Generic Group Model</head><p>In this section, we prove that the new assumption of this paper is secure under the generic group model. The generic group model was introduced by Shoup <ref type="bibr" target="#b42">[43]</ref>, and it is a tool for analyzing generic algorithms that work independently of the group representation. In the generic group model, an adversary is given a random encoding of a group element or an arbitrary index of a group element instead of the actual representation of a group element. Thus, the adversary performs group operations through oracles that are provided by a simulator, and the adversary only can check the equality of group elements. The detailed explanation of the generic group model is given in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b27">28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Master Theorem</head><p>To analyze the new assumption of this paper, we slightly modify the master theorem of Katz et al. <ref type="bibr" target="#b27">[28]</ref> since the new assumption is defined over asymmetric bilinear groups of prime order. Let G, Ĝ, G T be asymmetric bilinear groups of prime order p. The bilinear map is defined as e : G × Ĝ → G T . In the generic group model, a random group element of G, Ĝ, G T is represented as a random variable P i , Q i , R i respectively where P i , Q i , R i are chosen uniformly in Z p . We say that a random variable has degree t if the maximum degree of any variable is t. The generalized definition of dependence and independence is given as follows: Definition 6.1. Let P = {P 1 , . . . , P u }, T 0 , T 1 be random variables over G where T 0 = T 1 , let Q = {Q 1 , . . . , Q w } be random variables over Ĝ, and let R = {R 1 , . . . , R v } be random variables over G T . Let l = max{u, w, v}. We say that T b is dependent on P if there exists constants α,</p><formula xml:id="formula_92">{β i } such that α • T b = u ∑ i=1 β i • P i</formula><p>where α = 0. We say that T b is independent of P if T b is not dependent on P. We say that {e(T b , Q i )} i is dependent on P ∪ Q ∪ R if there exist constants {α i }, {β i, j }, {γ i } such that w</p><formula xml:id="formula_93">∑ i=1 α i • e(T b , Q i ) = u ∑ i=1 w ∑ j=1 β i, j • e(P i , Q j ) + v ∑ i=1 γ i • R i</formula><p>where α i = 0 for at least one i. We say that {e(T b , Q i )} i is independent of P ∪ Q ∪ R if {e(T b , Q i )} i is not dependent on P ∪ Q ∪ R.</p><p>We can obtain the following theorem by using the above dependence and independence of random variables. If T b is independent of P for all b ∈ {0, 1}, and {e(T b , Q j )} j is independent of P ∪ Q ∪ R for all b ∈ {0, 1}, then any algorithm A issuing at most q instructions has an advantage at most 3(q + 2l) 2 t/p. Proof. The proof consists of a sequence of games. The first game will be the original experiment that is described in the theorem and the last game will be a game that the algorithm has no advantage. We define the games as follows:</p><p>Game G 1 . This game is the original game. In this game, the simulator instantiates each of random variables P, Q, R, T b by choosing random values for each of the formal variables. Then it gives the handles of P, Q, R, T b to the algorithm A. Next, A requests a sequence of multiplication, exponentiation, and pairing instructions, and is given the handles of results. Finally, A outputs a bit b ′ .</p><p>Game G 2 . We slightly modify G 1 into a new game G 2 . In this game, the simulator never concretely instantiates the formal variables. Instead it keeps the formal polynomials themselves. Additionally, the simulator gives identical handles for two elements only if these elements are equal as formal polynomials in each of their components. That is, the simulator of this game assigns different handles for X and Y since these are different polynomials. Note that the simulator of G 1 assigned the same handle for X = (X 1 , . . . , X n ) and Y = (Y 1 , . . . ,Y n ) if X i = Y i for all i.</p><p>To prove the theorem, we will show that the statistical distance between two games G 1 and G 2 is negligible and the advantage of the algorithm in G 2 is zero. Then the advantage of the algorithm in the original game is bounded by the statistical distance between two games.</p><p>We first show that the statistical distance between two games G 1 and G 2 is negligible. The only difference between two games is the case that two different formal polynomials take the same value by concrete instantiation. The probability of this event is at most t/p from the Schwartz-Zippel Lemma <ref type="bibr" target="#b39">[40]</ref>. If we consider all pairs of elements produced by the algorithm A, the statistical distance between two games is at most 3(q + 2l) 2 t/p since A can request at most q instructions, the maximum size of handles in each group is at most q + 2l, and there are three different groups.</p><p>We next show that the advantage of the algorithm in G 2 is zero. In this game, the algorithm A only can distinguish whether it is given T 0 or T 1 if it can generate a formal polynomial that is symbolically equivalent to some previously generated polynomial for one value of b but not the other. In this case, we have α • T b = ∑ u i=1 β i • P i where α = 0, or else we have ∑ w i=1 α i • e(T b , Q i ) = ∑ u i=1 ∑ w j=1 β i, j • e(P i , Q j ) + ∑ v i=1 γ i • R i where α i = 0 for at least one i (otherwise, symbolic equality would hold for both value of b). However, the above equations are contradict to the independence assumptions of the theorem. Therefore, the advantage of A in this game is zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Analysis of Asymmetric 3-Party Diffie-Hellman</head><p>To apply the master theorem of the previous section, we only need to show the independence of T 0 , T 1 random variables. Using the notation of previous section, Assumption 5 (Asymmetric 3-Party Diffie-Hellman) can be written as P = {1, A, B,C, AB, A 2 B}, Q = {1, A, B}, R = {1}, T 0 = ABC, T 1 = D.</p><p>At first, we show the independence of T 1 . It is trivial that T 1 is independent of P since a random variable D does not exist in P. It is easy to show that {e(T 1 , Q i )} i is independent of P ∪ Q ∪ R since T 1 contains a random variable D that does not exist in P, Q, R. Next, we show the independence of T 0 . It is easy to show that T 0 is independent of P since the random variables with degree 3 are different. To show the independence of {e(T 0 , Q i )} i , we can derive the sets of random variables as {e(T 0 , Q j )} j = {ABC, A 2 BC, AB 2 C}, {e(P i , Q j )} i, j = {1, A, B,C, AB, A 2 B, A 2 , AC, A 3 B, B 2 , BC, AB 2 , A 2 B 2 },</p><formula xml:id="formula_94">{R i } = {1}.</formula><p>The random variables of {e(T 0 , Q i )} i always contain C and the degree of these random variables is greater than 3. However, the random variables of {e(P i , Q j )} i, j that contain C have the degree at most 2. Thus {e(T 0 , Q i )} i is independent of P ∪ Q ∪ R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper, we proposed an efficient anonymous HIBE scheme with short ciphertexts and proved its full model security under static assumptions. Though our construction is based on the IBE scheme of Lewko and Waters <ref type="bibr" target="#b32">[33]</ref>, it was not trivial to construct an anonymous HIBE scheme, since the randomization components of private keys cause a problem in the security proof of dual system encryption. We leave it as an interesting problem to construct a fully secure and anonymous HIBE scheme with short ciphertexts under standard assumptions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Assumption 3 (Assumption 5 (</head><label>35</label><figDesc>A2 B (λ ) = Pr[B(D, T 0 ) = 0] -Pr[B(D, T 1 ) = 0] where the probability is taken over the random choice of a, b, c, x, d ∈ Z p . Symmetric eXternal Diffie-Hellman) Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ respectively. The assumption is that if the challenge values D = ((p, G, Ĝ, G T , e), g, ĝ, ĝa , ĝb ) and T are given, no PPT algorithm B can distinguish T = T 0 = ĝab from T = T 1 = ĝc with more than a negligible advantage. The advantage of B is defined as Adv A3 B (λ ) = Pr[B(D, T 0 ) = 0] -Pr[B(D, T 1 ) = 0] where the probability is taken over the random choice of a, b, c ∈ Z p . Assumption 4 (Decisional Bilinear Diffie-Hellman) Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ respectively. The assumption is that if the challenge values D = ((p, G, Ĝ, G T , e), g, g a , g b , g c , ĝ, ĝa , ĝb , ĝc ) and T are given, no PPT algorithm B can distinguish T = T 0 = e(g, ĝ) abc from T = T 1 = e(g, ĝ) d with more than a negligible advantage. The advantage of B is defined as Adv A4 B (λ ) = Pr[B(D, T 0 ) = 0] -Pr[B(D, T 1 ) = 0] where the probability is taken over the random choice of a, b, c, d ∈ Z p . Asymmetric 3-Party Diffie-Hellman) Let (p, G, Ĝ, G T , e) be a description of the asymmetric bilinear group of prime order p with the security parameter λ . Let g, ĝ be generators of G, Ĝ respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><figDesc>d) ≥ 135.8 * (ld) + 9.5 * d + 135.8 ms, DelCost(l, d) ≥ 163.8 * (ld) + 346.5 ms, EncCost(d) ≥ 2.1 * d + 14.3 ms, DecCost ≥ 62.4 ms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Performance of our HIBE scheme</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 6 . 2 .</head><label>62</label><figDesc>Let P = {P 1 , . . . , P u }, T 0 , T 1 be random variables over G where T 0 = T 1 , let Q = {Q 1 , . . . , Q w } be random variables over Ĝ, and let R = {R 1 , . . . , R v } be random variables over G T . Let l = max{u, w, v}. Consider the following experiment in the generic group model: An algorithm is given P = {P 1 , . . . , P u }, Q = {Q 1 , . . . , Q w }, and R = {R 1 , . . . , R v }. A random bit b is chosen, and the adversary is given T b . The algorithm outputs a bit b ′ , and succeeds if b ′ = b. The algorithm's advantage is the absolute value of the difference between its success probability and 1/2.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Lewko and Waters used the parameter hiding property of composite order groups to prove the full security of their HIBE scheme using the dual system encryption technique<ref type="bibr" target="#b32">[33]</ref>. The parameter hiding property of composite order N = pqr is stated that an exponent Z N has one-to-one correspondence with (Z p , Z q , Z r ) because of Chinese Remainder Theorem (CRT) and Z q and Z r values are information theoretically hidden to an adversary even if Z p value is revealed to the adversary.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The dimensions of DPVS is generally proportional to the size of an identity vector in the scheme that uses DPVS[30,  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b38">39]</ref>. Thus an HIBE scheme based on DPVS that supports l-depth has linear-size of ciphertexts since it requires at least l-dimensions in DPVS. To reduce the dimensions of DPVS, one may try to use the technique of Okamoto and Takashima<ref type="bibr" target="#b37">[38]</ref>, but it only applied to non-anonymous schemes since it should reveal the identity of ciphertexts.<ref type="bibr" target="#b2">3</ref> To support private key re-randomization using a public key, some elements ĝ, û, ĥ ∈ Ĝ in a private key should be moved to a public key. However, these elements cannot be moved to the public key since the proof of dual system encryption goes wrong.</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>* This work was partly supported by the <rs type="funder">MSIP (Ministry of Science, ICT &amp; Future Planning)</rs>, <rs type="funder">Korea</rs>, under the C-<rs type="funder">ITRC</rs> (<rs type="programName">Convergence Information Technology Research Center) support program</rs> (<rs type="grantNumber">NIPA-2013-H0301-13-3007</rs>) supervised by the <rs type="funder">NIPA (National IT Industry Promotion Agency)</rs> and the <rs type="programName">IT R&amp;D program</rs> of <rs type="institution" subtype="infrastructure">MOTIE/KEIT [KI002113, Development of Security Technology for Car-Healthcare</rs>].</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_Mh3N24A">
					<idno type="grant-number">NIPA-2013-H0301-13-3007</idno>
					<orgName type="program" subtype="full">Convergence Information Technology Research Center) support program</orgName>
				</org>
				<org type="funding" xml:id="_GaU3qwK">
					<orgName type="program" subtype="full">IT R&amp;D program</orgName>
				</org>
			</listOrg>

			<listOrg type="infrastructure">
				<org type="infrastructure">					<orgName type="extracted">MOTIE/KEIT [KI002113, Development of Security Technology for Car-Healthcare</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Searchable encryption revisited: Consistency properties, relation to anonymous ibe, and extensions</title>
		<author>
			<persName><forename type="first">Michel</forename><surname>Abdalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dario</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eike</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tadayoshi</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tanja</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Malone-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Paillier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haixia</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3621</biblScope>
			<biblScope unit="page" from="205" to="222" />
			<date type="published" when="2005">2005</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Robust encryption</title>
		<author>
			<persName><forename type="first">Michel</forename><surname>Abdalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Neven</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Daniele</forename><surname>Micciancio</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5978</biblScope>
			<biblScope unit="page" from="480" to="497" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient lattice (h)ibe in the standard model</title>
		<author>
			<persName><forename type="first">Shweta</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Henri</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="553" to="572" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Lattice basis delegation in fixed dimension and shorter-ciphertext hierarchical ibe</title>
		<author>
			<persName><forename type="first">Shweta</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="98" to="115" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient selective-id secure identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Christian Cachin and Jan Camenisch</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3027</biblScope>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
	<note>EUROCRYPT</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient selective identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="659" to="693" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Hierarchical identity based encryption with constant size ciphertext</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eu-Jin</forename><surname>Goh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Ronald</forename><surname>Cramer</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="440" to="456" />
			<date type="published" when="2005">2005</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Public key encryption with keyword search</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Di Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Persiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Christian Cachin and Jan Camenisch</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3027</biblScope>
			<biblScope unit="page" from="506" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the weil pairing</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Joe</forename><surname>Kilian</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="213" to="229" />
			<date type="published" when="2001">2001</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the weil pairing</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="586" to="615" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Generalized identity based and broadcast encryption schemes</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Hamburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Josef</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5350</biblScope>
			<biblScope unit="page" from="455" to="470" />
			<date type="published" when="2008">2008</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Conjunctive, subset, and range queries on encrypted data</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Salil</surname></persName>
		</editor>
		<editor>
			<persName><surname>Vadhan</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4392</biblScope>
			<biblScope unit="page" from="535" to="554" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Anonymous hierarchical identity-based encryption (without random oracles)</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Cynthia</forename><surname>Dwork</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4117</biblScope>
			<biblScope unit="page" from="290" to="307" />
			<date type="published" when="2006">2006</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A forward-secure public-key encryption scheme</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Eli</forename><surname>Biham</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="255" to="271" />
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Chosen-ciphertext security from identity-based encryption</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Christian Cachin and Jan Camenisch</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3027</biblScope>
			<biblScope unit="page" from="207" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fully secure anonymous hibe and secretkey anonymous ibe with short ciphertexts</title>
		<author>
			<persName><forename type="first">Angelo</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Caro</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Vincenzo</forename><surname>Iovino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Persiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Joye</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Atsuko</forename><surname>Miyaji</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Akira</forename><surname>Otsuka</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6487</biblScope>
			<biblScope unit="page" from="347" to="366" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Bonsai trees, or how to delegate a lattice basis</title>
		<author>
			<persName><forename type="first">David</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eike</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Henri</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="523" to="552" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Hibe with short public parameters without random oracle</title>
		<author>
			<persName><forename type="first">Sanjit</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Palash</forename><surname>Sarkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Xuejia</forename><surname>Lai</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kefei</forename><surname>Chen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4284</biblScope>
			<biblScope unit="page" from="145" to="160" />
			<date type="published" when="2006">2006</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The relation and transformation between hierarchical inner product encryption and spatial encryption</title>
		<author>
			<persName><forename type="first">Jie</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hoon</forename><forename type="middle">Wei</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">San</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huaxiong</forename><surname>Wang</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2011/455" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2011">2011/455, 2011</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Public key broadcast encryption for stateless receivers</title>
		<author>
			<persName><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nelly</forename><surname>Fazio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital Rights Management Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Joan</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2696</biblScope>
			<biblScope unit="page" from="61" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Anonymity from asymmetry: New constructions for anonymous hibe</title>
		<author>
			<persName><forename type="first">Léo</forename><surname>Ducas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Josef</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5985</biblScope>
			<biblScope unit="page" from="148" to="164" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>CT-RSA</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Converting pairing-based cryptosystems from composite-order groups to prime-order groups</title>
		<author>
			<persName><forename type="first">David</forename><surname>Mandell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Freeman</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Henri</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="44" to="61" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Practical identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Serge</forename><surname>Vaudenay</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4004</biblScope>
			<biblScope unit="page" from="445" to="464" />
			<date type="published" when="2006">2006</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Hierarchical identity based encryption with polynomially many levels</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Omer</forename><surname>Reingold</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5444</biblScope>
			<biblScope unit="page" from="437" to="456" />
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Hierarchical id-based cryptography</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alice</forename><surname>Silverberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Yuliang</forename><surname>Zheng</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2501</biblScope>
			<biblScope unit="page" from="548" to="566" />
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Attribute-based encryption for finegrained access control of encrypted data</title>
		<author>
			<persName><forename type="first">Vipul</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omkant</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<editor>
			<persName><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Rebecca</forename><forename type="middle">N</forename><surname>Wright</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sabrina De Capitani Di</forename><surname>Vimercati</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="89" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Toward hierarchical identity-based encryption</title>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Horwitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Lynn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Lars</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2332</biblScope>
			<biblScope unit="page" from="466" to="481" />
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Predicate encryption supporting disjunctions, polynomial equations, and inner products</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Nigel</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="146" to="162" />
			<date type="published" when="2008">2008</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">New techniques for anonymous hibe with short ciphertexts in prime order groups</title>
		<author>
			<persName><forename type="first">Kwangsu</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong</forename><surname>Hoon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lee</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KSII Trans. Internet Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="968" to="988" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Tools for simulating features of composite order bilinear groups in the prime order setting</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">David</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Johansson</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7237</biblScope>
			<biblScope unit="page" from="318" to="335" />
			<date type="published" when="2012">2012</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Henri</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="62" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Achieving leakage resilience through dual system encryption</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Rouselakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6597</biblScope>
			<biblScope unit="page" from="70" to="88" />
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">New techniques for dual system encryption and fully secure hibe with short ciphertexts</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Daniele</forename><surname>Micciancio</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5978</biblScope>
			<biblScope unit="page" from="455" to="479" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Unbounded hibe and attribute-based encryption</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Kenneth</surname></persName>
		</editor>
		<editor>
			<persName><surname>Paterson</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6632</biblScope>
			<biblScope unit="page" from="547" to="567" />
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">The pairing-based cryptography library</title>
		<author>
			<persName><forename type="first">Ben</forename><surname>Lynn</surname></persName>
		</author>
		<ptr target="http://crypto.stanford.edu/pbc/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Hierarchical predicate encryption for inner-products</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Mitsuru</forename><surname>Matsui</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="214" to="231" />
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Fully secure functional encryption with general relations from the decisional linear assumption</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="191" to="208" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Achieving short ciphertexts or short secret-keys for adaptively secure general inner-product encryption</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Dongdai</forename><surname>Lin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gene</forename><surname>Tsudik</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Xiaoyun</forename><surname>Wang</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7092</biblScope>
			<biblScope unit="page" from="138" to="159" />
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Adaptively attribute-hiding (hierarchical) inner product encryption</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">David</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Johansson</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7237</biblScope>
			<biblScope unit="page" from="591" to="608" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Fast probabilistic algorithms for verification of polynomial identities</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName><surname>Schwartz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="701" to="717" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Anonymous hierarchical identity-based encryption with constant size ciphertexts</title>
		<author>
			<persName><forename type="first">Jae</forename><surname>Hong Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tetsutaro</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miyako</forename><surname>Ohkubo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koutarou</forename><surname>Suzuki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Stanislaw Jarecki and Gene Tsudik, editors, Public Key Cryptography</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5443</biblScope>
			<biblScope unit="page" from="215" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Delegating capabilities in predicate encryption systems</title>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Luca</forename><surname>Aceto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Leslie</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ann</forename><surname>Goldberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Magnús</forename><forename type="middle">M</forename><surname>Halldórsson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Anna</forename><surname>Ingólfsdóttir</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Igor</forename><surname>Walukiewicz</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5126</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="560" to="578" />
			<date type="published" when="2008">2008</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Lower bounds for discrete logarithms and related problems</title>
		<author>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Walter</forename><surname>Fumy</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="256" to="266" />
			<date type="published" when="1997">1997</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Efficient identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Ronald</forename><surname>Cramer</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="114" to="127" />
			<date type="published" when="2005">2005</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Dual system encryption: Realizing fully secure ibe and hibe under simple assumptions</title>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5677</biblScope>
			<biblScope unit="page" from="619" to="636" />
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
