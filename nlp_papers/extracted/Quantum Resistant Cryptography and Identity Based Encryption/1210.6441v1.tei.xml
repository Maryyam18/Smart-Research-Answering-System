<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Anonymous and Adaptively Secure Revocable IBE with Constant-Size Public Parameters</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2012-10-24">24 Oct 2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jie</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Division of Mathematical Sciences</orgName>
								<orgName type="department" key="dep2">School of Physical &amp; Mathematical Sciences</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wei</forename><surname>Hoon</surname></persName>
							<email>hoonwei@ntu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Division of Mathematical Sciences</orgName>
								<orgName type="department" key="dep2">School of Physical &amp; Mathematical Sciences</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">San</forename><surname>Lim</surname></persName>
							<email>lingsan@ntu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Division of Mathematical Sciences</orgName>
								<orgName type="department" key="dep2">School of Physical &amp; Mathematical Sciences</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Le</forename><surname>Ling</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Division of Mathematical Sciences</orgName>
								<orgName type="department" key="dep2">School of Physical &amp; Mathematical Sciences</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Huaxiong</forename><surname>Su</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Division of Mathematical Sciences</orgName>
								<orgName type="department" key="dep2">School of Physical &amp; Mathematical Sciences</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Wang</surname></persName>
							<email>hxwang@ntu.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Division of Mathematical Sciences</orgName>
								<orgName type="department" key="dep2">School of Physical &amp; Mathematical Sciences</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Anonymous and Adaptively Secure Revocable IBE with Constant-Size Public Parameters</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2012-10-24">24 Oct 2012</date>
						</imprint>
					</monogr>
					<idno type="MD5">A20D66C3CAC14A26FACBB745342390D2</idno>
					<idno type="arXiv">arXiv:1210.6441v1[cs.CR]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2" ident="GROBID" when="2025-11-28T12:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<label type="revision">a91ee48</label>
					<label type="parameters">startPage=-1, endPage=-1, consolidateCitations=0, consolidateHeader=0, consolidateFunders=0, includeRawAffiliations=false, includeRawCitations=false, includeRawCopyrights=false, generateTeiIds=false, generateTeiCoordinates=[], sentenceSegmentation=false, flavor=null</label>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Dual System Encryption</term>
					<term>Functional Encryption</term>
					<term>Identity-Based Encryption</term>
					<term>Key Revocation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In Identity-Based Encryption (IBE) systems, key revocation is non-trivial. This is because a user's identity is itself a public key. Moreover, the private key corresponding to the identity needs to be obtained from a trusted key authority through an authenticated and secrecy protected channel. So far, there exist only a very small number of revocable IBE (RIBE) schemes that support non-interactive key revocation, in the sense that the user is not required to interact with the key authority or some kind of trusted hardware to renew her private key without changing her public key (or identity). These schemes are either proven to be only selectively secure or have public parameters which grow linearly in a given security parameter. In this paper, we present two constructions of non-interactive RIBE that satisfy all the following three attractive properties: (i) proven to be adaptively secure under the Symmetric External Diffie-Hellman (SXDH) and the Decisional Linear (DLIN) assumptions; (ii) have constant-size public parameters; and (iii) preserve the anonymity of ciphertexts-a property that has not yet been achieved in all the current schemes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Identity-based encryption (IBE) allows one's identity to be directly used as a public key <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b11">12]</ref>. This obviates the need for a public key certificate that attests the binding between the identity and a (seemingly) random key, as in the case of more conventional certificate-based public-key systems. Thus, IBE systems have simpler public key management than that of certificate-based systems. In IBE, however, a private key (corresponding to an identity) needs to be generated by a trusted key authority. This and the fact that a user's identity is itself a public key complicates key renewal or revocation-one cannot simply change her public key, as this changes her identity as well. While there has been a great deal of work on IBE in recent years, see for example <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b1">2]</ref>, not much work has been devoted to key revocation.</p><p>One direct way to alleviate the key revocation problem in the IBE setting is to maintain a revocation list by some trusted third party. A sender checks on the trusted third party and just stops to encrypt messages if the corresponding receiver is revoked. However, this direct model requires the trusted third party to keep online in order to respond any sender's real time checking query. To address this problem, one simple solution is to append a validity period to a target identity during encryption <ref type="bibr" target="#b5">[6]</ref>. This results in a public key with a limited validity period, and hence, restricting the window of exposure should the corresponding private key is compromised. If the validity period is sufficiently short, one may not require an explicit key revocation mechanism since an exposed private key is of little value to an adversary beyond the specified validity period. However, one major drawback of this approach is that each user has to periodically renew her private key. As a consequence, the key authority's workload increases linearly in the number of non-revoked users. Further, we must ensure that each transmission of a new private key between the key authority and a non-revoked user is performed through some form of authenticated and secure channel. There exist some improved key revocation techniques in the literature, for example <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b14">15]</ref>. However, they require interactions either between the user and the key authority, as before, or between the user and some kind of trusted hardware. These may not always be practical.</p><p>The first non-interactive, revocable IBE (RIBE) scheme that neither presupposes the existence of trusted hardware nor requires a secure channel between the user and the key authority, is due to Boldyreva et al. <ref type="bibr" target="#b4">[5]</ref>. Their scheme borrows the concept of fuzzy IBE (FIBE) <ref type="bibr" target="#b27">[28]</ref> in which encryption of a message is associated with two "attributes", namely identity of the receiver and time period. The corresponding decryption key is also split into two private components, matching the identity and the time period, respectively. The private component that corresponds to the identity is essentially similar to a regular private key in IBE and it is issued to a user by the key authority through a secure channel. On the other hand, the private key component corresponding to the time period is regarded as a key update and is published by the key authority to all users. (Here the key update is public information and does not require secrecy protection.) Thus, to revoke a user, the key authority simply stops distributing the key update for that user. To reduce the number of key updates to be performed by the key authority, Boldyreva et al. organize and relate users' key updates in a binary tree <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b21">22]</ref>. Briefly speaking, each node of the tree is assigned some key material and each user is assigned to a leaf node in the tree. Upon registration, the key authority computes and provides the user with a set of distinct private keys (corresponding to its identity) based on the key material for each node in the path from the leaf node corresponding to that user to the root node. To be able to decrypt a ciphertext associated with time t, the user needs just one key update (corresponding to t) computed on the key material associated to any of the nodes on the path from the leaf node of the user to the root node. Thus, when no user is revoked, the key authority publishes just the key update computed on the key material of the root node. When a subset of the users is revoked, the key authority first finds the minimal set of nodes in the tree which contains an ancestor (or, the node itself) among all the leaf nodes corresponding to non-revoked users. The key authority then distributes the key updates for only this set. This way, every update of the revocation list only requires the key authority to perform logarithmic work in the maximal number of users and linear in the number of revoked users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Previous Non-Interactive RIBE Constructions</head><p>Although an adaptive-ID secure IBE scheme <ref type="bibr" target="#b29">[30]</ref> (which is resilient even against an adversary that is allowed to adaptively select an identity as the attack target based on the responses to the adversary's queries in a security game) has been in existence for some years, constructing an RIBE scheme with equivalent security guarantee is non-trivial. This is evident from the first RIBE scheme proposed by Boldyreva et al. <ref type="bibr" target="#b4">[5]</ref>. Although it is intriguing that their RIBE scheme was constructed from the FIBE scheme of <ref type="bibr" target="#b27">[28]</ref> and made clever use of the binary tree technique, the scheme was only proven in the selective-ID model, which is, unfortunately, a rather weak model. This is because the adversary is required to set the challenge identity and time at the beginning of a security game before receiving the relevant public parameters. Nevertheless, Libert and Vergnaud <ref type="bibr" target="#b20">[21]</ref> eventually proposed an adaptive-ID secure RIBE scheme using similar key revocation techniques as with <ref type="bibr" target="#b4">[5]</ref>, and thus solved the problem left open by Boldyreva et al. However, instead of building on FIBE, Libert and Vergnaud adopted a variant <ref type="bibr" target="#b19">[20]</ref> of the Waters IBE scheme <ref type="bibr" target="#b29">[30]</ref>, which is based on partitioning techniques and has a drawback in having public parameters that comprise O(λ) group elements for security parameter λ. Consequently, the Libert and Vergnaud RIBE scheme inherits a similar limitation. Clearly, it is desirable that a scheme has small or constant-size public parameters, secret keys, and ciphertexts, if it were to be deployed in real world applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. RIBE from Dual System Encryption</head><p>Moving beyond proving security through the partitioning techniques, Waters proposed the dual system encryption methodology <ref type="bibr" target="#b30">[31]</ref>, which has been a powerful tool to obtain full security for various classes of functional encryption (FE) <ref type="bibr" target="#b8">[9]</ref>, such as IBE <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b15">16]</ref>, inner product encryption (IPE) <ref type="bibr" target="#b17">[18]</ref>, and attribute-based encryption (ABE) <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b24">25]</ref>. Although there already exist some schemes that achieve full security using the dual system encryption technique, (for example, the HIBE scheme of <ref type="bibr" target="#b16">[17]</ref> has been proven to be fully secure by applying this technique to the HIBE scheme of <ref type="bibr" target="#b6">[7]</ref>), however, these fully secure schemes typically require relatively large parameters and/or constructed only in the composite order bilinear groups. Thus, in general, the dual system encryption methodology does not always provide generic transformation from selective security to adaptive security without suffering from the mentioned limitations.</p><p>In our work, we initially tried to apply the dual system encryption technique to the selective-ID RIBE scheme of <ref type="bibr" target="#b4">[5]</ref>, however this results an analogous construction and proof to the ABE scheme of <ref type="bibr" target="#b24">[25]</ref>. Furthermore, as we illustrate below, such an approach does not enjoy constant-size public parameters and keys.</p><p>To see this, we specifically consider the binary-tree key update approach <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b20">21]</ref> in the setting similar to key-policy ABE. 1 As before, a ciphertext in the RIBE scheme is associated with two attributes: identity id i and time period t j . The ciphertext can be decrypted by a user if and only if the user possesses both the private key for identity id i and the key update for time t j on some node in the tree. Since the private keys and key updates associated with a specific node are not given to the users simultaneously, collusion among some (non-revoked) users on some 1 The case for ciphertext-policy ABE setting is similar. attributes (i.e. time attribute) is possible. Hence from the view of ABE, all users can be regarded as "sharing" the same key (or private component) associated with access structure of the form</p><formula xml:id="formula_0">(id 1 ∨ • • • ∨ id n ) ∧ (t 1 ∨ • • • ∨ t m )</formula><p>on each node in the tree for some integers n and m, but each user is given only some parts of the key for this access structure. That is, the parts of the key that the user gets correspond to access structure</p><formula xml:id="formula_1">id i ∧ (t 1 ∨ • • • ∨ t m ) if</formula><p>this node is in the path from the leaf node associated with id i to the root node; while the key updates corresponding to (t 1 ∨ • • • ∨ t m ) are given to all users (not necessarily at the same time). Clearly, we require that the private keys are collusion-resistant on different nodes. Moreover, supporting a large universe attribute space is required and can be used to deal with exponential identity spaces in RIBE.</p><p>We observe that, however, the adaptively secure ABE schemes of <ref type="bibr" target="#b24">[25]</ref> cannot be used directly for our purpose because the resulting RIBE somewhat unexpectedly has private keys and ciphertexts with sizes that grow linearly in the maximal number of users and the size of time space (even though they are polynomial in the security parameter).</p><p>It turns out that constructing a fully secure RIBE scheme with constant-size public parameters and keys requires additional work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Our Contributions</head><p>In this paper, we investigate how to instantiate the Waters dual system encryption methodology with revocable IBE schemes. Particularly, we construct two efficient non-interactive RIBE schemes that are proven to be adaptively secure under the Symmetric External Diffie-Hellman (SXDH) and the Decisional Linear (DLIN) assumptions, respectively.</p><p>Our schemes improve the previous work by achieving adaptive security with constant-size public parameters.</p><p>Moreover, our schemes are anonymous, namely, preserving the privacy of ciphertext recipients and encryption times.</p><p>We note that previous RIBE schemes do not consider the anonymity property, an advantage inherited from using the dual pairing vector spaces (DPVS) <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref> to achieve orthogonality and entropy-hiding in prime-order groups.</p><p>Our constructions also make use of the key revocation techniques of <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b20">21]</ref>, namely, we employ binary-tree data structure to achieve key update with logarithmic complexity in the maximal number of users for the key authority.</p><p>We give a summary of comparisons between existing and our RIBE schemes in Table <ref type="table">I</ref>. Here, we use PP to denote public parameters, MK to denote master key, SK to denote private key, KU to denote key update, CT to denote ciphertext, and # pairing to denote the number of pairing computation for decryption. The sizes are in terms of group elements and λ denotes the security parameter.</p><p>TABLE I COMPARISONS BETWEEN EXISTING AND OUR RIBE SCHEMES. BGK [5] LV [21] Ours size of PP 5 O(λ) 19 55 size of MK 1 1 19 55 size of SK 2 3 6 9 size of KU 2 3 6 9 size of CT 4 5 6 9 # pairings 4 3 12 18 security selective adaptive adaptive adaptive anonymity No No Yes Yes assumption DBDH mDBDH SXDH DLIN</p><p>We compare our schemes against Boldyreva et al.'s scheme <ref type="bibr" target="#b4">[5]</ref>, which is under the Decision Bilinear Diffie-Hellman (DBDH) assumption, and Libert and Vergnaud's scheme <ref type="bibr" target="#b20">[21]</ref>, which is under the modified DBDH (mDBDH) assumption. Overall, our schemes are anonymous, adaptively secure, and have constant-size public parameters, at the expense of bigger (but still seems acceptable) sizes in terms of the master key, private key, and key update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Our Approach</head><p>In RIBE, different from the standard security game for IBE, the adversary is allowed to query parts of the challenge identities and time periods. Thus, to overcome the problem of increasing sizes of public parameters in the maximal number of users and sizes of the time space as analyzed in the ABE setting, our security proof makes use of two types of nominally semi-functional pairs, while all the previous works based on the dual system encryption methodology, such as <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b24">25]</ref>, require only a single type of nominally semi-functional pair. Moreover, prior to the start of the game, we execute a preliminary game to "locate" the positions of the challenge identities and times. We then transform all the private keys and key updates associated with the non-challenge identities and times, respectively, into nominally semi-functional (we denote by Type I) one by one. We transform the challenge private keys and key updates (or simply keys) into nominally semi-functional (we denote by Type II) node by node at the last step. Note that the distribution of nominally semi-functional pairs of Type I for challenge identities and times can be detected by the adversary that they are different from the distribution of the semi-functional keys and ciphertexts. Moreover, nominally semi-functional pairs of Type II can be only generated for the last remaining keys; in other words, all the other keys must have been already semi-functional. This is why the preliminary game is needed. We also introduce some statistical indistinguishability arguments in our proof to show that the distributions of nominally semi-functional pair of both Types I &amp; II remain the same as the distributions of semi-functional keys and ciphertexts from the adversary's view. Finally, we arrive at a security game that only requires to generate semi-functional keys and ciphertexts while security can be proved directly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PRELIMINARIES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Dual Pairing Vector Spaces</head><p>Our constructions are based on dual pairing vector spaces proposed by Okamoto and Takashima <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref>. In this paper, we concentrate on the asymmetric version <ref type="bibr" target="#b25">[26]</ref>. Particularly, we give a brief description on how to generate random dual orthonormal bases. See <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref> for a full definition of dual pairing vector spaces.</p><p>Definition 1 (Asymmetric bilinear pairing groups). Asymmetric bilinear pairing groups (q, G 1 , G 2 , G T , g 1 , g 2 , e) are a tuple of a prime q, cyclic (multiplicative) groups G 1 , G 2 and G T of order q, g 1</p><formula xml:id="formula_2">= 1 ∈ G 1 , g 2 = 1 ∈ G 2 ,</formula><p>and a polynomial-time computable nondegenerate bilinear pairing e : G 1 × G 2 → G T i.e., e(g s 1 , g t 2 ) = e(g 1 , g 2 ) st and e(g 1 , g 2 ) = 1.</p><p>In addition to individual elements of G 1 or G 2 , we will also consider "vectors" of group elements. For v = (v 1 , . . . , v n ) ∈ Z n q and g β ∈ G β , we write g v β to denote a n-tuple of elements of G β for β = 1, 2:</p><formula xml:id="formula_3">g v β := (g v1 β , . . . , g vn β ).</formula><p>For any a ∈ Z q and v, w ∈ Z n q , we have:</p><formula xml:id="formula_4">g av β := (g av1 β , . . . , g avn β ), g v+w β := (g v1+w1 β , . . . , g vn+wn β ).</formula><p>Then we define</p><formula xml:id="formula_5">e(g v 1 , g w 2 ) := n i=1 e(g vi 1 , g wi 2 ) = e(g 1 , g 2 ) v•w .</formula><p>Here, the dot product is taken modulo q.</p><p>Dual Pairing Vector Spaces. For a fixed (constant) dimension n, we choose two random bases B := (b 1 , . . . , b n ) and B * := (b * 1 , . . . , b * n ) of Z n q , subject to the constraint that they are "dual orthonormal", meaning that b i • b * j = 0 (mod q) whenever i = j, and</p><formula xml:id="formula_6">b i • b * i = ψ (mod q)</formula><p>for all i, where ψ is a random element of Z q . We denote the above algorithm, which generates the dual orthonormal bases, as Dual(•). Then for generators g 1 ∈ G 1 and g 2 ∈ G 2 , we have</p><formula xml:id="formula_7">e(g bi 1 , g b * j 2 ) = 1</formula><p>whenever i = j, where 1 here denotes the identity element in G T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Complexity Assumptions</head><p>To define the SXDH assumption, we first define DDH problems in G 1 and G 2 .</p><p>Definition 2 (DDH1: Decisional Diffie-Hellman Assumption in G 1 ). Given a group generator G, we define the following distribution:</p><formula xml:id="formula_8">G := (q, G 1 , G 2 , G T , g 1 , g 2 , e) ← R G, a, b, c ← R Z q , D := (G; g 1 , g 2 , g a 1 , g b 1 )</formula><p>.</p><p>We assume that for any PPT algorithm A (with output in {0, 1}),</p><formula xml:id="formula_9">Adv DDH1 A (λ) := Pr[A(D, g ab 1 ) -Pr[A(D, g ab+c 1 )]</formula><p>is negligible in the security parameter λ.</p><p>The dual of the Decisional Diffie-Hellman assumption in G 1 is Decisional Diffie-Hellman assumption in G 2 (denoted as DDH2), which is identical to Definitions 2 with the roles of G 1 and G 2 reversed. We say that:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. The Symmetric External Diffie-Hellman assumption holds if DDH problems are intractable in both</head><formula xml:id="formula_10">G 1 and G 2 .</formula><p>The following SXDH-based Subspace assumptions is from <ref type="bibr" target="#b10">[11]</ref>, which we will use in our security proof.</p><p>Definition 4 (DS1: Decisional Subspace Assumption in G 1 ). Given a group generator G(•), define the following distribution:</p><formula xml:id="formula_11">G := (q, G 1 , G 2 , G T , g 1 , g 2 , e) ← R G(1 λ ), (B, B * ) ← R Dual(Z N q ), τ 1 , τ 2 , µ 1 , µ 2 ← R Z q , U 1 := g µ1b * 1 +µ2b * K+1 2 , . . . , U K := g µ1b * K +µ2b * 2K 2 , V 1 := g τ1b1 1 , . . . , V K := g τ1bK 1 , W 1 := g τ1b1+τ2bK+1 1 , . . . , W K := g τ1bK +τ2b2K 1 , D := (G; g b * 1 2 , . . . , g b * K 2 , g b * 2K+1 2 , . . . , g b * N 2 , g b1 1 , . . . , g bN 1 , U 1 , . . . , U K , µ 2 ),</formula><p>where K, N are fixed positive integers that satisfy 2K ≤ N . We assume that for any PPT algorithm A (with output in {0, 1}),</p><formula xml:id="formula_12">Adv DS1 A (λ) := | Pr[A(D, V 1 , . . . , V K ) = 1] -Pr[A(D, W 1 , . . . , W K ) = 1]|</formula><p>is negligible in the security parameter λ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1.</head><p>If the DDH assumption in G 1 holds, then the Subspace assumption in G 1 stated in Definition 4 also holds.</p><p>More precisely, for any adversary A against the Subspace assumption in G 1 , there exist probabilistic algorithms B whose running times are essentially the same as that of A, such that</p><formula xml:id="formula_13">Adv DS1 A (λ) ≤ Adv DDH1 B (λ).</formula><p>The dual of the Subspace assumption in G 1 is Subspace assumption in G 2 (denoted as DS2), which is identical to Definitions 4 with the roles of G 1 and G 2 reversed. Similarly, the Subspace assumption holds in G 2 if the DDH assumption in G 2 holds.</p><p>We define the DLIN problem in symmetric bilinear pairing groups (namely</p><formula xml:id="formula_14">G 1 = G 2 ).</formula><p>The DLIN-based Subspace assumptions could be found in <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b24">25]</ref>.</p><p>Definition 5 (DLIN: Decisional Linear Assumption). Given a group generator G, we define the following distribution:</p><formula xml:id="formula_15">G := (q, G, G T , g, e) ← R G, a 1 , a 2 , b 1 , b 2 , c ← R Z q , D := (G; g, g a1 , g a2 , g a1b1 , g a2b2 ).</formula><p>We assume that for any PPT algorithm A (with output in {0, 1}),</p><formula xml:id="formula_16">Adv DLIN A (λ) := Pr[A(D, g b1+b2 ) -Pr[A(D, g<label>b1+b2+c 1 )</label></formula><p>]</p><p>is negligible in the security parameter λ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. REVOCABLE IBE</head><p>We first recall the definition of RIBE and its security from <ref type="bibr" target="#b4">[5]</ref> and then define an appropriate security model for our constructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6. An Identity-Based Encryption with efficient revocation or simply Revocable IBE (RIBE) scheme has</head><p>seven PPT algorithms Setup, PriKeyGen, KeyUpd, DecKeyGen, Enc, Dec, and KeyRev with associated message space M, identity space I and time space T . We assume that the size of T is polynomial in the security parameter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Each algorithm is run by either one of three types of parties-key authority, sender or receiver. Key authority maintains a revocation list RL and state ST. In what follows, an algorithm is called stateful if it updates RL or</head><p>ST. We treat time as discrete as opposed to continuous.</p><p>• Setup(1 λ , N max ) takes as input a security parameter λ and a maximal number of users N max . It outputs public parameters PP, a master key MK, a revocation list RL (initially empty), and a state ST. (This is run by the key authority.) • PriKeyGen(PP, MK, id, ST) takes as input the public parameters PP, the master key MK, an identity id ∈ I, and the state ST. It outputs a private key SK id and an updated state ST. (This is stateful and run by the key authority.) • KeyUpd(PP, MK, t, RL, ST) takes as input the public parameters PP, the master key MK, a key update time t ∈ T , the revocation list RL, and the state ST. It outputs a key update KU t . (This is run by the key authority.) • DecKeyGen(SK id , KU t ) takes as input a private key SK id and key update KU t . It outputs a decryption key DK id,t or a special symbol ⊥ indicating that id was revoked. (This is deterministic and run by the receiver.) • Enc(PP, id, t, m) takes as input the public parameters PP, an identity id ∈ I, an encryption time t ∈ T , and a message m ∈ M. It outputs a ciphertext CT id,t . (This is run by the sender.) • Dec(PP, DK id,t , CT id,t ) takes as input the public parameters PP, a decryption key DK id,t , and a ciphertext CT id,t . It outputs a message m ∈ M. (This is deterministic and run by the receiver.) • KeyRev(id, t, RL, ST) takes as input an identity to be revoked id ∈ I, a revocation time t ∈ T , the revocation list RL, and the state ST. It outputs an updated revocation list RL. (This is stateful and run by the key authority.)</p><p>The consistency condition requires that for all λ ∈ N and polynomials (in λ) N max , all PP and MK output by setup algorithm Setup, all m ∈ M, id ∈ I, t ∈ T and all possible valid states ST and revocation lists RL, if identity id was not revoked before or, at time t then the following experiment returns 1 except for a negligible probability:</p><formula xml:id="formula_17">(SK id , ST) ← R PriKeyGen(PP, MK, id, ST); KU t ← R KeyUpd(PP, MK, t, RL, ST) DK id,t ← DecKeyGen(SK id , KU t ); CT id,t ← R Enc(PP, id, t, m)</formula><p>If Dec(PP, DK id,t , CT id,t ) = m then return 1 else return 0.</p><p>Boldyreva et al. formalized and defined the selective-ID security for RIBE. Their definition captures not only the standard notion of selective-ID security but also takes into account key revocation. The following definition extends the security property expressed in <ref type="bibr" target="#b4">[5]</ref> to the adaptive-ID and anonymous setting.</p><p>• Setup: It is run to generate public parameters PP, a master key MK, a revocation list RL (initially empty), and a state ST. Then PP is given to A.</p><p>• Query: A may adaptively make a polynomial number of queries of the following oracles (the oracles share state):</p><p>-The private key generation oracle PriKeyGen(•) takes as input an identity id and runs PriKeyGen(PP, MK, id, ST)</p><p>to return a private key SK id .</p><p>-The key update generation oracle KeyUpd(•) takes as input time t and runs KeyUpd(PP, MK, t, RL, ST)</p><p>to return a key update KU t .</p><p>-The revocation oracle KeyRev(•, •) takes as input an identity id and time t and runs KeyRev(id, t, RL, ST)</p><p>to update RL.</p><p>• Challenge: A outputs the two challenge pair (id</p><formula xml:id="formula_18">* (0) , t * (0) , m * (0) ), (id * (1) , t * (1) , m * (1) ) ∈ I × T × M. A random bit β is chosen. A is given Enc(PP, id * (β) , t * (β) , m * (β)</formula><p>).</p><p>• Guess: The adversary may continue to make queries of the oracles as in Query phase and outputs a bit β ′ , and succeeds if β ′ = β.</p><p>The following restrictions must always hold:</p><p>1) KeyUpd(•) and KeyRev(•, •) can be queried on time which is greater than or equal to the time of all previous queries, i.e., the adversary is allowed to query only in non-decreasing order of time. Also, the oracle KeyRev(•, •) cannot be queried at time t if KeyUpd(•) was queried on t.</p><p>2) For β = 0, 1, if PriKeyGen(•) was queried on identity id (β) then KeyRev(•, •) must be queried on (id * (β) , t) for some t ≤ t * (β) , i.e., identity id * (β) must be in RL when KeyUpd(•) is queried at time t * (β) .</p><p>For β = 0, 1 let W β be the event that the adversary outputs 1 in Experiment β and define</p><formula xml:id="formula_19">Adv RIBE A (λ) := | Pr[W 0 ] -Pr[W 1 ]|.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7. An RIBE scheme is adaptive-ID secure and anonymous if for all PPT adversaries A the function</head><formula xml:id="formula_20">Adv RIBE A (λ) is negligible.</formula><p>Remark: The security notion of non-anonymous RIBE is defined as above with restriction that id * (0) = id * (1) and t * (0) = t * (1) . On the other hand, if the adversary A outputs (id * (0) , id * (0) ) and (id * (1) , t * (1) ) before the Setup phase, it is selective-ID security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. CONSTRUCTION FROM SXDH</head><p>In this section, we present our first construction of RIBE and its proof of security under the SXDH assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Binary-tree Data Structure</head><p>Key revocation in our scheme relies on binary-tree data structure, as with <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b20">21]</ref>. We denote the binary-tree by BT and its root node by root. If ν is a leaf node then Path(ν) denotes the set of nodes on the path from ν to root (both ν and root inclusive). If θ is a non-leaf node then θ ℓ , θ r denote the left and right child of θ, respectively.</p><p>We assume that all nodes in the tree are uniquely encoded as strings, and the tree is defined by all of its node descriptions.</p><p>Each user is assigned to a leaf node ν. Upon registration, the key authority provides the user with a set of distinct private keys for each node in Path(ν). At time t, the key authority uses an algorithm called KUNodes to determine the minimal set Y of nodes in BT such that none of the nodes in RL with corresponding time ≤ t (users revoked on or before t) have any ancestor (or, themselves) in the set Y, and all other leaf nodes (corresponding to non-revoked users) have exactly one ancestor (or, themselves) in the set. The KUNodes algorithm takes as input a binary tree BT, a revocation list RL and a time t, and can be formally specified as follows:</p><formula xml:id="formula_21">KUNodes(BT, RL, t) X, Y ← ∅ ∀(ν i , t i ) ∈ RL if t i ≤ t then add Path(ν i ) to X ∀θ ∈ X if θ ℓ ∈ X then add θ ℓ to Y if θ r ∈ X then add θ r to Y If Y = ∅ then add root to Y Return Y</formula><p>The KUNodes algorithm marks all the ancestors of revoked nodes as revoked and outputs all the non-revoked children of revoked nodes. The key authority then publishes a key update for all nodes of Y. A user assigned to leaf ν is then able to form an effective decryption key for time t if the set Y contains a node in Path(ν). By doing so, every update of the revocation list RL only requires the key authority to perform logarithmic work in the maximal number of users and linear in the number of revoked users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Our Scheme</head><p>We now specify our RIBE scheme. We sometimes provide some intuition or remark at the end of an algorithm and this is marked by the symbol "//".</p><p>• Setup(λ, N max ) On input a security parameter λ, and a maximal number N max of users, and generate a bilinear pairing G := (q, G 1 , G 2 , G T , g 1 , g 2 , e) for sufficiently large prime order q. Next perform the following steps:</p><p>1) Let RL be an empty set and BT be a binary-tree with at least N max leaf nodes, set ST = BT. </p><formula xml:id="formula_22">:= e(g 1 , g 2 ) αd1•d *<label>1</label></formula><p>3) Output RL, ST, the public parameters</p><formula xml:id="formula_23">PP := G; g α T , g d1 1 , g d2 1 , g d3 1 ,</formula><p>and the master key MK MK := α, g</p><formula xml:id="formula_24">d * 1 2 , g d * 2 2 , g d *<label>3</label></formula><p>2 .</p><p>• PriKeyGen(PP, MK, id, RL, ST) On input the public parameters PP, the master key MK, an identity id, the revocation list RL, and the state ST, it picks an unassigned leaf node v from BT and stores id in that node.</p><p>It then performs the following steps:</p><p>1) For any θ ∈ Path(v), if α θ,1 , α θ,2 are undefined, then pick α θ,1 ← R Z q , set α θ,2 = αα θ,1 , and store them in node θ 2 . Pick r θ,1 ← R Z q and compute K id,θ := g</p><formula xml:id="formula_25">(α θ,1 +r θ,1 id)d * 1 -r θ,1 d * 2 2</formula><p>.</p><p>2) Output SK id := {(θ, K id,θ )} θ∈Path(v) , ST.</p><p>//The algorithm computes the id-component of the decryption key for all the nodes on the path from the leaf node (corresponding to id) to root.</p><p>• KeyUpd(PP, MK, t, RL, ST) On input the public parameters PP, the master key MK, a time t, the revocation list RL, and the state ST, it performs the following steps:</p><formula xml:id="formula_26">1) ∀θ ∈ KUNodes(BT, RL, t), if α θ,1 , α θ,2 are undefined, then pick α θ,1 ← R Z q , set α θ,2 = α -α θ,1</formula><p>, and store them in node θ. Pick r θ,2 ← R Z q and compute</p><formula xml:id="formula_27">K t,θ := g (α θ,2 +r θ,2 t)d * 1 -r θ,2 d * 3 2<label>.</label></formula><p>2) Output KU t := {(θ, K t,θ )} θ∈KUNodes(BT,RL,t) .</p><p>//The algorithm first finds a minimal set of nodes which contains an ancestor (or, the node itself) of all the non-revoked nodes. Then it computes the t-component of the decryption key for all the nodes in that set.</p><p>• DecKeyGen(SK id , KU t ) On input a private secret key SK id := {(i, K id,i )} i∈I , KU t := {(j, K t,j )} j∈J for some set of nodes I, J, it runs the following steps:</p><p>1) ∀(i, K id,i ) ∈ SK id , (j, K t,j ) ∈ KU t , if ∃(i, j) s.t. i = j then DK id,t ← (K id,i , K t,j ); else (if SK id and KU t do not have any node in common) DK id,t ← ⊥.</p><p>2) Output DK id,t .</p><p>• Enc(PP, id, t, m) On input the public parameters PP, an identity id, a time t ∈ Z n q , and a message m, pick z ← R Z q and forms the ciphertext as</p><formula xml:id="formula_28">CT id,t := C := m • (g α T ) z , C 0 := g z(d1+idd2+td3)<label>1</label></formula><p>.</p><p>• Dec(PP, DK id,t , CT id,t ) On input the public parameters PP, a decryption key DK id,t := (K id,θ , K t,θ ), and a ciphertext CT id,t := (C, C 0 ), it computes the message as</p><formula xml:id="formula_29">m := C/ (e(C 0 , K id,θ ) • e(C 0 , K t,θ )) .</formula><p>• KeyRev(id, t, RL, ST) On input an identity id, a time t, the revocation list RL, and the state ST, the algorithm adds (id, t) to RL for all nodes ν associated with identity id and returns RL.</p><p>This ends the description of our scheme. 2 To avoid having to store α θ,1 , α θ,2 for each node, the authority can derive them from a pseudo-random function of using a shorter seed and re-compute them when necessary.</p><p>Correctness: Observe that e(C 0 , K id,θ ) = e(g z(d1+idd2+td3) 1</p><p>, g</p><formula xml:id="formula_30">(α θ,1 +r θ,1 id)d * 1 -r θ,1 d * 2 2 ) = e(g 1 , g 2 ) α θ,1 zd1•d * 1 • e(g 1 , g 2 ) zr θ,1 idd1•d * 1 -zr θ,1 idd2•d * 2 = e(g 1 , g 2 ) α θ,1 zd1•d * 1 .</formula><p>Similarly, e(C 0 , K t,θ ) = e(g 1 , g 2 ) α θ,2 zd1•d * 1 . The message is recovered as:</p><formula xml:id="formula_31">C/e(C 0 , K id,θ ) • e(C 0 , K t,θ ) = m • (e(g 1 , g 2 ) αd1•d * 1 ) z /e(g 1 , g 2 ) αzd1•d * 1 = m.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Proof of Security</head><p>Statistical Indistinguishability Lemmas: We require the following two lemmas, which are derived from <ref type="bibr" target="#b25">[26]</ref>, for our security proofs.</p><p>Lemma 2. For p ∈ Z q , let</p><formula xml:id="formula_32">C p := (x, v)|x • v = p, 0 = x, 0 = v ∈ Z n q .</formula><p>For all (x, v) ∈ C p , for all (z, w) ∈ C p , and A ← R Z n×n q (A is invertible with overwhelming probability),</p><formula xml:id="formula_33">Pr[xA ⊤ = z ∧ vA -1 = w] = 1 #C p . Lemma 3. For p 1 , p 2 ∈ Z q , let C p1,p2 := (x, v 1 , v 2 ) x = 0, x • v 1 = p 1 , x • v 2 = p 2 where x, v 1 , v 2 ∈ Z n q , {v 1 , v 2 } are linearly independent over Z q . For all (x, v 1 , v 2 ) ∈ C p1,p2</formula><p>, for all (z, w 1 , w 2 ) ∈ C p1,p2 , and A ← R Z n×n q (A is invertible with overwhelming probability),</p><formula xml:id="formula_34">Pr[xA ⊤ = z ∧ v 1 A -1 = w 1 ∧ v 2 A -1 = w 2 ] = 1 #C p1,p2</formula><p>.</p><p>The following theorem shows that our RIBE scheme is indeed adaptively secure and anonymous.</p><p>Theorem 1. The RIBE scheme is adaptively secure and anonymous under the SXDH assumption. More precisely, for any adversary A against the RIBE scheme, there exist probabilistic algorithms B 0 , {B κ1,κ2 } κ1=1,...,qn 1 ,κ2=1,...,⌈log Nmax⌉ , {B κ1,κ2 } κ1=qn 1 +1,...,qn 1 +qn 2 +1,κ2=1,...,Nmax , {B qn 1 +qn 2 +1,κ2 } κ2=1,...,4Nmax</p><p>whose running times are essentially the same as that of A, such that</p><formula xml:id="formula_35">Adv RIBE A (λ) ≤ (q n1 q n2 ) 2 • Adv DDH1 B0 (λ) + qn 1 κ1=1 ⌈log Nmax⌉ κ2=1 Adv DDH2 Bκ 1 ,κ 2 (λ) + qn 2 κ1=qn 1 +1 Nmax κ2=1 Adv DDH2 Bκ 1 ,κ 2 (λ) + 4Nmax κ2=1 Adv DDH2</formula><p>Bq n 1 +qn 2 +1,κ 2 (λ) + 6(q n1 ⌈log N max ⌉ + q n2 N max ) + 32N max + 6 q where q n1 , q n2 ≥ 4 are the maximum number of A's private key and key update queries respectively.</p><p>Proof: We adopt the dual system encryption methodology by Waters <ref type="bibr" target="#b30">[31]</ref> to prove the security of our RIBE scheme. We use the concepts of semi-functional ciphertexts and semi-functional keys in our proof and provide algorithms that generate them. Particularly, we define two types of semi-functional keys: semi-functional private keys (for identity) and semi-functional key updates (for time). We note that the algorithms (we specify below) are only provided for definitional purposes, and are not part of the RIBE system. In particular, they do not need to be efficiently computable from the public parameters and the master key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PriKeyGenSF</head><p>The algorithm picks r θ,1 , ν θ,4,1 , ν θ,5,1 , ν θ,6,1 randomly from Z q and forms a semi-functional private key for node θ as</p><formula xml:id="formula_36">K (SF) id,θ := g (α θ,1 +r θ,1 id)d * 1 -r θ,1 d * 2 +[ν θ,4,1 d * 4 +ν θ,5,1 d * 5 +γ θ,6,1 d * 6 ] 2</formula><p>.</p><p>(1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>KeyUpdSF</head><p>The algorithm picks r θ,2 , ν θ,4,2 , ν θ,5,2 , ν θ,6,2 randomly from Z q and forms a semi-functional updated key for node θ as</p><formula xml:id="formula_37">K (SF)</formula><p>t,θ := g (α θ,2 +r θ,2 t)d * 1 -r θ,2 d * 3 +[ν θ,4,2 d * 4 +ν θ,5,2 d * 5 +ν θ,6,2 d * 6 ] 2</p><p>.</p><p>(</p><formula xml:id="formula_38">)<label>2</label></formula><p>EncryptSF The algorithm picks z, χ 4 , χ 5 , χ 6 randomly from Z q and forms a semi-functional ciphertext as</p><formula xml:id="formula_39">CT (SF) id,t := C := m • (g α T ) z , C 0 := g z(d1+idd2+td3)+(χ4d4+χ5d5+χ6d6) 1 .<label>(3)</label></formula><p>We call a private key or key update semi-functional if all its parts are semi-functional, which are denoted as</p><formula xml:id="formula_40">SK (SF) id := {(θ, K (SF) id,θ )} θ∈Path(v) KU (SF) t := {(θ, K (SF) t,θ )} θ∈KUNodes(BT,RL,t) .</formula><p>We observe that a normal ciphertext CT id,t can be decrypted by a semi-functional key pair (K</p><formula xml:id="formula_41">(SF) id,θ , K (SF) t,θ ) on some node θ, because d * 4 , d * 5 , d * 6</formula><p>are orthogonal to all of the vectors in exponent of C 0 , and hence have no effect on decryption. Similarly, decryption of a semi-functional ciphertext CT (SF) id,t by a normal key pair (K id,θ , K t,θ ) on some node θ will also succeed because d 4 , d 5 , d 6 are orthogonal to all of the vectors in the exponent of the key. When both the ciphertext and key pair on some node are semi-functional, the result of e(C</p><formula xml:id="formula_42">(SF) 0 , K (SF) id,θ ) • e(C (SF) 0 , K (SF) t,θ )</formula><p>will have an additional term, namely e(g 1 , g 2 )</p><formula xml:id="formula_43">6 i=4 (ν θ,i,1 +ν θ,i,2 )χid * i •di = e(g 1 , g 2 ) 6 i=4 (ν θ,i,1 +ν θ,i,2 )χiψ .</formula><p>Decryption will then fail unless 6 i=4 (ν θ,i,1 + ν θ,i,2 )χ i ψ ≡ 0 mod q. If this modular equation holds, we say that the private key, key update and ciphertext pair is nominally semi-functional. In our security proof, there are two types of nominally semi-functional pairs:</p><p>Nominally semi-functional pair of Type I</p><formula xml:id="formula_44">K (SF) id,θ := g (α θ,1 +r θ,1 id)d * 1 -r θ,1 d * 2 +[ν θ,4,1 idd * 4 -ν θ,4,1 d * 5 ] 2 , K (SF) t,θ := g (α θ,2 +r θ,2 t)d * 1 -r θ,2 d * 3 +[ν θ,4,2 td * 4 -ν θ,4,2 d * 6 ] 2 , CT (SF) id,t := C := m • (g α T ) z , C 0 := g z(d1+idd2+td3)+[χ4(d4+idd5+td6)] 1 , where r θ,1 , ν θ,4,1 , r θ,2 , ν θ,4,2 , z, χ 4 ← R Z q .</formula><p>Nominally semi-functional pair of Type II</p><formula xml:id="formula_45">K (SF) id,θ := g (α θ,1 +r θ,1 id)d * 1 -r θ,1 d * 2 +[(α θ +ν θ,4,1 id)d * 4 -ν θ,4,1 d * 5 ] 2 , K (SF) t,θ := g (α θ,2 +r θ,2 t)d * 1 -r θ,2 d * 3 +[(-α θ +ν θ,4,2 t)d * 4 -ν θ,4,2 d * 6 ] 2 , CT (SF) id,t := C := m • (g α T ) z , C 0 := g z(d1+idd2+td3)+[χ4(d4+idd5+td6)]<label>1</label></formula><p>,</p><formula xml:id="formula_46">where α θ , r θ,1 , ν θ,4,1 , r θ,2 , ν θ,4,2 , z, χ 4 ← R Z q .</formula><p>Note that nominally semi-functional pair of Type I is used to transform the non-challenge private key and key update queries into semi-functional ones while Type II is for the challenge private key and key update queries.</p><p>Assume that a probabilistic polynomial-time adversary A makes at most q n1 private key queries id 1 , . . . , id qn 1 and q n2 key update queries t 1 , . . . , t qn 2 . Since there are many types of adversaries according to whether the challenges id * (0) , id * (1) t * (0) , t * (1) being queried and the restriction of queries, in order to simplify and unify reduction, we add four dumb queries id qn 1 +1 , id qn 1 +2 , t qn 2 +1 , t qn 2 +2 (the keys for these queries will not be given to A), which makes the challenge identities id * (0) , id * (1) and times t * (0) , t * (1) be included in the q n1 + 2 private key queries and the the q n2 + 2 key update queries. For any adversary, we use values ϕ 1 , ϕ 2 (0 &lt; ϕ 1 &lt; ϕ 2 &lt; q n1 + 2) to indicate the positions of id * (0) , id * (1) being queried, namely either the ϕ 1 -th or ϕ 2 -th query is id * (0) and the other is id * (1) . Similarly, we use values ϕ 3 , ϕ 4 (0 &lt; ϕ 3 &lt; ϕ 4 &lt; q n2 + 2) to indicate the positions of t * (0) , t * (1) being queried. Our proof of security consists of the following sequence of games between the adversary A and challengers.</p><p>• Game Real : is the real security game.</p><p>• Game Real ′ : is a preliminary game, which is the same as Game Real except that the challenger picks</p><formula xml:id="formula_47">φ 1 , φ 2 ← R [q n1 + 2] (0 &lt; φ 1 &lt; φ 2 &lt; q n1 + 2) and φ 3 , φ 4 ← R [q n2 + 2] (0 &lt; φ 3 &lt; φ 4 &lt; q n2 +</formula><p>2) before setup, and the game is aborted if φ i = ϕ i for any i ∈ <ref type="bibr" target="#b3">[4]</ref>.</p><p>//Guess the positions of the challenge identities id * (0) , id * (1) and times t * (0) , t * (1) . If the guess is incorrect then the game aborts. Re-write</p><formula xml:id="formula_48">Γ 1 := {id ′ 1 , . . . , id ′ qn 1 } = {id 1 , . . . , id qn 1 +2 }\{id ϕ1 , id ϕ2 } Γ 2 := {t ′ 1 , . . . , t ′ qn 2 } = {t 1 , . . . , t qn 2 +2 }\{t ϕ3 , t ϕ4 }.</formula><p>• Game 0 : is the same as Game Real ′ except that the challenge ciphertext is semi-functional.</p><p>• Game κ1,κ2 : for κ 1 from 1 to q n1 , for κ 2 from 0 to ⌈log N max ⌉, Game κ1,κ2 is the same as Game 0 except that the first κ 1 -1 private keys and the first κ 2 components of the κ 1 -th private key for Γ 1 are semi-functional and the remaining keys are normal.</p><p>//Transform all private keys into semi-functional ones (one by one and node by node) except the φ 1 -th and φ 2 -th private queries. Namely, the private keys for the challenge identities id * (0) , id * (1) (if queried) are still normal. Note that the number of nodes associated with a private key is ⌈log N max ⌉. Moreover Game 1,0 and Game 0 , Game κ1,⌈log Nmax⌉ and Game κ1+1,0 are identical.</p><p>• Game κ1,κ2 : for κ 1 from q n1 + 1 to q n2 , for κ 2 from 0 to N max , Game κ1,κ2 is the same as Game qn 1 ,⌈log Nmax⌉ (namely all private keys for Γ 1 are semi-functional) except that the first κ 1q n1 -1 key updates and the first κ 2 components of the (κ 1q n1 )-th key update for Γ 2 are semi-functional and the remaining key updates are normal.</p><p>//Transform all key updates into semi-functional ones (one by one and node by node) except the φ 3 -th and φ 4 -th key update queries. Namely, the key updates for the challenge times t * (0) , t * (1) (if queried) are still normal. Note that a key update for a time updates at most N max nodes. Moreover, Game qn 1 ,⌈log Nmax⌉ and Game qn 1 +1,0 , Game κ1,Nmax and Game κ1+1,0 are identical.</p><p>• Game qn 1 +qn 2 +1,κ2 : for κ 2 from 0 to 4N max , Game qn 1 +qn 2 +1,κ2 is the same as Game qn 1 +qn 2 ,Nmax (namely all private keys for Γ 1 and key updates for Γ 2 are semi-functional) except that the φ 1 , φ 2 -th private keys, the φ 3 , φ 4 -th key updates for the first κ 2 nodes are semi-functional and the remaining keys are normal.</p><p>//Transform the ϕ 1 , ϕ 2 -th private key and the ϕ 3 , ϕ 4 -th key update queries into semi-functional ones (node by node). Note that there are at most 2 ⌈log Nmax⌉ (≤ 4N max ) nodes in the binary tree. Moreover, Game qn 1 +qn 2 ,Nmax and Game qn 1 +qn 2 +1,0 are identical, namely all keys are semi-functional in Game qn 1 +qn 2 +1,4Nmax .</p><p>• Game F inal : is the same as Game qn 1 +qn 2 +1,4Nmax , except that the challenge ciphertext is a semi-functional encryption of a random message in G T and under a random identity in Z q a random time in Z q . We denote the challenge ciphertext in Game F inal as CT (R) id (R) ,t (R) . We prove the following lemmas to show the above games are indistinguishable. The advantage gap between Game Real and Game 0 is bounded by the advantage of the Subspace assumption in G 1 . Additionally, we require a statistical indistinguishability argument to show that the distribution of the challenge ciphertext remains the same from the adversary's view. Similarly, the advantage gap between any two consecutive games of Game 1,1 to Game qn 1 +qn 2 +1,4Nmax is bounded by the advantage of Subspace assumption in G 2 . Finally, we statistically transform Game qn 1 +qn 2 +1,4Nmax to Game F inal in one step, i.e., we show the joint distributions of parameters in these two games are equivalent from the adversary's view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We let Adv Game Real</head><p>A denote an adversary A's advantage in the real game.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4. For any adversary A, Adv Game</head><formula xml:id="formula_49">Real A (λ) ≤ (q n1 q n2 ) 2 • Adv Game Real ′ A (λ).</formula><p>Proof: Since φ 1 , φ 2 , φ 3 , φ 4 are uniformly and independently generated, which are hidden from the adversary A's view. The game is non-aborted with probability 4 (q n1 + 2)(q n1 + 1)(q n2 + 2)(q n2 + 1) .</p><p>Thus,</p><formula xml:id="formula_50">Adv Game Real A (λ) = (q n1 + 2)(q n1 + 1)(q n2 + 2)(q n2 + 1) 4 • Adv Game Real ′ A (λ) ≤ (q n1 q n2 ) 2 • Adv Game Real ′ A (λ).</formula><p>Lemma 5. Suppose that there exists an adversary A where |Adv</p><formula xml:id="formula_51">Game Real ′ A (λ) -Adv Game0 A (λ)| = ǫ.</formula><p>Then there exists an algorithm B 0 such that Adv DS1 B0 (λ) = ǫ + 2 q , with K = 3 and N = 6.</p><p>Proof: B 0 is given</p><formula xml:id="formula_52">D := (G; g b * 1 2 , g b * 2 2 , g b * 3 2 , g b1 1 , . . . , g b6 1 , U 1 , U 2 , U 3 , µ 2 ).</formula><p>along with T 1 , T 2 , T 3 . We require that B 0 decides whether T 1 , T 2 , T 3 are distributed as g τ1b1</p><formula xml:id="formula_53">1 , g τ1b2 1 , g τ1b3 1 or g τ1b1+τ2b4 1 , g τ1b2+τ2b5 1 , g τ1b3+τ2b6 1 .</formula><p>B 0 simulates Game Real ′ or Game 0 with A, depending on the distribution of T 1 , T 2 , T 3 . To compute the public parameters and master key, B 0 chooses a random invertible matrix A ∈ Z 3×3 q (A is invertible with overwhelming probability if it is uniformly picked) and implicitly sets dual orthonormal bases D, D * to: We note that D, D * are properly distributed, and reveal no information about A. Moreover, B 0 cannot generate</p><formula xml:id="formula_54">g d *<label>4</label></formula><p>2 , g</p><formula xml:id="formula_55">d * 5 2 , g d *<label>6</label></formula><p>2 , but these will not be needed for creating normal private keys and key updates. B 0 chooses random value α ∈ Z q and computes g α T := e(g 1 , g 2 ) αd1•d * 1 . It then gives A the public parameters</p><formula xml:id="formula_56">PP := {G; g α T , g d1 1 , g d2 1 , g d3 1 }.</formula><p>The master key</p><formula xml:id="formula_57">MK := {α, g d * 1 2 , g d * 2 2 , g d * 3 2 }</formula><p>is known to B 0 , which allows B 0 to respond to all of A's queries by calling the normal private keys, key updates, and key revocation algorithms.</p><formula xml:id="formula_58">A sends B 0 two pairs (id * (0) , t * (0) , m * (0) ) and (id * (1) , t * (1) , m *<label>(1)</label></formula><p>). B 0 chooses a random bit β ∈ {0, 1} and encrypts m * (β) under (id * (β) , t * (β) ) as follows:</p><formula xml:id="formula_59">C := m * (β) • e(T 1 , g b * 1 2 ) α = m * (β) • (g α T ) z , C 0 := T 1 (T 2 ) id * (β) (T 3 ) t * (β) ,</formula><p>where B 0 has implicitly set z := τ 1 . It gives the ciphertext (C, C 0 ) to A.</p><formula xml:id="formula_60">Now, if T 1 , T 2 , T 3 are equal to g τ1b1 1 , g τ1b2 1 , g τ1b3 1</formula><p>, then this is a properly distributed normal encryption of m * (β) . In this case, B 0 has properly simulated Game Real ′ . If T 1 , T 2 , T 3 are equal to g τ1b1+τ2b4 1 , g τ1b2+τ2b5 1 , g τ1b3+τ2b6 1 instead, then the ciphertext element C 0 has an additional term of</p><formula xml:id="formula_61">τ 2 b 4 + id * (β) τ 2 b 5 + t * (β) τ 2 b 6</formula><p>in its exponent. The coefficients here in the basis b 4 , b 5 , b 6 form the vector (τ 2 , id * (β) τ 2 , t * (β) τ 2 ). To compute the coefficients in the basis d 4 , d 5 , d 6 , we multiply the matrix A -1 by the transpose of this vector, obtaining</p><formula xml:id="formula_62">τ 2 A -1 (1, id * (β) , t * (β) ) ⊤ .</formula><p>Since A is random (everything else given to A has been distributed independently of A), these coefficients are uniformly random except with probability 2/q (namely, the cases τ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) defined in Equation 3 is the zero vector ) from Lemma 2. Therefore, in this case, B 0 has properly simulated Game 0 . This allows B 0 to leverage A's advantage ǫ between Game Real ′ and Game 0 to achieve an advantage ǫ + 2 q against the Subspace assumption in G 1 , namely Adv DS1 B0 (λ) = ǫ + 2 q .</p><p>Lemma 6. For κ 1 from 1 to q n1 , for κ 2 from 0 to ⌈log N max ⌉, suppose that there exists an adversary A where</p><formula xml:id="formula_63">|Adv Gameκ 1 ,κ 2 -1 A (λ) -Adv Gameκ 1 ,κ 2 A (λ)| = ǫ.</formula><p>Then there exists an algorithm B κ1,κ2 such that Adv DS2 Bκ 1 ,κ 2 (λ) = ǫ + 6 q , with K = 3 and N = 6.</p><p>Proof: B κ1,κ2 is given</p><formula xml:id="formula_64">D := (G; g b1 1 , g b2 1 , g b3 1 , g b * 1 2 , . . . , g b * 6 2 , U 1 , U 2 , U 3 , µ 2 )</formula><p>along with T 1 , T 2 , T 3 . We require that B κ1,κ2 decides whether T 1 , T 2 , T 3 are distributed as g</p><formula xml:id="formula_65">τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2 or g τ1b * 1 +τ2b * 4 2 , g τ1b * 2 +τ2b * 5 2 , g τ1b * 3 +τ2b * 6 2 .</formula><p>B κ1,κ2 simulates Game κ1,κ2 or Game κ1,κ2-1 with A, depending on the distribution of T 1 , T 2 , T 3 . To compute the public parameters and master key, B κ1,κ2 chooses a random matrix A ∈ Z 3×3 q (with all but negligible probability, A is invertible). We then implicitly set dual orthonormal bases D, D * to:</p><formula xml:id="formula_66">d 1 := b 1 , d 2 := b 2 , d 3 := b 3 , (d 4 , d 5 , d 6 ) := (b 4 , b 5 , b 6 )A, d * 1 := b * 1 , d * 2 := b * 2 , d * 3 := b * 3 , (d * 4 , d * 5 , d * 6 ) := (b * 4 , b * 5 , b * 6 )(A -1 ) ⊤ .</formula><p>We note that D, D * are properly distributed, and reveal no information about A. B κ1,κ2 chooses random value α ∈ Z q and compute g α T := e(g 1 , g 2 ) αd1•d * 1 . B can gives A the public parameters</p><formula xml:id="formula_67">PP := {G; g α T , g d1 1 , g d2 1 , g d3 1 }.</formula><p>The master key</p><formula xml:id="formula_68">MK := {α, g d * 1 2 , g d * 2 2 , g d * 3 2 }</formula><p>is known to B κ1,κ2 , which allows B κ1,κ2 to respond to all of A's private key and key update queries by calling the normal key generation algorithm. Since B κ1,κ2 also knows g</p><formula xml:id="formula_69">d * 4 2 , g d *<label>5</label></formula><p>2 , and g</p><formula xml:id="formula_70">d *<label>6</label></formula><p>2 , it can easily produce semi-functional keys. To answer the key queries that A makes, B κ1,κ2 runs the semi-functional private key and key update generation algorithm to produce semi-functional keys and gives these to A. To answer the κ 2 -th component of the κ 1 -th private key for id ′ κ1 , B κ1,κ2 responds with:</p><formula xml:id="formula_71">K id ′ κ 1 ,θ := (g b * 1 2 ) α θ,1 T id ′ κ 1 1 (T 2 ) -1 .</formula><p>This implicitly sets r θ,</p><formula xml:id="formula_72">1 := τ 1 . If T 1 , T 2 , T 3 are equal to g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2</formula><p>, then this is a properly distributed normal private key. Otherwise, if T 1 , T 2 , T 3 are equal to g</p><formula xml:id="formula_73">τ1b * 1 +τ2b * 4 2 , g τ1b * 2 +τ2b * 5 2 , g τ1b * 3 +τ2b * 6 2</formula><p>, then this is a semi-functional key, whose exponent vector includes</p><formula xml:id="formula_74">id ′ κ1 τ 2 b * 4 -τ 2 b * 5<label>(4)</label></formula><p>as its component in the span of b * 4 , b * 5 , b * 6 . To respond to the remaining key queries, B κ1,κ2 simply runs the normal key generation algorithm.</p><p>At some point, A sends B κ1,κ2 two pairs (id</p><formula xml:id="formula_75">* (0) , t * (0) , m * (0) ) and (id * (1) , t * (1) , m *<label>(1)</label></formula><p>). B 0 chooses a random bit β ∈ {0, 1} and encrypts m * (β) under (id * (β) , t * (β) ) as follows:</p><formula xml:id="formula_76">C := m * (β) • e(U 1 , g b *<label>1</label></formula><p>2</p><formula xml:id="formula_77">) α = m * (β) • (g α T ) z , C 0 := U 1 (U 2 ) id * (β) (U 3 ) t * (β) ,</formula><p>where B κ1,κ2 has implicitly set z := µ 1 . The "semi-functional part" of the exponent vector here is:</p><formula xml:id="formula_78">µ 2 b 4 + id * (β) µ 2 b 5 + t * (β) µ 2 b 6 .<label>(5)</label></formula><p>We observe that if id * (β) = id ′ κ1 (which is impossible), then vectors 4 and 5 would be orthogonal, resulting in a nominally semi-functional ciphertext and key pair (B κ1,κ2 can also use T 1 , T 2 , T 3 to generate private key part for Using the change of basis matrix A, we obtain the new coefficients (in vector form) as:</p><formula xml:id="formula_79">τ 2 A ⊤ (id ′ κ1 , -1, 0) ⊤ , µ 2 A -1 (1, id * (β) , t * (β) ) ⊤ .</formula><p>Since the distribution of everything given to A except for the κ 2 -th component of the κ 1 -th private key K id ′ κ 1 ,θ and the challenge ciphertext (C, C 0 ) is independent of the random matrix A and id * (β) = id ′ κ1 , we can conclude that these coefficients are uniformly except with probability 4/q (namely, the cases µ 2 or τ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) or (ν θ,4,1 , ν θ,5,1 , ν θ,6,1 ) defined in Equations 3 and 1 is the zero vector) from Lemma 2. Thus, B κ1,κ2 has properly simulated Game κ1,κ2 in this case.</p><formula xml:id="formula_80">If T 1 , T 2 , T 3 are equal to g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2</formula><p>, then the coefficients of the vector 5 are uniformly except with probability 2/q (namely, the cases µ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) defined in Equations 3 is the zero vector) from Lemma 2. Thus, B κ1,κ2 has properly simulated Game κ1,κ2-1 in this case.</p><p>In summary, B κ1,κ2 has properly simulated either Game κ1,κ2-1 or Game κ1,κ2 for A, depending on the distribution of T 1 , T 2 , T 3 . It can therefore leverage A's advantage ǫ between these games to obtain an advantage ǫ + 6 q against the Subspace assumption in G 2 , namely Adv DS2 Bκ (λ) = ǫ + 6 q .</p><p>Lemma 7. For κ 1 from q n1 +1 to q n1 +q n2 , for κ 2 from 0 to N max , suppose that there exists an adversary A where</p><formula xml:id="formula_81">|Adv Gameκ 1 ,κ 2 -1 A (λ) -Adv Gameκ 1 ,κ 2 A (λ)| = ǫ.</formula><p>Then there exists an algorithm B κ1,κ2 such that Adv DS2 Bκ 1 ,κ 2 (λ) = ǫ + 6 q , with K = 3 and N = 6.</p><p>Proof: B κ1,κ2 is given</p><formula xml:id="formula_82">D := (G; g b1 1 , g b2 1 , g b3 1 , g b * 1 2 , . . . , g b * 6 2 , U 1 , U 2 , U 3 , µ 2 )</formula><p>along with T 1 , T 2 , T 3 . We require that B κ1,κ2 decides whether T 1 , T</p><p>2 , T 3 are distributed as g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2 or g τ1b * 1 +τ2b * 4 2 , g τ1b * 2 +τ2b * 5 2 , g τ1b * 3 +τ2b * 6 2 . B κ1,κ2 simulates Game κ1,κ2 or Game κ1,κ2-1 with A, depending on the distribution of T 1 , T 2 , T 3 . To compute the public parameters and master key, B κ1,κ2 chooses a random matrix A ∈ Z 3×3 q</p><p>(with all but negligible probability,</p><p>A is invertible). We then implicitly set dual orthonormal bases D, D * to:</p><formula xml:id="formula_83">d 1 := b 1 , d 2 := b 2 , d 3 := b 3 , (d 4 , d 5 , d 6 ) := (b 4 , b 5 , b 6 )A, d * 1 := b * 1 , d * 2 := b * 2 , d * 3 := b * 3 , (d * 4 , d * 5 , d * 6 ) := (b * 4 , b * 5 , b * 6 )(A -1 ) ⊤ .</formula><p>We note that D, D * are properly distributed, and reveal no information about A. B κ1,κ2 chooses random value α ∈ Z q and compute g α T := e(g 1 , g 2 ) αd1•d * 1 . B can gives A the public parameters</p><formula xml:id="formula_84">PP := {G; g α T , g d1 1 , g d2 1 , g d3 1 }.</formula><p>The master key</p><formula xml:id="formula_85">MK := {α, g d * 1 2 , g d * 2 2 , g d * 3 2 }</formula><p>is known to B κ1,κ2 , which allows B κ1,κ2 to respond to all of A's private key and key update queries by calling the normal key generation algorithm. Since B κ1,κ2 also knows g</p><formula xml:id="formula_86">d *<label>4</label></formula><p>2 , g</p><formula xml:id="formula_87">d *<label>5</label></formula><p>2 , and g</p><formula xml:id="formula_88">d *<label>6</label></formula><p>2 , it can easily produce semi-functional keys. To answer the key queries that A makes, B κ1,κ2 runs the semi-functional private key and key update generation algorithm to produce semi-functional keys and gives these to A. To answer the κ 2 -th component of the κ 1 -th private key for id ′ κ1 , B κ1,κ2 responds with:</p><formula xml:id="formula_89">K id ′ κ 1 ,θ := (g b * 1 2 ) α θ,1 T id ′ κ 1 1 (T 2 ) -1 .</formula><p>This implicitly sets r θ,1 := τ 1 . If T 1 , T</p><p>2 , T 3 are equal to g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2 , then this is a properly distributed normal private key. Otherwise, if T 1 , T 2 , T 3 are equal to g τ1b * 1 +τ2b * 4 2 , g τ1b * 2 +τ2b * 5 2 , g τ1b * 3 +τ2b * 6 2 , then this is a semi-functional key, whose exponent vector includes id ′ κ1 τ 2 b * 4τ 2 b * 5 (6) as its component in the span of b * 4 , b * 5 , b * 6 . To respond to the remaining key queries, B κ1,κ2 simply runs the normal key generation algorithm. At some point, A sends B κ1,κ2 two pairs (id * (0) , t * (0) , m * (0) ) and (id * (1) , t * (1) , m * (1) ). B 0 chooses a random bit β ∈ {0, 1} and encrypts m * (β) under (id * (β) , t * (β) ) as follows:</p><formula xml:id="formula_90">C := m * (β) • e(U 1 , g b * 1 2 ) α = m * (β) • (g α T ) z , C 0 := U 1 (U 2 ) id * (β) (U 3 ) t * (β) ,</formula><p>where B κ1,κ2 has implicitly set z := µ 1 . The "semi-functional part" of the exponent vector here is:</p><formula xml:id="formula_91">µ 2 b 4 + id * (β) µ 2 b 5 + t * (β) µ 2 b 6 .<label>(7)</label></formula><p>We observe that if id * (β) = id ′ κ1 (which is impossible), then vectors 6 and 7 would be orthogonal, resulting in a nominally semi-functional ciphertext and key pair (B κ1,κ2 can also use T 1 , T</p><p>2 , T 3 to generate private key part for t * (β) ) of Type I. It gives the ciphertext (C, C 0 ) to A. We now argue that since id * (β) = id ′ κ1 , in A's view the vectors 6 and 7 are distributed as random vectors in the spans of d * 4 , d * 5 , d * 6 and d 4 , d 5 , d 6 respectively. To see this, we take the coefficients of vectors 6 and 7 in terms of the bases b * 4 , b * 5 , b * 6 and b 4 , b 5 , b 6 respectively and translate them into coefficients in terms of the bases d * 4 , d * 5 , d * 6 and d 4 , d 5 , d 6 . Using the change of basis matrix A, we obtain the new coefficients (in vector form) as:</p><formula xml:id="formula_92">τ 2 A ⊤ (id ′ κ1 , -1, 0) ⊤ , µ 2 A -1 (1, id * (β) , t * (β) ) ⊤ .</formula><p>Since the distribution of everything given to A except for the κ 2 -th component of the κ 1 -th private key K id ′ κ 1 ,θ and the challenge ciphertext (C, C 0 ) is independent of the random matrix A and id * (β) = id ′ κ1 , we can conclude that these coefficients are uniformly except with probability 4/q (namely, the cases µ 2 or τ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) or (ν θ,4,1 , ν θ,5,1 , ν θ,6,1 ) defined in Equations 3 and 1 is the zero vector) from Lemma 2. Thus, B κ1,κ2 has properly simulated Game κ1,κ2 in this case.</p><formula xml:id="formula_93">If T 1 , T 2 , T 3 are equal to g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2</formula><p>, then the coefficients of the vector 7 are uniformly except with probability 2/q (namely, the cases µ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) defined in Equations 3 is the zero vector) from Lemma 2. Thus, B κ1,κ2 has properly simulated Game κ1,κ2-1 in this case.</p><p>In summary, B κ1,κ2 has properly simulated either Game κ1,κ2-1 or Game κ1,κ2 for A, depending on the distribution of T 1 , T 2 , T 3 . It can therefore leverage A's advantage ǫ between these games to obtain an advantage ǫ + 6 q against the Subspace assumption in G 2 , namely Adv DS2 Bκ (λ) = ǫ + 6 q .</p><p>B κ1,κ2 is given</p><formula xml:id="formula_94">D := (G; g b1 1 , g b2 1 , g b3 1 , g b * 1 2 , . . . , g b * 6 2 , U 1 , U 2 , U 3 , µ 2 )</formula><p>along with T 1 , T 2 , T 3 . We require that B κ1,κ2 decides whether T 1 , T</p><p>2 , T 3 are distributed as g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2 or g τ1b * 1 +τ2b * 4 2 , g τ1b * 2 +τ2b * 5 2 , g τ1b * 3 +τ2b * 6 2</p><p>.</p><p>B κ1,κ2 simulates Game κ1,κ2 or Game κ1,κ2-1 with A, depending on the distribution of T 1 , T 2 , T 3 . To compute the public parameters and master key, B κ1,κ2 chooses a random matrix A ∈ Z 3×3 q (with all but negligible probability, A is invertible). We then implicitly set dual orthonormal bases D, D * to:</p><formula xml:id="formula_95">d 1 := b 1 , d 2 := b 2 , d 3 := b 3 , (d 4 , d 5 , d 6 ) := (b 4 , b 5 , b 6 )A, d * 1 := b * 1 , d * 2 := b * 2 , d * 3 := b * 3 , (d * 4 , d * 5 , d * 6 ) := (b * 4 , b * 5 , b * 6 )(A -1 ) ⊤ .</formula><p>We note that D, D * are properly distributed, and reveal no information about A. B κ1,κ2 chooses random value α ∈ Z q and compute g α T := e(g 1 , g 2 ) αd1•d * 1 . B can give A the public parameters</p><formula xml:id="formula_96">PP := {G; g α T , g d1 1 , g d2 1 , g d3 1 }.</formula><p>The master key</p><formula xml:id="formula_97">MK := {α, g d * 1 2 , g d * 2 2 , g d * 3 2 }</formula><p>is known to B κ1,κ2 , which allows B κ1,κ2 to respond to all of A's private key and key update queries by calling the normal key generation algorithm. Since B κ1,κ2 also knows g</p><formula xml:id="formula_98">d * 4 2 , g d *<label>5</label></formula><p>2 , and g</p><formula xml:id="formula_99">d *<label>6</label></formula><p>2 , it can easily produce semi-functional keys. To answer the key queries that A makes, B κ1,κ2 runs the semi-functional private key and key update generation algorithm to produce semi-functional keys and gives these to A. To answer the κ 2 -th component of the (κ 1 -q n1 )-th key update for t ′ κ1-qn 1 , B κ1,κ2 responds with:</p><formula xml:id="formula_100">K t ′ κ 1 -qn 1 ,θ := (g b * 1 2 ) α θ,2 T t ′ κ 1 -qn 1 1 (T 3 ) -1 .</formula><p>This implicitly sets r θ,2 := τ 1 . If T 1 , T</p><p>2 , T 3 are equal to g τ1b * 1 2 , g τ1b * 2 2 , g τ1b * 3 2 , then this is a properly distributed normal key update. Otherwise, if T 1 , T 2 , T 3 are equal to g τ1b * 1 +τ2b * 4 2 , g τ1b * 2 +τ2b * 5 2 , g τ1b * 3 +τ2b * 6 2 , then this is a semi-functional key update, whose exponent vector includes t ′ κ1-qn 1 τ 2 b * 4τ 2 b * 6 (8) as its component in the span of b * 4 , b * 5 , b * 6 . To respond to the remaining key queries, B κ1,κ2 simply runs the normal key generation algorithm. At some point, A sends B κ1,κ2 two pairs (id * (0) , t * (0) , m * (0) ) and (id * (1) , t * (1) , m * (1) ). B 0 chooses a random bit β ∈ {0, 1} and encrypts m (β) under (id * (β) , t * (β) ) as follows:</p><formula xml:id="formula_101">C := m * (β) • e(U 1 , g b * 1 2 ) α = m * (β) • (g α T ) z , C 0 := U 1 (U 2 ) id * (β) (U 3 ) t * (β) ,</formula><p>where B κ1,κ2 has implicitly set z := µ 1 . The "semi-functional part" of the exponent vector here is:</p><formula xml:id="formula_102">µ 2 b 4 + id * (β) µ 2 b 5 + t * (β) µ 2 b 6 .<label>(9)</label></formula><p>We observe that if t * (β) = t ′ κ1-qn 1 (which is impossible), then vectors 8 and 9 would be orthogonal, resulting in a nominally semi-functional ciphertext and key pair (B κ1,κ2 can also use T 1 , T</p><p>2 , T 3 to generate private key part for id * (β) ) of Type I. It gives the ciphertext (C, C 0 ) to A. We now argue that since t * (β) = t ′ κ1-qn 1 , in A's view the vectors 8 and 9 are distributed as random vectors in the spans of d * 4 , d * 5 , d * 6 and d 4 , d 5 , d 6 respectively. To see this, we take the coefficients of vectors 8 and 9 in is known to B qn 1 +qn 2 +1,κ2 , which allows B qn 1 +qn 2 +1,κ2 to respond to all of A's private key and key update queries by calling the normal key generation algorithm. Since B qn 1 +qn 2 +1,κ2 also knows g d * 4 2 , g d * 5 2 , and g d * 6</p><p>2 , it can easily produce semi-functional keys. To answer the key queries that A makes, B qn 1 +qn 2 +1,κ2 runs the semi-functional private key and key update generation algorithm to produce semi-functional keys and gives these to A.</p><p>However, B qn 1 +qn 2 +1,κ2 changes the strategy to respond all the components for the κ 2 -th node in the binary tree of private keys and key updates. All key queries for Γ 1 and Γ 2 are similar with the following process except that B qn 1 +qn 2 +1,κ2 uses g</p><p>d * 1 2 , . . . , g d * 6</p><p>2 to re-randomize the exponents. To answer the component for the challenge identities id * (0) , id * (1) and times t * (0) , t * (1) (namely, the φ 1 , φ 2 -th private key and φ 3 , φ 4 -th key update queries) on the κ 2 -th node, B qn 1 +qn 2 +1,κ2 picks α ′ θ,1 , α ′′ θ,1 ∈ Z q and responds with:</p><formula xml:id="formula_103">K id * (0) ,θ := g α ′ θ,1 b * 1 2 (T b * 1 1 ) α ′′ θ,1 T r ′ θ,1 id * (0) 1 (T 2 ) -r ′ θ,1 , K t * (0) ,θ := g (α-α ′ θ,1 ) 2 (T b * 1 1 ) -α ′′ θ,1 T r ′ θ,2 t * (0) 1 (T 2 ) -r ′ θ,2 , K id * (1) ,θ := g α ′ θ,1 b * 1 2 (T b * 1 1 ) α ′′ θ,1 T r ′′ θ,1 id * (1)</formula><p>1 (T 2 ) -r ′′ θ,1 ,</p><formula xml:id="formula_104">K t * (1) ,θ := g (α-α ′ θ,1 ) 2 (T b * 1 1 ) -α ′′ θ,1 T r ′′ θ,2 t * (1) 1 (T 2 ) -r ′′ θ,2 ,</formula><p>where B qn 1 +qn 2 +1,κ2 implicitly sets α θ,1 := α ′ θ,1 +α ′′ θ,1 τ 1 and α θ,2 := α-α ′ θ,1 -α ′′ θ,1 τ 1 (note that α θ,1 +α θ,2 = α). Note that from the restriction of queries for the challenge identities and times, only part of the keys are given to A.</p><p>If T 1 , T 2 , T 3 are equal to g </p><p>(-α ′′ θ,1 τ 2 + t * (0) τ 2 r ′ θ,2 )b * 4τ 2 r ′ θ,2 b * 6 , (11) (α ′′ θ,1 τ 2 + id * (1) τ 2 r ′′ θ,1 )b * 4τ 2 r ′′ θ,1 b * 5 , (12) (-α ′′ θ,1 τ 2 + t * (1) τ 2 r ′′ θ,2 )b * 4τ 2 r ′′ θ,2 b * 6 , (13) as its component in the span of b * 4 , b * 5 , b * 6 respectively. To respond to the remaining key queries, B qn 1 +qn 2 +1,κ2 simply runs the normal key generation algorithm. At some point, A sends B qn 1 +qn 2 +1,κ2 two challenge pairs (id * (0) , t * (0) , m * (0) ) and (id * (1) , t * (1) , m * (1) ). B qn 1 +qn 2 +1,κ2 chooses a random bit β ∈ {0, 1} and encrypts m * (β) under (id * (β) , t * (β) ) as follows:</p><formula xml:id="formula_106">C := m * (β) • e(U 1 , g b *<label>1</label></formula><p>2 )</p><formula xml:id="formula_107">α = m * (β) • (g α T ) z , C 0 := U 1 (U 2 ) id * (β) (U 3 ) t * (β) ,</formula><p>where B qn 1 +qn 2 +1,κ2 has implicitly set z := µ 1 . The "semi-functional part" of the exponent vector here is:</p><formula xml:id="formula_108">µ 2 b 4 + id * (β) µ 2 b 5 + t * (β) µ 2 b 6 .<label>(14)</label></formula><p>We observe that ((C, C 0 ), K id * (β) ,θ , K t * (β) ,θ ) would result in a nominally semi-functional ciphertext and key pair of Type II. It gives the ciphertext (C, C 0 ) to A. whose running times are essentially the same as that of A, such that Adv RIBE A (λ) ≤ (q n1 q n2 ) 2 • Adv DLIN B0 (λ) +</p><p>qn 1 κ1=1 ⌈log Nmax⌉ κ2=1 Adv DLIN Bκ 1 ,κ 2 (λ) + qn 2 κ1=qn 1 +1 Nmax κ2=1 Adv DLIN Bκ 1 ,κ 2 (λ) + 4Nmax κ2=1</p><p>Adv DLIN Bq n 1 +qn 2 +1,κ 2 (λ) + 6(q n1 ⌈log N max ⌉ + q n2 N max ) + 32N max + 6 q where q n1 , q n2 ≥ 4 are the maximum number of A's private key and key update queries respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSIONS</head><p>In this paper, we presented two efficient RIBE schemes under the SXDH and the DLIN assumptions, respectively, which overcome the existing problem of increasing sizes of public parameters. In comparison with the existing schemes of <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b20">21]</ref>, our RIBE schemes are adaptively secure, anonymous and have constant-size public parameters, although they have larger sizes of keys and ciphertexts. Our RIBE schemes can be extended very naturally to obtain revocable IPE schemes with weakly attribute-hiding <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b25">26]</ref>. Also our techniques can be applied to a more generally setting, for example, the ABE schemes of <ref type="bibr" target="#b25">[26]</ref> to obtain adaptively secure revocable ABE schemes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 )</head><label>2</label><figDesc>Sample random dual orthonormal bases, (D, D * ) ← R Dual(Z 6 q ). Let d 1 , . . . , d 6 denote the elements of D and d * 1 , . . . , d * 6 denote the elements of D * . It also picks α ← R Z q and computes g α T</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>d 1 :</head><label>1</label><figDesc>= b 1 , d 2 := b 2 , d 3 := b 3 , (d 4 , d 5 , d 6 ) := (b 4 , b 5 , b 6 )A, d * 1 := b * 1 , d * 2 := b * 2 , d * 3 := b * 3 , (d * 4 , d * 5 , d * 6 ) := (b * 4 , b * 5 , b * 6 )(A -1 ) ⊤ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>6 and d 4 ,</head><label>64</label><figDesc>t * (β) ) of Type I. It gives the ciphertext (C, C 0 ) to A. We now argue that since id * (β) = id ′ κ1 , in A's view the vectors 4 and 5 are distributed as random vectors in the spans of d * 4 , d * 5 , d * 6 and d 4 , d 5 , d 6 respectively. To see this, we take the coefficients of vectors 4 and 5 in terms of the bases b * 4 , b * 5 , b * 6 and b 4 , b 5 , b 6 respectively and translate them into coefficients in terms of the bases d * 4 , d * 5 , d * d 5 , d 6 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>2 , 2 ,</head><label>22</label><figDesc>then these are properly distributed normal keys. If T 1 , T 2 , T 3 are equal to g then these are semi-functional keys, whose exponent vector includes(α ′′ θ,1 τ 2 + id * (0) τ 2 r ′ θ,1 )b * 4τ 2 r ′ θ,1 b * 5 ,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>F</head><figDesc>* := (f * 1 , . . . , f * 6 ) as follows: any adversary A against the RIBE scheme, there exist probabilistic algorithms B 0 , {B κ1,κ2 } κ1=1,...,qn 1 ,κ2=1,...,⌈log Nmax⌉ , {B κ1,κ2 } κ1=qn 1 +1,...,qn 1 +qn 2 +1,κ2=1,...,Nmax , {B qn 1 +qn 2 +1,κ2 } κ2=1,...,4Nmax</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Using the change of basis matrix A, we obtain the new coefficients (in vector form) as:</p><p>Since the distribution of everything given to A except for the κ 2 -th component of the (κ 1q n1 )-th key update</p><p>,θ and the challenge ciphertext (C, C 0 ) is independent of the random matrix A and t * (β) = t ′ κ1-qn 1 , we can conclude that these coefficients are uniformly except with probability 4/q (namely, the cases µ 2 or τ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) or (ν θ,4,2 , ν θ,5,2 , ν θ,6,2 ) defined in Equations 3 and 2 is the zero vector) from Lemma 2. Thus, B κ1,κ2 has properly simulated Game κ1,κ2 in this case.</p><p>If T 1 , T 2 , T 3 are equal to g</p><p>, then the coefficients of the vector 9 are uniformly except with probability 2/q (namely, the cases µ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) defined in Equations 3 is the zero vector) from Lemma 2. Thus, B κ1,κ2 has properly simulated Game κ1,κ2-1 in this case.</p><p>In summary, B κ1,κ2 has properly simulated either Game κ1,κ2-1 or Game κ1,κ2 for A, depending on the distribution of T 1 , T 2 , T 3 . It can therefore leverage A's advantage ǫ between these games to obtain an advantage ǫ + 6 q against the Subspace assumption in G 2 , namely Adv DS2 Bκ (λ) = ǫ + 6 q .</p><p>Lemma 8. For κ 2 from 0 to 4N max , suppose that there exists an adversary A where |Adv</p><p>Then there exists an algorithm B qn 1 +qn 2 +1,κ2 such that Adv DS2 Bq n 1 +qn 2 +1,κ 2 (λ) = ǫ+ 8 q , with K = 3 and N = 6.</p><p>Proof: B qn 1 +qn 2 +1,κ2 is given</p><p>along with T 1 , T 2 , T 3 . We require that B qn 1 +qn 2 +1,κ2 decides whether T 1 , T 2 , T 3 are distributed as g</p><p>B qn 1 +qn 2 +1,κ2 simulates Game qn 1 +qn 2 +1,κ2 or Game qn 1 +qn 2 +1,κ2-1 with A, depending on the distribution of T 1 , T 2 , T 3 . To compute the public parameters and master key, B qn 1 +qn 2 +1,κ2 chooses a random matrix A ∈ Z 3×3 q (with all but negligible probability, A is invertible). We then implicitly set dual orthonormal bases D, D * to:</p><p>We note that D, D * are properly distributed, and reveal no information about A. B qn 1 +qn 2 +1,κ2 chooses random value α ∈ Z q and compute g α T := e(g 1 , g 2 ) αd1•d * 1 . B can gives A the public parameters</p><p>The master key</p><p>Since the adversary A is only allowed to query one of the following sets for the challenge identities and times:</p><p>∅, {id </p><p>Since the distribution of everything given to A except for the coefficients of the vectors in above Table is independent of the random matrix A, we can conclude that these coefficients are uniformly except with probability</p><p>• 2/q, namely except for the cases:</p><p>µ 2 defined in Subspace problem is zero, -(χ 4 , χ 5 , χ 6 ) defined in Equation 3 the zero vector, from Lemma 2 for Case 1.</p><p>• 4/q, namely except for the cases:</p><p>µ 2 or τ 2 defined in Subspace problem is zero, -(χ 4 , χ 5 , χ 6 ) or (ν θ,4,1 , ν θ,5,1 , ν θ,6,1 ) or (ν θ,4,2 , ν θ,5,2 , ν θ,6,2 ) defined in Equations 3, 1 and 2 is the zero vector, from Lemma 3 for Cases 2-5, since α ′′ θ,1 is randomly picked from Z q . • 6/q, namely except for the cases:</p><p>µ 2 or τ 2 defined in Subspace problem is zero, -(χ 4 , χ 5 , χ 6 ) or (ν θ,4,1 , ν θ,5,1 , ν θ,6,1 ) or (ν θ,4,2 , ν θ,5,2 , ν θ,6,2 ) defined in Equations 3, 1 and 2 is the zero vector,</p><p>) and (ν θ,4,2 , ν θ,5,2 , ν θ,6,2 ) defined in Equations 1 and 2 are linearly dependent, from Lemma 2 for Cases 6-9, since α ′′ θ,1 is randomly picked from Z q and the coefficients of vectors 10, 11, 12, 13 are linearly independent.</p><p>Thus, B qn 1 +qn 2 +1,κ2 has properly simulated Game qn 1 +qn 2 +1,κ2 in this case.</p><p>, then the coefficients of the vector 14 are uniformly except with probability 2/q (namely, the cases µ 2 defined in Subspace problem is zero, (χ 4 , χ 5 , χ 6 ) defined in Equations 3 is the zero vector) from Lemma 2. Thus, B qn 1 +qn 2 +1,κ2 has properly simulated Game qn 1 +qn 2 +1,κ2-1 in this case.</p><p>In summary, B qn 1 +qn 2 +1,κ2 has properly simulated either Game qn 1 +qn 2 +1,κ2-1 or Game qn 1 +qn 2 +1,κ2 for A, depending on the distribution of T 1 , T 2 , T 3 . It can therefore leverage A's advantage ǫ between these games to obtain an advantage ǫ + 8 q against the Subspace assumption in G 2 , namely Adv DS2 Bq n 1 +qn 2 +1,κ 2 (λ) = ǫ + 8 q .</p><p>Lemma 9. For any adversary A, Adv</p><p>Proof: To prove this lemma, we show the joint distributions of</p><p>, {SK</p><p>in Game ν and that of</p><p>in Game F inal are equivalent for the adversary's view, where</p><p>is a semi-functional encryption of a random message in G T and under a random identity id (R) in Z q and a random time t (R) in Z q .</p><p>For this purpose, we pick A := (ξ i,j ) ← R Z 3×3 q and define new dual orthonormal bases F := (f 1 , . . . , f 6 ), and</p><p>It is easy to verify that F and F * are also dual orthonormal, and are distributed the same as D and D * .</p><p>Then the public parameters, challenge ciphertext, queried private keys and key updates in Game qn 1 +qn 2 +1,4Nmax are expressed over bases D and D * as .</p><p>Then we can express them over bases F and F * as</p><p>.</p><p>where</p><p>which are all uniformly distributed if (χ 4 , χ 5 , χ 6 ) defined in Equation <ref type="formula">3</ref>is a non-zero vector since</p><p>are all uniformly picked from Z q .</p><p>In other words, the coefficients (z, zid *</p><p>, thus the challenge ciphertext can be viewed as a semi-functional encryption of a random message in G T and under a random identity in Z q and a random time in Z q . Moreover, it is not difficult to check that all other coefficients are well distributed. Thus</p><p>, {SK</p><p>expressed over bases F and F * is properly distributed as</p><p>in Game F inal .</p><p>In the adversary's view, both (D, D * ) and (F, F * ) are consistent with the same public key. Therefore, the challenge ciphertext and queried secret keys above can be expressed as keys and ciphertext in two ways, in Game ν over bases (D, D * ) and in Game F inal over bases (F, F * ). Thus, Game qn 1 +qn 1 +1,4Nmax and Game F inal are statistically indistinguishable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 10. For any adversary A, Adv Game</head><p>Proof: The value of β is independent from the adversary's view in Game F inal . Hence, Adv Game F inal A (λ) = 0.</p><p>In Game F inal , the challenge ciphertext is a semi-functional encryption of a random message in G T and under a random identity in Z q and a random time in Z q , independent of the two messages, the challenge identities, and times provided by A. Thus, our RIBE scheme is adaptively secure and anonymous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONSTRUCTION FROM DLIN</head><p>We use the same binary tree structure mentioned in previous section in our second construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Our Scheme</head><p>Here we provide our second construction of RIBE under the DLIN assumption. Our RIBE scheme is specified as follows:</p><p>• Setup(λ, N max ) On input a security parameter λ, a maximal number N max of users and generate a symmetric bilinear pairing G := (q, G, G T , g, e) for sufficiently large prime order q. Next perform the following steps:</p><p>1) Let RL be an empty set and BT be a binary-tree with at least N max leaf nodes, set ST = BT. 3) Output RL, ST, the public parameters PP := G; g α T , g d1 , . . . , g d6 , and the master key MK MK := α, g d * 1 , . . . , g d *</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6</head><p>.</p><p>• PriKeyGen(PP, MK, id, RL, ST) On input the public parameters PP, the master key MK, an identity id, the revocation list RL, and the state ST, it picks an unassigned leaf node v from BT and stores id in that node.</p><p>It then performs the following steps:</p><p>and store them in node θ. Pick r θ,1 , r θ,3 ← R Z q and compute</p><p>2) Output SK id := {(θ, K id,θ )} θ∈Path(v) , ST.</p><p>• KeyUpd(PP, MK, t, RL, ST) On input the public parameters PP, the master key MK, a time t, the revocation list RL, and the state ST, it performs the following steps:</p><p>1) ∀θ ∈ KUNodes(BT, RL, t), if α θ,1 , α θ,2 , α θ,3 are undefined, then pick α θ,1 , α θ,3 ← R Z q , set α θ,2 = αα θ,1 , and store them in node θ. Pick r θ,2 , r θ,4 ← R Z q and compute</p><p>2) Output KU t := {(t, θ, K t,θ )} θ∈KUNodes(BT,RL,t) .</p><p>• DecKeyGen(SK id , KU t ) On input a private secret key SK id := {(i, K id,i )} i∈I , KU t := {(j, K t,j )} j∈J for some set of nodes I, J, it runs the following steps:</p><p>1) ∀(i, K id,i ) ∈ SK id , (j, K t,j ) ∈ KU t , if ∃(i, j) s.t. i = j then DK id,t ← (K id,i , K t,j ); else (if SK id and KU t do not have any node in common) DK id,t ← ⊥.</p><p>2) Output DK id,t .</p><p>• Enc(PP, id, t, m) On input the public parameters PP, an identity id, a time t ∈ Z n q , and a message m, it picks z 1 , z 2 ← R Z q and forms the ciphertext as CT id,t := C := m • (g α T ) z1 , C 0 := g z1(d1+idd2+td3)+z2(d4+idd5+td6) .</p><p>• Dec(PP, DK id,t , CT id,t ) On input the public parameters PP, a decryption key DK id,t := (K id,θ , K t,θ ), and a ciphertext CT id,t := (C, C 0 ), it computes the message as m := C/ (e(C 0 , K id,θ ) • e(C 0 , K t,θ )) .</p><p>• KeyRev(id, t, RL, ST) On input an identity id, a time t, the revocation list RL, and the state ST, the algorithm adds (id, t) to RL for all nodes ν associated with identity id and returns RL.</p><p>Correctness. Observe that e(C 0 , K id,θ ) = e(g z1(d1+idd2+td3)+z2(d4+idd5+td6) , g (α θ,1 +r θ,1 id)d * Similarly, e(C 0 , K t,θ ) = e(g, g) α θ,2 z1d1•d * </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Proof of Security</head><p>We show the RIBE scheme is secure by the following theorem, the proof techniques are essentially the same as those for Theorem 1 except that we use the DLIN-based Subspace assumption of <ref type="bibr" target="#b15">[16]</ref>.</p><p>Theorem 2. The RIBE scheme is adaptively secure and anonymous under the DLIN assumption. More precisely,</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Efficient lattice (h)ibe in the standard model</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="553" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Lattice basis delegation in fixed dimension and shorter-ciphertext hierarchical ibe</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="98" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast digital identity revocation (extended abstract)</title>
		<author>
			<persName><forename type="first">W</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lodha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="137" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Ciphertext-policy attribute-based encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bethencourt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="321" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Identity-based encryption with efficient revocation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="417" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the weil pairing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="213" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Hierarchical identity based encryption with constant size ciphertext</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="440" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Space-efficient identity based encryption without pairings</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="647" to="657" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Functional encryption: Definitions and challenges</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="253" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Bonsai trees, or how to delegate a lattice basis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="523" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Shorter ibe and signatures via asymmetric pairings</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pairing</title>
		<imprint>
			<date type="published" when="2012">2012. 2012/224</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
	<note>To appear, also Cryptology ePrint Archive</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An identity based encryption scheme based on quadratic residues</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IMA Int. Conf</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="360" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Trapdoors for hard lattices and new cryptographic constructions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="197" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Attribute-based encryption for fine-grained access control of encrypted data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="89" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Identity-based hierarchical strongly key-insulated encryption and its application</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hanaoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hanaoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shikata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Imai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="495" to="514" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Tools for simulating features of composite order bilinear groups in the prime order setting</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="318" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">New techniques for dual system encryption and fully secure hibe with short ciphertexts</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="455" to="479" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="62" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient revocation and threshold pairing based cryptosystems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Quisquater</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="163" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Towards black-box accountable authority ibe with short ciphertexts and private keys</title>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vergnaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="235" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Adaptive-id secure revocable identity-based encryption</title>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vergnaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Certificate revocation and certificate update</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="561" to="570" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Homomorphic encryption and signatures from vector decomposition</title>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pairing</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="57" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Hierarchical predicate encryption for inner-products</title>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="214" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Fully secure functional encryption with general relations from the decisional linear assumption</title>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="191" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fully secure functional encryption with general relations from the decisional linear assumption</title>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">563</biblScope>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Attribute-based encryption with non-monotonic access structures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="195" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Fuzzy identity-based encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="457" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Identity-based cryptosystems and signature schemes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="47" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Efficient identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="114" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Dual system encryption: Realizing fully secure ibe and hibe under simple assumptions</title>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="619" to="636" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
