<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Quantum Identity-Based Encryption from the Learning with Errors Problem</title>
				<funder ref="#_4EAjzWT #_zCdA3XU">
					<orgName type="full">National Natural Science Foundation of China</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Wenhua</forename><surname>Gao</surname></persName>
							<email>gaowenhua@iie.ac.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Information Engineering</orgName>
								<orgName type="laboratory">State Key Laboratory of Information Security</orgName>
								<orgName type="institution">CAS</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">School of Cyber Security</orgName>
								<orgName type="institution">University of Chinese Academy of Sciences</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Institute of Information Engineering</orgName>
								<orgName type="institution">Chinese Academy of Sciences</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Li</forename><surname>Yang</surname></persName>
							<email>yangli@iie.ac.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Information Engineering</orgName>
								<orgName type="laboratory">State Key Laboratory of Information Security</orgName>
								<orgName type="institution">CAS</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">School of Cyber Security</orgName>
								<orgName type="institution">University of Chinese Academy of Sciences</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Institute of Information Engineering</orgName>
								<orgName type="institution">Chinese Academy of Sciences</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daode</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Xia</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Information Engineering</orgName>
								<orgName type="laboratory">State Key Laboratory of Information Security</orgName>
								<orgName type="institution">CAS</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">School of Cyber Security</orgName>
								<orgName type="institution">University of Chinese Academy of Sciences</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Institute of Information Engineering</orgName>
								<orgName type="institution">Chinese Academy of Sciences</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Quantum Identity-Based Encryption from the Learning with Errors Problem</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8E580B035CF29AA12AB786C5C8AEB331</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2" ident="GROBID" when="2025-11-07T10:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<label type="revision">a91ee48</label>
					<label type="parameters">startPage=-1, endPage=-1, consolidateCitations=0, consolidateHeader=0, consolidateFunders=0, includeRawAffiliations=false, includeRawCitations=false, includeRawCopyrights=false, generateTeiIds=false, generateTeiCoordinates=[], sentenceSegmentation=false, flavor=null</label>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In order to prevent eavesdropping and tampering, the network security protocols use a handshake with an asymmetric cipher to establish a session-specific shared key with which further communication is encrypted using a symmetric cipher. The commonly used asymmetric algorithms include public key encryption, key exchange and identity-based encryption (IBE). However, the network security protocols based on classic identity-based encryption do not have perfect forward security. To solve the problem, we construct the first quantum IBE (QIBE) scheme based on the learning with errors problem, and prove that our scheme is fully secure under the random oracle. Moreover, we construct the quantum circuit of our QIBE scheme and give an estimate of the quantum resource of our circuit including the numbers of Hadamard gate, phase gate, T gate, CNOT gate and the total qubits used in the circuit, and conclude that the quantum resources required by our scheme increase linearly with the number of bits of the encrypted quantum plaintext. Our scheme exhibits the following advantages:</p><p>â€¢ The classic key generation center (KGC) system still can be used for our QIBE scheme to generate and distribute the secret identity keys so that the cost can be reduced when the scheme is implemented. The reason why the classic KGC can be used is that the public and private keys are in the form of classic bits.</p><p>â€¢ The network security protocols using a handshake with our QIBE scheme can provide perfect forward security. In our scheme, the ciphertext is transmitted in the form of a quantum state that is unknown to the adversary and therefore cannot be copied and stored. Thus, in the network security protocols based on our QIBE construction, the adversary cannot decrypt the previous quantum ciphertext to threat the previous session keys even if the identity secret key is threatened.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Identity-based cryptosystem is a public key cryptosystem first proposed by Shamir in 1984 <ref type="bibr" target="#b22">[23]</ref>, whose public key is calculated directly from the receiver's identity ğ‘–ğ‘‘ ğ‘… such as phone number, email address, or network address, and the corresponding secret key ğ‘ ğ‘˜ ğ‘… is calculated by the trusted key generation center (KGC) who owns the master public key mpk and master secret key msk. When the sender wants to send message ğ‘š to the receiver, the sender encrypts the message to get the ciphertext ğ‘ = Encrypt(mpk, ğ‘–ğ‘‘ ğ‘… , ğ‘š; ğ‘Ÿ ), where ğ‘Ÿ ( ) Li Yang yangli@iie.ac.cn is a random number. On receiving the ciphertext ğ‘, the receiver can decrypt and get the message ğ‘š = Decrypt(ğ‘ ğ‘˜ ğ‘… , ğ‘). Compared with cryptographic systems based on public key infrastructure (PKI), identity-based cryptosystems avoid the high cost of storing and managing public key certificates, simplify the management process of public keys, and reduce the pressure on the system. Therefore, identity-based cryptosystems have been widely developed and applied.</p><p>The first practical identity-based encryption (IBE) scheme was proposed by Boneh et al. <ref type="bibr" target="#b5">[6]</ref> in 2001, which was followed by numerous other classic IBE schemes. These classic identity-based encryption (IBE) schemes can be mainly divided into three categoreies: IBE schemes based on elliptic curve bilinear mapping <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b25">26]</ref>, IBE schemes based on quadratic residue <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17]</ref>, and IBE schemes based on lattices <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b32">33]</ref>. With the development of quantum computers and quantum algorithms, especially the proposal of Shor algorithm <ref type="bibr" target="#b23">[24]</ref>, the security of IBE schemes based on elliptic curve bilinear pair and quadratic residue have been seriously threatened. Since there is no quantum algorithm that can solve lattice-based difficult problems, the design and research of lattice-based IBE schemes have become the research hotspot of cryptographers.  There are many applications of IBE such as constructing network security protocol (Chinese SSL VPN technology specification <ref type="bibr" target="#b8">[9]</ref>). In the security protocol based on IBE, the receiver will send their identity ğ‘–ğ‘‘ ğ‘… and mpk to the sender, and the sender chooses a ğ‘ ğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›ğ¾ğ‘’ğ‘¦ and sends its ciphertext to the receiver. Then the receiver decrypts the ciphertext to obtain the ğ‘ ğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›ğ¾ğ‘’ğ‘¦. After that, both of them can own this secret key ğ‘ ğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›ğ¾ğ‘’ğ‘¦ with which further communication is encrypted using a symmetric cipher. The above process is briefly described in Figure <ref type="figure" target="#fig_1">1</ref>. A security protocol is said to provide perfect forward secrecy <ref type="bibr" target="#b24">[25]</ref> if the compromise of long-term keys does not compromise past session keys that have arXiv:2109.15049v1 [cs.CR] 26 Sep 2021 been established before the compromise of the long-term key. In the security protocol based on classic IBE, all session keys and their ciphertexts are in the form of classic bits. A patient attacker can capture conversations to store the ciphertexts of session keys whose confidentiality is protected by the secret identity key (which is called the long-term key) and wait until the long-term key is threatened. Once the patient attacker gets the long-term key, they can decrypt the ciphertext of all previous session keys. In a word, all encrypted communications and sessions recorded in the past can be retrieved. Therefore, the security protocol based on classic IBE does not have perfect forward security. To solve this problem, considering that an adversary cannot replicate an unknown quantum state <ref type="bibr" target="#b26">[27]</ref>, we construct an quantum identity-based encryption (QIBE) scheme based on learning with errors problem. In our QIBE scheme, the ciphertext is transmitted in the form of a quantum state that is unknown to the adversary, and the ciphertext of session keys can not be copied. Then, in the security protocol based on our QIBE construction, even if the secret identity key is threatened, the adversary does not have the previous ciphertexts of session keys to decrypt so that they can not threat the security of the previous session keys. Therefore, the security protocol based on our QIBE construction has perfect forward security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contributions</head><p>In this work, we give the definition of identity-based quantum encryption and construct the first QIBE scheme based on the proposed classic identity-based encryption scheme <ref type="bibr" target="#b13">[14]</ref>, and proved that our scheme is fully secure under the random oracle.</p><p>In our scheme, the Setup and KeyGen algorithms are classic algorithms and then the public and private keys are classic bits. Thus the classic key generation center (KGC) system still can be used for our QIBE scheme to generate and distribute the secret identity keys so that the cost can be reduced when the scheme is implemented.</p><p>In our scheme, the ciphertext is transmitted in the form of a quantum state that is unknown to the adversary and cannot be copied and stored. Therefore, in the network security protocols using a handshake with our QIBE scheme, if the identity private key is threatened, the adversary cannot decrypt the previous quantum ciphertext state to threat the previous session keys. Therefore, the network security protocol based on our QIBE can have perfect forward security compared to the network security protocol based on the classic IBE.</p><p>we construct the quantum circuit of our QIBE scheme and give an estimate of the quantum resource of our circuit including the numbers of Hadamard gate, phase gate, T gate, CNOT gate and the total qubits used in the circuit, and conclude that the quantum resources required by our scheme increase linearly with the number of bits of the encrypted quantum plaintext.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Outline of the paper</head><p>The remainder of this paper is organised as follows: Section 2 describes the basic notation and previous work on quantum circuit, and basic knowledge and definitions of classic IBE and lattices. Section 3 gives the definition of QIBE, describes the concrete construction of our scheme, analyzes the correctness of our scheme and gives its security proof, and analyzes the forward security of the network protocol based on our scheme. Section 4 constructs the specific quantum circuit of our QIBE scheme, and estimates the quantum resources needed. Section 5 summarises our work and presents directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>The basic quantum gate involved in this study includes the singlequbit gate the NOT gate shown in Figure <ref type="figure">2</ref>.(ğ‘), double-qubit gates the CNOT gate shown in Figure <ref type="figure">2</ref>.(ğ‘) and a variant of it shown in 2.(ğ‘) which can be obtained by a CNOT gate and two NOT gates, and three-qubit gate the Toffoli gate shown in Figure <ref type="figure">2</ref>.(ğ‘‘).</p><formula xml:id="formula_0">| |( + 1) mod 2 ( )<label>= ( ) ( ) ( ) ( ) ( )</label></formula><formula xml:id="formula_1">| | |( + ) mod 2 | | | | | |( + ) mod 2 | | | |( + + 1) mod 2 | ( )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2: The Basic quantum gates</head><p>The notations involved in this study is shown in Figure <ref type="figure">3</ref>, where (ğ‘) means the input is multiple qubits and the black triangles in (ğ‘) represents the main output registers.</p><formula xml:id="formula_2">| |( + 1)<label>2</label></formula><formula xml:id="formula_3">( ) = ( ) ( ) ( ) ( ) ( ) | | |( + ) 2 | | | | | |( + ) 2 | | | |( + + 1) 2 | ( )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3: The involved notations</head><p>We use bold lowercase letters to denote vectors. On the basis of the above, the ğ‘™-controlled NOT gate and the combination of multi-CNOT gates involved in this study are shown in Figure <ref type="figure" target="#fig_8">4</ref>, where (ğ‘) is the ğ‘™-controlled NOT gate and its simplified form, which can be decomposed into 2ğ‘™ -3 Toffoli gates, and (ğ‘) is a combination of ğ‘™ CNOT gates and its simplified form. In addition, the simplified circuit of controlled copying the classical constant ğ‘‘ which can be decomposed into ğ‘™ bit binary string t âˆˆ {0, 1} ğ‘™ is shown in Figure <ref type="figure" target="#fig_2">5</ref>. This circuit is implemented by performing CNOT operation or not according the value of each bit of t is one or zero. If ğ‘¡ ğ‘– = 1(ğ‘– = 1, ..., ğ‘™), take |ğ‘˜ 1 âŸ© as control bit and the ğ‘–-th bit of |0âŸ© as target bit to perform CNOT operation; If ğ‘¡ ğ‘– = 0, do not any operation to the ğ‘–-th bit of |0âŸ©. Finally, the output will produce (|ğ‘˜ 1 âŸ©, |ğ‘‘ * ğ‘˜ 1 âŸ©). In general, zero and one in t are approximately uniform, so this circuit requires approximately ğ‘™/2 CNOT gates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Quantum Circuit</head><p>The transformation of quantum states is realized by a series of unitary operations, which can be decomposed into many elementary gate operations. Therefore, the realization of quantum circuits is also accomplished by a series of gate operations. In this section, we describe the proposed quantum arithmatic operations including addition and subtraction, controlled addition, modular addition and comparison, and their corresponding quantum resources required including the numbers of CNOT gate, the Toffoli gate and the total qubit. All these works lay the foundation for the quantum circuit realization of our QIBE. To simplify the description, we show the simplified form of these arithmatic operations here and their specific implementation process can be seen in corresponding reference.</p><p>â€¢ Addition and subtraction : Cuccaro et al. proposed a quantum addition circuit <ref type="bibr" target="#b10">[11]</ref>. The quantum addition achieves the addition of two registers, that is</p><formula xml:id="formula_4">|ğ‘, ğ‘âŸ© â†’ |ğ‘, ğ‘ + ğ‘âŸ©.</formula><p>To prevent overflows caused by carry, the second register (initially loaded in state |ğ‘âŸ©) should be sufficiently large, i.e. if both ğ‘ and ğ‘ are encoded on ğ‘™ qubits, the second register should be of size ğ‘™ + 1. In the addition network, the last carry is the most significant bit of the result and is written in the ğ‘™ + 1-th qubit of the second register. Because of the reversibility of unitary operations, by reversing the network of addition, i.e., apply each gate of the network in the reversed order, the subtraction network will be obtained. The simplified form of the addition and subtraction network are shown in (ğ‘) and (ğ‘) of Figure <ref type="figure" target="#fig_3">6</ref>. In this paper, a network with a bar on the left side represents the reversed sequence of elementary gates embedded in the same network with the bar on the right side. On the subtraction network, with the input (|ğ‘âŸ©, |ğ‘âŸ©), the output will produce (|ğ‘âŸ©, |ğ‘ -ğ‘âŸ©) when ğ‘ â‰¥ ğ‘. When ğ‘ &lt; ğ‘, the output is When ğ‘ &lt; ğ‘, the significant qubit, the ğ‘™ + 1-th qubit of the second register, which indicates whether or not an overflow occurred in the subtraction, will always contains 1. To calculate the addition or subtraction of two ğ‘™-bit length inputs, a total of 2ğ‘™ Toffoli gates, 4ğ‘™ + 1 CNOT gates, and a total of 2ğ‘™ + 2-qubit are required for the addition or subtraction network.</p><formula xml:id="formula_5">(|2 ğ‘™ -(ğ‘ -ğ‘)âŸ©),</formula><p>â€¢ Addition module ğ‘ : Liu et al. <ref type="bibr" target="#b33">[34]</ref> improved Roetteler's <ref type="bibr" target="#b21">[22]</ref> quantum modular addition circuit, reducing the number of quantum gates required. This quantum network effects |ğ‘, ğ‘âŸ© â†’ |ğ‘, (ğ‘ + ğ‘) mod ğ‘âŸ©, where 0 â‰¤ ğ‘, ğ‘ &lt; ğ‘. The simplified form of the addition module ğ‘ network are shown in (ğ‘) of Figure <ref type="figure" target="#fig_4">7</ref>. The modular subtraction can be obtained by reversing modular addition circuit and its bar is on the left hand. To calculate the addition or subtraction module ğ‘ of two âŒŠlog ğ‘ + 1âŒ‹-bit length inputs, a total of 8âŒŠlog ğ‘ + 1âŒ‹ Toffoli gates, 13âŒŠlog ğ‘ + 1âŒ‹ + 6 CNOT gates and 3âŒŠlog ğ‘ + 1âŒ‹ + 3-qubit are required for this addition or subtraction module ğ‘ network. â€¢ Comparison : Markov et al. construct a quantum comparison circuit by comparing |ğ‘âŸ© and |ğ‘âŸ© by whether the highest bit of |ğ‘ -ğ‘âŸ© is |0âŸ© or |1âŸ© [18]</p><p>. This circuit is obtained by modifying the the previous subtraction circuit so that it outputs only the highest bit of |ğ‘ -ğ‘âŸ©. The comparison network achieves the comparison of two registers, that is</p><formula xml:id="formula_6">|ğ‘, ğ‘âŸ©|0âŸ© â†’ |ğ‘, ğ‘âŸ©|0âŸ©, for ğ‘ â‰¥ ğ‘. |ğ‘, ğ‘âŸ©|0âŸ© â†’ |ğ‘, ğ‘âŸ©|1âŸ©, for ğ‘ &lt; ğ‘.</formula><p>The simplified form of the quantum comparison network is shown in Figure <ref type="figure" target="#fig_4">7</ref>.(ğ‘). To comparing two ğ‘™-bit length inputs |ğ‘âŸ© and |ğ‘âŸ©, a total of 2ğ‘™ Toffoli gates, 4ğ‘™ + 1 CNOT gates, and 2ğ‘™ + 2 qubits are required for the comparison network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Lattices</head><p>Let ğ‘‹ and ğ‘Œ be two random variables over some finite set ğ‘† ğ‘‹ , ğ‘† ğ‘Œ , respectively. The statistical distance Î”(ğ‘‹, ğ‘Œ ) between ğ‘‹ and ğ‘Œ is defined as</p><formula xml:id="formula_7">Î”(ğ‘‹, ğ‘Œ ) = 1 2 âˆ‘ï¸ ğ‘  âˆˆğ‘† ğ‘‹ âˆªğ‘† ğ‘Œ |Pr[ğ‘‹ = ğ‘ ] -Pr[ğ‘Œ = ğ‘ ] | .</formula><p>For integer ğ‘ â‰¥ 2, Z ğ‘ denotes the quotient ring of integer modulo ğ‘. We use bold capital letters to denote matrices, such as A, B, and bold lowercase letters to denote vectors, such as x, y. We denote the ğ‘—-th row of a matrix R by r ğ‘— and its ğ‘–-th column by r ğ‘– . Moreover, we denote the ğ‘—-th element of a vector m by ğ‘š ğ‘— . The notations A âŠ¤ denote the transpose of the matrix A. Specially, we use i to denote a vector that each element is one, i.e</p><formula xml:id="formula_8">, i = (1, â€¢ â€¢ â€¢ , 1) âŠ¤ .</formula><p>Let S be a set of vectors</p><formula xml:id="formula_9">S = {s 1 , â€¢ â€¢ â€¢ , s ğ‘› } in R ğ‘š . We use S = { s 1 , â€¢ â€¢ â€¢ , s ğ‘› } to denote the Gram-Schmidt orthogonalization of the vectors s 1 , â€¢ â€¢ â€¢ , s ğ‘› in</formula><p>that order, and âˆ¥Sâˆ¥ to denote the length of the longest vector in S. For positive integers ğ‘, ğ‘›, ğ‘š with ğ‘ prime, and a matrix A âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ , the ğ‘š-dimensional integer lattices are defined as:</p><formula xml:id="formula_10">Î› ğ‘ (A) = {y : y = A âŠ¤ s for some s âˆˆ Z ğ‘› } and Î› âŠ¥ ğ‘ (A) = {y : Ay = 0 mod ğ‘}. Moreover, for u âˆˆ Z ğ‘›</formula><p>ğ‘ , the set of syndromes is defined as (Î›) , where x âˆˆ Î›. For simplicity, ğœŒ ğ‘ ,0 and D Î›,ğ‘ ,0 are abbreviated as ğœŒ ğ‘  and D Î›,ğ‘  , respectively. Lemma 2.1. Let ğ‘, ğ‘›, ğ‘š be positive integers with ğ‘ â‰¥ 2 and ğ‘ prime. There exists PPT algorithms such that</p><formula xml:id="formula_11">Î› u ğ‘ (A) = {y : u = Ay mod ğ‘}. For x âˆˆ Î›, define the Gaussian function ğœŒ ğ‘ ,c (x) over Î› âŠ† Z ğ‘š cen- tered at c âˆˆ R ğ‘š with parameter ğ‘  &gt; 0 as ğœŒ ğ‘ ,c (x) = exp(-ğœ‹ ||x -c||/ğ‘  2 ). Let ğœŒ ğ‘ ,c (Î›) = xâˆˆÎ› ğœŒ ğ‘ ,c (x), and define the discrete Gaussian distri- bution over Î› as D Î›,ğ‘ ,c (x) = ğœŒ ğ‘ ,c (x) ğœŒ ğ‘ ,c</formula><p>â€¢ ([2, 3]): TrapGen(1 ğ‘› , 1 ğ‘š , ğ‘) a randomized algorithm that, when ğ‘š â‰¥ 6ğ‘›âŒˆlog ğ‘âŒ‰, outputs a pair (A,</p><formula xml:id="formula_12">T A ) âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ Ã— Z ğ‘šÃ—ğ‘š such that A is 2 -Î© (ğ‘›) -close to uniform in Z ğ‘›Ã—ğ‘š ğ‘ and T A is a basis of Î› âŠ¥ ğ‘ (A), satisfying âˆ¥ T A âˆ¥ â‰¤ O (</formula><p>âˆšï¸ ğ‘› log ğ‘) with overwhelming probability.</p><p>â€¢ ( <ref type="bibr" target="#b13">[14]</ref>): SampleD(A, T A , u, ğœ) a randomized algorithm that, given a full rank matrix</p><formula xml:id="formula_13">A âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ ,a basis T A of Î› âŠ¥ ğ‘ (A), a vector u âˆˆ Z ğ‘› ğ‘ and ğœ â‰¥ âˆ¥ T A âˆ¥ â€¢ ğœ” ( âˆšï¸ log ğ‘š), then outputs a vector r âˆˆ Z ğ‘š ğ‘ sampled from a distribution 2 -Î© (ğ‘›) -close to D Î› u ğ‘ (A),ğœ . Discrete Gaussian Lemmas.</formula><p>The following lemmas are used to manipulate and obtain meaningful bounds on discrete Gaussian vectors. Lemma 2.2. (Adopted from <ref type="bibr" target="#b13">[14]</ref>, Lem.5.2). Let ğ‘›, ğ‘š, ğ‘ be positive integers such that ğ‘š â‰¥ 2ğ‘› log ğ‘ and ğ‘ a prime. Let ğœ be any positive real such that ğœ â‰¥ âˆšï¸ ğ‘› + log ğ‘š. Then for all but 2 -Î© (ğ‘›) fraction of A âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ , we have that the distribution of u = Ar mod ğ‘ for r â† ğ· Z ğ‘š ,ğœ is 2 -Î© (ğ‘›) -close to uniform distribution over Z ğ‘› ğ‘ . Furthermore, for a fixed u âˆˆ Z ğ‘› ğ‘ , the conditional distribution of r â† ğ· Z ğ‘š ,ğœ , given Ar = u mod ğ‘ is D Î› u ğ‘ (A),ğœ . The security of our construction is based on the learning with errors (LWE) hardness assumption. The LWE problem is a hard problem based on lattices defined by Regev <ref type="bibr" target="#b20">[21]</ref>, which is stated below: given an input (A, d), where A âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ for any ğ‘š = ğ‘ğ‘œğ‘™ğ‘¦ (ğ‘›) and integer ğ‘ â‰¥ 2 is prime and d âˆˆ Z ğ‘š ğ‘ is either of the form d = (A âŠ¤ s + e) mod ğ‘ for s âˆˆ Z ğ‘› ğ‘ and e âˆˆ D Z ğ‘š ,ğœ or is uniformly random (and independent of A), distinguish which is the case, with non-negligible advantage. Regev proved that LWE problem is as hard as approximating standard lattice problems in the worst case using a quantum algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Classic Identity-Based Encryption</head><p>A classic IBE scheme consists of the following four algorithms:</p><p>â€¢ KeyGen(</p><p>1 ğœ† ) â†’ (mpk, msk). The key generation algorithm takes in a security parameter 1 ğœ† as input. It outputs master public key mpk and a master secret key msk. â€¢ Extract(mpk, msk, ğ‘–ğ‘‘) â†’ ğ‘ ğ‘˜ ğ‘–ğ‘‘ . The key extraction algorithm takes master public key mpk, master secret key msk, and identity ğ‘–ğ‘‘ as input. It outputs ğ‘ ğ‘˜ ğ‘–ğ‘‘ as the secret key. â€¢ Encrypt(mpk, ğ‘–ğ‘‘, M; ğ‘Ÿ ) â†’ ğ‘. The encryption algorithm takes in public parameters mpk, identities ğ‘–ğ‘‘, and a message M as input. It outputs a ciphertext ğ‘. â€¢ Decrypt(ğ‘ ğ‘˜ ğ‘–ğ‘‘ , ğ‘) â†’ M. The decryption algorithm takes in the secret key ğ‘ ğ‘˜ ğ‘–ğ‘‘ and a ciphertext ğ‘, as input. It outputs a message M.</p><p>Correctness. For all (mpk, msk)</p><formula xml:id="formula_14">$ â† KeyGen(1 ğœ† ), all identities ğ‘–ğ‘‘ âˆˆ ğ¼ğ·, all messages ğ‘€, all ğ‘ â† Encrypt(mpk, ğ‘–ğ‘‘, M; ğ‘Ÿ ), we have Pr[Decrypt(mpk, ğ‘ ğ‘˜ ğ‘–ğ‘‘ , ğ‘) = M] = 1 -negl(ğœ†).</formula><p>Security. The security game is defined by the following experiment, played by a challenger and an adversary A:</p><p>(1) The challenger runs KeyGen to generate (mpk, msk). It gives mpk to the adversary A. (2) The adversary A adaptively requests keys for any identity ğ‘–ğ‘‘ ğ‘– of its choice. The challenger responds with the corresponding secret key ğ‘ ğ‘˜ ğ‘–ğ‘‘ ğ‘– , which it generates by running Extract(mpk, msk, ğ‘–ğ‘‘ ğ‘– ). (3) The adversary A submits two messages M 0 and M 1 of equal length and a challenge identity ğ‘–ğ‘‘ * with the restriction that ğ‘–ğ‘‘ * is not equal to any identity requested in the previous phase. The challenger picks ğ›½ $ â† {0, 1}, and encrypts M ğ›½ under ğ‘–ğ‘‘ * by running the encryption algorithm. It sends the ciphertext to the adversary A. (4) A continues to issue key queries for any identity ğ‘–ğ‘‘ ğ‘– as in step (2) with the restriction that ğ‘–ğ‘‘ ğ‘– â‰  ğ‘–ğ‘‘ * . (5) The adversary A outputs a guess ğ›½ â€² for ğ›½.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The advantage Adv IBE</head><p>A (ğœ†) of an adversary A is defined to be</p><formula xml:id="formula_15">Adv IBE A (ğœ†) = Pr[ğ›½ â€² = ğ›½] -1/2 .</formula><p>ğ·ğ‘’ ğ‘“ ğ‘–ğ‘›ğ‘–ğ‘¡ğ‘–ğ‘œğ‘› 1. An IBE scheme is fully secure if for all probabilistic polynomial-time adversaries A, Adv IBE A (ğœ†) is a negligible function in ğœ†.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">QUANTUM IBE 3.1 Definition of QIBE</head><p>In this section, we give the definition of QIBE and classify QIBE.</p><p>Definition 2: If one or more elements of the quadruple (KeyGen, Extract, Encrypt, Decrypt) of the IBE scheme are quantum process, then we call the IBE scheme quantum IBE, namely QIBE scheme.</p><p>It is analogous to the analysis and classification of quantum public key encryption <ref type="bibr" target="#b27">[28]</ref> and quantum symmetric-encryption scheme <ref type="bibr" target="#b30">[31]</ref>, each element of the quadruple can be classic or quantum, so there may be sixteen types of QIBE schemes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Our Construction</head><p>In this section, we utilise the proposed classic IBE scheme <ref type="bibr" target="#b13">[14]</ref> to construct a kind of QIBE scheme based on quantum trapdoor one-way transformation <ref type="bibr" target="#b34">[35]</ref>, whose directly encrypted message is a multi-bit quantum state. In our QIBE scheme, the algorithms KeyGen and Extract are classic process and the algorithms Encrypt and Decrypt are quantum process. To make it easier to distinguish between classic IBE and QIBE, we denote that our scheme consists of four algorithms QIBE = (QKeyGen, QExtract, QEncrypt, QDecrypt). In the scheme, let integer parameters ğ‘› = O (ğœ†), ğ‘š = O (ğ‘›), ğœ = O (ğ‘› 0.5 ), ğ‘ = O (ğ‘š 3.5 ) according to <ref type="bibr" target="#b13">[14]</ref>, where ğœ† is a security parameter.</p><p>â€¢QKeyGen : ( <ref type="formula">1</ref> â˜…Step 3: Take above result as the input of quantum absolute value circuit which will be described in section 4.</p><p>1, we can get âˆ‘ï¸ m ğ›¼ m abs x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘y mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ â€¢ i . â˜…Step 4: Take above result, âŒŠ ğ‘ 4 âŒ‹ and |0âŸ© as the inputs of quantum comparison network, we can get âˆ‘ï¸ m ğ›¼ m abs âŒŠx + ğ‘ 2 âŒ‹m mod ğ‘y mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ â€¢ i |mâŸ© . Next, we will unentangle the first and the second register of this quantum state. â˜…Step 5: Take the first register of above result as the input of the inverse of quantum absolute value circuit, we can get âˆ‘ï¸ m ğ›¼ m âŒŠx + ğ‘ 2 âŒ‹m mod ğ‘y mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ â€¢ i |mâŸ© . â˜…Step 6: Take âŒŠ ğ‘ 2 âŒ‹ and the first register of above result as quantum addition network's inputs, we can get âˆ‘ï¸ m ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘y mod ğ‘ |mâŸ© . â˜…Step 7: Take |yâŸ© and the first register of above result as the quantum adder modulo ğ‘ network's inputs, we can get âˆ‘ï¸ m ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘ |mâŸ© . â˜…Step 8: Take each bit of the second register of above result as the control bit and |0âŸ© as the input, by the controlled copying classic constant âŒŠ ğ‘ 2 âŒ‹ circuit, we can get âˆ‘ï¸ m ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘ |mâŸ© âŒŠ ğ‘ 2 âŒ‹m . â˜…Step 9: Take the first register and the third register of above result as the inputs of the inverse of quantum adder modulo ğ‘ network, we can get âˆ‘ï¸ m ğ›¼ m |xâŸ© |mâŸ© âŒŠ ğ‘ 2 âŒ‹m . Then, we need to unentangle the second and the third register of this result. â˜…Step 10: Take each bit of the second register of above result as the control bit, and the third register of above result as the input of controlled copying classic constant âŒŠ ğ‘ 2 âŒ‹ circuit, that's, by performing the inverse operation of step 8, we can get âˆ‘ï¸ m ğ›¼ m |mâŸ© |0âŸ© . Then, quantum state m ğ›¼ m |mâŸ© is no longer entangled with other registers and the decryption process is complete. (3) In a word, QDecrypt(ğ‘–ğ‘‘, mpk, R, (c 1 , |ğœ“ âŸ©)) â†’ m ğ›¼ m |mâŸ©.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Correctness</head><p>Consider a ciphertext </p><formula xml:id="formula_16">(c 1 , |ğœ“ âŸ©) = (A âŠ¤ s + e) mod ğ‘, âˆ‘ï¸ m ğ›¼ m (x + âŒŠ ğ‘ 2 âŒ‹m) mod ğ‘ of an ğ‘›-qubit quantum superposition state m ğ›¼ m |mâŸ©, it is easy to see that |ğœ“ âŸ© = m ğ›¼ m |c 0 âŸ©, where c 0 = (x + âŒŠ ğ‘ 2 âŒ‹m) mod ğ‘ = U âŠ¤ s + e 0 + âŒŠ ğ‘ 2 âŒ‹ â€¢ m mod ğ‘. In the step 2 of QDecrypt, it is clear that x + âŒŠ ğ‘ 2 âŒ‹m mod ğ‘ -y mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ â€¢ i = (c 0 -y) mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ â€¢ i</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Security proof</head><p>Theorem 3.1. The above IBE scheme QIBE is fully secure in the random oracle model assuming the hardness of LWE. Namely, for any classical PPT adversary A making at most ğ‘„ H random oracle queries to H and ğ‘„ ID secret key queries, there exists a classical PPT algorithm B such that</p><formula xml:id="formula_17">Adv QIBE A (ğœ†) â‰¤ ğ‘„ H â€¢ Adv LWE B (ğœ†) + (ğ‘› â€¢ğ‘„ H +ğ‘› â€¢ğ‘„ ID + 1) â€¢ 2 -Î© (ğ‘›) .</formula><p>(1) Proof (of Theorem 3.1.) Without loss of generality, we make some simplifying assumptions on A. First, we assume that whenever A queries a secret key or asks for a challenge ciphertext, the corresponding ğ‘–ğ‘‘ has already been queried to the random oracle H. Second, we assume that A makes the same query for the same random oracle at most once. Third, we assume that A does not repeat secret key queries for the same identity more than once. We show the security of the scheme via the following games. In each game, we define ğ‘‹ ğ‘– as the event that the adversary A wins in Game i . Game 0 : This is the real security game. At the beginning of the game, (A, T A ) â† TrapGen(1 ğ‘› , 1 ğ‘š , ğ‘) is run and the adversary A is given A. The challenger then samples ğ›½ â† {0, 1} and keeps it secret. During the game, A may make random oracle queries, secret key queries, and the challenge query. These queries are handled as follows:</p><p>â€¢Hash queries: When A makes a random oracle query to H on ğ‘–ğ‘‘, the challenger chooses a random matrix U ğ‘–ğ‘‘ â† Z ğ‘› ğ‘ and locally stores the tuple (ğ‘–ğ‘‘, U ğ‘–ğ‘‘ , âŠ¥), and returns U ğ‘–ğ‘‘ to A.</p><p>â€¢Secret key queries: When the adversary A queries a secret key for ğ‘–ğ‘‘, the challenger uses the algorithm SampleD which takes A, T ğ´ , ğœ, U ğ‘–ğ‘‘ as input to compute R ğ‘–ğ‘‘ and returns R ğ‘–ğ‘‘ to A. At the end of the game, A outputs a guess ğ›½ â€² for ğ›½. Finally, the challenger outputs ğ›½ â€² . By definition, we have</p><formula xml:id="formula_18">| Pr[ğ‘‹ 0 ] - 1 2 | = | Pr[ğ›½ â€² = ğ›½] - 1 2 | = Adv QIBE A (ğœ†). (<label>2</label></formula><formula xml:id="formula_19">)</formula><p>Game 1 : In this game, we change the way the random oracle queries to H are answered. When A queries the random oracle H on ğ‘–ğ‘‘, the challenger generates a pair (U ğ‘–ğ‘‘ , R ğ‘–ğ‘‘ ) by first sampling r ğ‘– ğ‘–ğ‘‘ $ â† D Z ğ‘š ,ğœ to construct R ğ‘–ğ‘‘ and setting U ğ‘–ğ‘‘ = A â€¢ R ğ‘–ğ‘‘ . Then it locally stores the tuple (ğ‘–ğ‘‘, U ğ‘–ğ‘‘ , âŠ¥), and returns U ğ‘–ğ‘‘ to A. Here, we remark that when A makes a secret key query for ğ‘–ğ‘‘, the challenger uses the algorithm SampleD which takes A, T ğ´ , ğœ, U ğ‘–ğ‘‘ as input to compute R â€² ğ‘–ğ‘‘ and returns R â€² ğ‘–ğ‘‘ to A. Note that R â€² ğ‘–ğ‘‘ is independent from R ğ‘–ğ‘‘ that was generated in the simulation of the random oracle H on input ğ‘–ğ‘‘. Due to Lemma 2.2, the distribution of U ğ‘–ğ‘‘ in Game 1 is ğ‘› â€¢ 2 -Î© (ğ‘›) -close to that of Game 0 except for 2 -Î© (ğ‘›) fraction of A since we choose ğœ &gt; âˆšï¸ ğ‘› + log ğ‘š. Therefore, we have</p><formula xml:id="formula_20">| Pr[ğ‘‹ 1 ] -Pr[ğ‘‹ 0 ]| = ğ‘› â€¢ ğ‘„ H â€¢ 2 -Î© (ğ‘›) .<label>(3)</label></formula><p>Game 2 : In this game, we change the way secret key queries are answered. By the end of this game, the challenger will no longer require the trapdoor T A to generate the secret keys. When A queries the random oracle on ğ‘–ğ‘‘, the challenger generates a pair (U ğ‘–ğ‘‘ , R ğ‘–ğ‘‘ ) as in the previous game. Then it locally stores the tuple (ğ‘–ğ‘‘, U ğ‘–ğ‘‘ , R ğ‘–ğ‘‘ ) and returns U ğ‘–ğ‘‘ to A. When A queries a secret key for ğ‘–ğ‘‘, the challenger retrieves the unique tuple (ğ‘–ğ‘‘, U ğ‘–ğ‘‘ , R ğ‘–ğ‘‘ ) from local storage and returns R ğ‘–ğ‘‘ . For any fixed U ğ‘–ğ‘‘ , let R ğ‘–ğ‘‘,1 and R ğ‘–ğ‘‘,2 be random variables that are distributed according to the distributions of ğ‘ ğ‘˜ ğ‘–ğ‘‘ conditioning on H(ğ‘–ğ‘‘) = U ğ‘–ğ‘‘ in Game 1 and Game 2 , respectively. Due to Lemma 2.1, we have</p><formula xml:id="formula_21">Î”(r ğ‘– ğ‘–ğ‘‘,1 , D Î› u ğ‘ (A),ğœ ) â‰¤ 2 -Î© (ğ‘›) for ğ‘– = 1, â€¢ â€¢ â€¢ , ğ‘›. Due to Lemma 2.2, we have Î”(r ğ‘– ğ‘–ğ‘‘,2 , D Î› u ğ‘ (A),ğœ ) â‰¤ 2 -Î© (ğ‘›) for ğ‘– = 1, â€¢ â€¢ â€¢ , ğ‘›. Then we can get Î”(R ğ‘–ğ‘‘,1 , R ğ‘–ğ‘‘,2 ) â‰¤ ğ‘› â€¢ 2 -Î© (ğ‘›) . There- fore we have | Pr[ğ‘‹ 2 ] -Pr[ğ‘‹ 1 ]| = ğ‘› â€¢ ğ‘„ ID â€¢ 2 -Î© (ğ‘›) .<label>(4)</label></formula><p>Game 3 : In this game, we change the way the matrix A is generated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concretely, the challenger chooses</head><formula xml:id="formula_22">A $ â† Z ğ‘›Ã—ğ‘š ğ‘</formula><p>without generating the associated trapdoor T A . By Lemma 2.1, this makes only 2 -Î© (ğ‘›)statistical difference. Since the challenger can answer all the secret key queries without the trapdoor due to the change we made in the previous game, the view of A is altered only by 2 -Î© (ğ‘›) . Therefore, we have â€¢Hash queries: on A's ğ‘—th distinct queries ğ‘–ğ‘‘ ğ‘— to H, the challenger does the following: if ğ‘— = ğ‘– * , then locally stores the tuple (ğ‘–ğ‘‘ ğ‘— , U, âŠ¥) and returns U to A. Otherwise for ğ‘— â‰  ğ‘– * , the challenger selects R ğ‘–ğ‘‘ ğ‘— and computes U ğ‘–ğ‘‘ ğ‘— = AR ğ‘–ğ‘‘ ğ‘— , then locally stores the tuple (ğ‘–ğ‘‘ ğ‘— , U ğ‘–ğ‘‘ ğ‘— , R ğ‘–ğ‘‘ ğ‘— ) and returns U ğ‘–ğ‘‘ ğ‘— to A.</p><formula xml:id="formula_23">| Pr[ğ‘‹ 3 ] -Pr[ğ‘‹ 2 ]| = 2 -Î© (ğ‘›) .<label>(5</label></formula><p>â€¢Challenge ciphertext: when A produces a challenge identity ğ‘–ğ‘‘ * (distinct from all its secret key queries) and messages m 0 ğ›¼ m 0 |m 0 âŸ©, m 1 ğ›¼ m 1 |m 1 âŸ©, assume without loss of generality that A already queried H on ğ‘–ğ‘‘ * . If ğ‘–ğ‘‘ * â‰  ğ‘–ğ‘‘ ğ‘– * , i.e., if the tuple (ğ‘–ğ‘‘ ğ‘– * , U, âŠ¥) is not in local storage, then the challenger ignores the output of A and aborts the game (we denote this event as abort). Otherwise, i.e., the abort does not happen(we denote this event as abort), the chal- Conditioned on the challenger not aborting, we claim that the view it provides to A in Game 4 is statistically close to that in Game 3 . Therefore, we have</p><formula xml:id="formula_24">Pr[ğ‘‹ 4 | abort] = Pr[ğ‘‹ 3 | abort].<label>(6)</label></formula><p>By a standard argument, the probability that the challenger does not abort during the simulation is 1 ğ‘„ H (this is proved by considering a game in which the challenger can answer all secret key queries, so that the value of ğ‘– * is perfectly hidden from A). Therefore, we have</p><formula xml:id="formula_25">Pr[abort] = 1 ğ‘„ H .<label>(7)</label></formula><p>Game 5 : In this game, we change the way the challenge ciphertext is created.</p><p>â€¢Challenge ciphertext: when A produces a challenge identity ğ‘–ğ‘‘ * (distinct from all its secret key queries) and messages m 0 ğ›¼ m 0 |m 0 âŸ©, m 1 ğ›¼ m 1 |m 1 âŸ©, assume without loss of generality that A already queried H on ğ‘–ğ‘‘ * . If ğ‘–ğ‘‘ * â‰  ğ‘–ğ‘‘ ğ‘– , i.e., if the tuple (ğ‘–ğ‘‘ ğ‘– , U, âŠ¥) is not in local storage, then the challenger ignores the output of A and aborts the game (we denote this event as abort). Otherwise, i.e., the abort does not happen (we denote this event as abort), the challenger picks ğ›½ </p><p>Note that c 1 , x is statistically close to the uniform distribution over</p><formula xml:id="formula_27">Z ğ‘š ğ‘ Ã— Z ğ‘› ğ‘ , so that Pr[ğ‘‹ 5 | abort] = 1 2 . (<label>9</label></formula><formula xml:id="formula_28">)</formula><p>According to equations from ( <ref type="formula" target="#formula_24">6</ref>) to <ref type="bibr" target="#b8">(9)</ref>, we can get</p><formula xml:id="formula_29">Pr[ğ‘‹ 3 | abort] - 1 2 â‰¤ ğ‘„ H â€¢ Adv LWE B (ğœ†).</formula><p>Then because abort is independent of ğ‘‹ 3 , we can get</p><formula xml:id="formula_30">Pr[ğ‘‹ 3 ] - 1 2 â‰¤ ğ‘„ H â€¢ Adv LWE B (ğœ†).<label>(10)</label></formula><p>Finally, according to equations from (2) to ( <ref type="formula" target="#formula_23">5</ref>) together with equation <ref type="bibr" target="#b9">(10)</ref>, we can get equation (1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Security Network Protocols with Our QIBE</head><p>A fundamental fact in quantum information theory is that unknown or random quantum states cannot be cloned <ref type="bibr" target="#b26">[27]</ref>. The quantum ciphertext state is</p><formula xml:id="formula_31">|ğœ“ âŸ© = âˆ‘ï¸ m ğ›¼ m |(x + âŒŠ ğ‘<label>2</label></formula><p>âŒ‹m) mod ğ‘âŸ©.</p><p>For the adversary, the probability amplitude and the corresponding basis state of the ciphertext quantum states |ğœ“ âŸ© is unknown, so they cannot try to copy it during its transmission. Then in the handshake protocol based on our QIBE, an attacker cannot copy and store the quantum ciphertext states of session keys whose confidentiality is protected by the secret identity key (which is called the long-term key). Thus, although the attacker gets the long-term key, they has no the quantum ciphertext of previous session keys to decrypt and cannot threat the security of the previous session key. In a word, all encrypted communications and sessions happened in the past cannot be retrieved. Therefore, the security protocol based on our QIBE has perfect forward security, which cannot achieve by the security protocol based on classic IBE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">QUANTUM CIRCUIT REALIZATION 4.1 Quantum Circuit</head><p>In order to analyze the realizability of our scheme in quantum circuit construction and estimate the quantum resources required by the scheme, in this section we give the specific quantum circuit implementation of our QIBE scheme. The algorithms QKeyGen and QExtract of QIBE are classic algorithms and can be implemented with classic circuits. Thus we show the quantum circuit implementation of algorithms QEncrypt and QDecrypt of QIBE here.</p><p>â€¢ Quantum circuit of the algorithm QEncrypt: To simplify the description, we present the encryption quantum circuit of |ğ‘š ğ‘– âŸ©, and the encryption quantum circuit of m ğ›¼ m |mâŸ© is its ğ‘›-fold expansion. The quantum circuit implementation of the algorithm QEncrypt is shown in Figure <ref type="figure">8</ref>. In the first two steps of the encryption process, through the quantum controlled addition network and the quantum addition module ğ‘ network, we can get |ğ‘š ğ‘– âŸ©|(ğ‘¥ ğ‘– + âŒŠ â€¢ Quantum circuit of the algorithm QDecrypt: The algorithm QDecrypt extracts m ğ›¼ m |mâŸ© from the ciphertext quantum state. To simplify the description, we present the decryption quantum circuit of the ciphertext whose corresponding plaintext is |ğ‘š ğ‘– âŸ©, and the decryption quantum circuit of the ciphertext whose corresponding plaintext is m ğ›¼ m |mâŸ© is its ğ‘›-fold expansion. According to Appendix, we can know that if abs ğ‘¥ ğ‘– + âŒŠ ğ‘ 2 âŒ‹ğ‘š ğ‘– mod ğ‘ -ğ‘¦ ğ‘– mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ &lt; âŒŠ ğ‘ 4 âŒ‹, |ğ‘š ğ‘– âŸ© = |1âŸ©; otherwise, |ğ‘š ğ‘– âŸ© = |0âŸ©. Thus, before constructing the decryption quantum circuit, we need to construct the quantum absolute value circuit which implements the step 3 and step 5 of the QDecrypt process. The analysis and construction process of the quantum absolute value circuit is as follows: Denote |ğœ‘âŸ© = ğ‘¥ ğ‘– + âŒŠ ğ‘ 2 âŒ‹ğ‘š ğ‘– mod ğ‘ -ğ‘¦ ğ‘– mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ , to prevent overflow when storing |ğœ‘âŸ©, the size of the register to store |ğœ‘âŸ© should be âŒŠlog ğ‘ + 1âŒ‹ + 1. Denote ğ‘” ğ‘— ( ğ‘— = 1, ..., âŒŠlog ğ‘ + 1âŒ‹ + 1) as the ğ‘—-th bit of |ğœ‘âŸ© and ğ‘” â€² ğ‘— ( ğ‘— = 1, ..., âŒŠlog ğ‘ + 1âŒ‹ + 1) as the ğ‘—-th bit of |abs (ğœ‘)âŸ©, where ğ‘” âŒŠlog ğ‘+1âŒ‹+1 and ğ‘” â€² âŒŠlog ğ‘+1âŒ‹+1 are the most significant bits of |ğœ‘âŸ© and |abs (ğœ‘)âŸ©, respectively. Denote "(â€¢)" is to reverse "(â€¢)" bit by bit, for example 101 = |010âŸ©. It is clear that if |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© = 0, |abs (ğœ‘)âŸ© = |ğœ‘âŸ©; if |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© = 1, then |abs (ğœ‘)âŸ© can be also expressed as bellow:</p><formula xml:id="formula_32">abs ğ‘¥ ğ‘– + âŒŠ ğ‘ 2 âŒ‹ğ‘š ğ‘– mod ğ‘ -ğ‘¦ ğ‘– mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ = ğ‘¥ ğ‘– + âŒŠ ğ‘ 2 âŒ‹ğ‘š ğ‘– mod ğ‘ -ğ‘¦ ğ‘– mod ğ‘ -âŒŠ ğ‘ 2 âŒ‹ + 1 = 2 âŒŠlog ğ‘+1âŒ‹ + âŒŠ ğ‘ 2 âŒ‹ -ğ‘¥ ğ‘– + âŒŠ ğ‘ 2 âŒ‹ğ‘š ğ‘– mod ğ‘ -ğ‘¦ ğ‘– mod ğ‘ ,</formula><p>and we can also know that |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© = 1 in this situation from this result. Thus, we can conclude that |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© = |ğ‘” â€² âŒŠlog ğ‘+1âŒ‹+1 âŸ©. For constructing the quantum absolute value circuit to calculate |abs (ğœ‘)âŸ© from |ğœ‘âŸ©, we use |ğ‘” âŒŠlog ğ‘+1âŒ‹+1 âŸ© as the control bit. If ğ‘” âŒŠlog ğ‘+1âŒ‹+1 = |1âŸ©, the circuit perform the operation of bitwise negation and adding 1 on the result; otherwise, no useful operations are performed on the input. Then, we give the concrete quantum absolute value circuit and its simplified form shown in Figure <ref type="figure" target="#fig_12">9</ref>, which realizes</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>|ğœ‘âŸ© â†’ |abs (ğœ‘)âŸ©</head><p>To calculate the absolute value of |ğœ‘âŸ© which is âŒŠlog ğ‘ + 1âŒ‹ + 1qubits, a total of 2âŒŠlog ğ‘ + 1âŒ‹ + 2 Toffoli gates, 5âŒŠlog ğ‘ + 1âŒ‹ + 9 CNOT gates, and a total of 2âŒŠlog ğ‘ + 1âŒ‹ + 2 qubits are required for this quantum absolute value network. Then, the quantum circuit implementation of the algorithm QDecrypt is shown in Figure <ref type="figure" target="#fig_13">10</ref>, which marks the steps 1 to 10 in the process of the quantum decryption algorithm QDecrypt in Section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Quantum resource estimation</head><p>To measure the complexity of a quantum circuit, we should consider the number of quantum gates in the circuit and the total number of qubits used. In quantum circuits, it is meaningful to estimate the number of Hadamard gates, phase gate, CNOT gates and especially T gates. On the one hand, any unitary operator can be expressed exactly using single qubit and CNOT gates <ref type="bibr" target="#b11">[12]</ref>, and single qubit operation can be approximated to arbitrary accuracy using the Hadamard gate, phase gate and T gate <ref type="bibr" target="#b18">[19]</ref>. On the other hand, the structure of the fault-tolerant T gate is non-transverse and requires more complex and expensive technology to achieve it <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b18">19]</ref>. According to the trues that one âŒŠlog ğ‘ + 1âŒ‹-controlled NOT gate can be decomposed into 2âŒŠlog ğ‘ + 1âŒ‹ -3 Toffoli gates, and one Toffoli gate can be broken down into two Hadamard gates, one phase gate, seven T gates and six CNOT gates <ref type="bibr" target="#b3">[4]</ref>, we estimate the quantum resources needed to encrypt the ğ‘›-qubit quantum state m ğ›¼ m |mâŸ© with the algorithm QEncrypt of QIBE, and decrypt the corresponding ciphertext with the algorithm QDecrypt of QIBE, including the numbers of Hadamard gate, phase gate, T gate, CNOT gate and the total qubits used, in which these gates constitute a universal quantum gate group. The quantum resources required by the quantum circuits of the encryption algorithm QEncrypt and the decryption algorithm QDecrypt are shown in the table 1. In order to save quantum resources, auxiliary bits can be reused according to the sequence of calculations in each circuit <ref type="bibr" target="#b14">[15]</ref>. It can be seen from the table that the quantum resources required by our scheme increase linearly with the number of bits of the encrypted quantum plaintext.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>In this paper, we proposed a kind of QIBE scheme based on the proposed classic IBE scheme <ref type="bibr" target="#b13">[14]</ref>, and proved that it is fully secure. We construct the quantum circuit of QEncrypt of our scheme. Moreover, to implement the quantum circuit of QDecrypt of our scheme, we construct a quantum absolute value circuit and then give the quantum circuit of QDecrypt based on it. We estimate the quantum resources required for the quantum circuit of our scheme, including the numbers of Hadamard gate, phase gate, T gate, CNOT gate and total qubits used, and conclude that the quantum resources required by our scheme increase linearly with the number of bits of the encrypted quantum plaintext. Our QIBE scheme is suitable for quantum computing environment can encrypt both quantum messages and classic messages, and the classic KGC can still be used for the generation and distribution of identity secret key so that the cost can be reduced when the quantum scheme is implemented.</p><p>In our QIBE scheme, the ciphertexts are transmitted in the form of a quantum state that is unknown to the adversary and cannot be copied and stored due to the no-cloning theorem. Thus, in the network security protocol based on our QIBE construction, even if the long-term key is threatened, the adversary cannot decrypt the previous ciphertexts to threat the previous session keys. Therefore, our QIBE scheme can make the network security protocol based on it have perfect forward security.</p><p>Our structure is one of the sixteen types of QIBE schemes described in section 3.1, and the other fifteen types of QIBE schemes are yet to be studied. Moreover, the security of our scheme is based on the classic difficulty problem assumption the LWE assumption. Compared with the rapid development of quantum public-key encryption schemes based on the basic principles of quantum mechanics <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b35">36]</ref>, the design and research of the QIBE scheme based on the basic principles of quantum mechanics has a lot of room for development, which is also a very meaningful research direction.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><figDesc>1} * ğ‘ = Encrypt(mpk, ğ‘–ğ‘‘ğ‘…, ğ‘ ğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›ğ¾ğ‘’ğ‘¦; ğ‘Ÿ ) ğ‘ ğ‘ ğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›ğ¾ğ‘’ğ‘¦ = Decrypt(ğ‘ ğ‘˜ğ‘…, ğ‘) Secure communication</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Security protocols based on IBE</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: controlled copying the classical constant ğ‘‘ circuit</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: simplified form of the quantum addition and subtraction network</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: simplified form of the quantum quantum adder modulo ğ‘ network and quantum comparison network</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>ğ‘ 2 âŒ‹ğ›¼ m |mâŸ© âŒŠ ğ‘ 2 âŒ‹m . â˜…Step 2 : 2 âŒ‹m) mod ğ‘ . â˜…Step 3 :ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹mğ‘ 2 âŒ‹ğ›¼ m x + âŒŠ ğ‘ 2 âŒ‹m 2 âŒ‹</head><label>222232222</label><figDesc>) Use the algorithm TrapGen(ğ‘š, ğ‘›, ğ‘) to select a uniformly random ğ‘› Ã—ğ‘š-matric A âˆˆ Z ğ‘›Ã—ğ‘š ğ‘ and T A âˆˆ Z ğ‘šÃ—ğ‘š ğ‘ which is a good basis for Î› âŠ¥ ğ‘ (A). (2) Select a hash function H : {0, 1} ğ‘› â†’ Z ğ‘›Ã—ğ‘› ğ‘ which map an identity to an ğ‘› Ã— ğ‘›-matric. (3) Output the master key mpk = (A, ğ‘, ğ‘š, ğ‘›, H) and msk = (T A ). (4) In a word, QKeyGen(ğœ†, ğ‘, ğ‘š, ğ‘›) â†’ (mpk = (A, ğ‘, ğ‘š, ğ‘›, H), msk = (T A )). â€¢QExtract: (1) Input mpk, msk and an identity ğ‘–ğ‘‘ âˆˆ {0, 1} ğ‘› . (2) Compute U = H(ğ‘–ğ‘‘) and use the algorithm SampleD to generate ğ‘ ğ‘˜ ğ‘–ğ‘‘ = R such that r ğ‘– = SampleD(A, T A , u ğ‘– , ğœ) for ğ‘– = 1, â€¢ â€¢ â€¢ , ğ‘›. It is clear U = AR mod ğ‘. (3) In a word, QExtract(msk, mpk, ğ‘–ğ‘‘) â†’ ğ‘ ğ‘˜ ğ‘–ğ‘‘ = R. â€¢QEncrypt: (1) To encrypt an ğ‘›-qubit quantum superposition state m ğ›¼ m |mâŸ©, input an identity ğ‘–ğ‘‘, mpk and the quantum message m ğ›¼ m |mâŸ©, where |mâŸ© is the basis state of the quantum message length ğ‘›-qubit. (2) Compute U = H(ğ‘–ğ‘‘). (3) Choose a uniformly random s â† Z ğ‘› ğ‘ , e 0 âˆˆ D Z ğ‘› ,ğœ and e âˆˆ D Z ğ‘š ,ğœ . (4) Set x = (U âŠ¤ s + e 0 ) mod ğ‘ and c 1 = (A âŠ¤ s + e) mod ğ‘. Then more processes are performed as follows: â˜…Step 1: Take each bit of quantum state m ğ›¼ m |mâŸ© as the control bit and |0âŸ© as the input, by the controlled copying classical constant âŒŠ circuit we can get âˆ‘ï¸ m Take above result and x as quantum adder modulo ğ‘ network's inputs, we can get âˆ‘ï¸ m ğ›¼ m |mâŸ© (x + âŒŠ ğ‘ Unentangle the two registers of the above result to get |ğœ“ âŸ© = âˆ‘ï¸ m ğ›¼ m (x + âŒŠ ğ‘ 2 âŒ‹m) mod ğ‘ , and the specific unentanglement process will be described in detail in Section 4. (5) In a word, QEncrypt(ğ‘–ğ‘‘, m ğ›¼ m |mâŸ©) â†’ (ğ‘ = (c 1 , |ğœ“ âŸ©)). â€¢QDecrypt: (1) Input the master public key mpk, the private key R, and the ciphertext (c 1 , |ğœ“ âŸ©). (2) Set R âŠ¤ c 1 mod ğ‘ = y âˆˆ Z ğ‘› ğ‘ . Then more processes are performed as follows: â˜…Step 1: Take |yâŸ© and |ğœ“ âŸ© = m ğ›¼ m (x + âŒŠ ğ‘ 2 âŒ‹m) mod ğ‘ as the inputs of the inverse of quantum adder modulo ğ‘ network, we can get âˆ‘ï¸ m mod ğ‘y mod ğ‘ . â˜…Step 2: Take âŒŠ and above result as the inputs of quantum subtraction network, we can get âˆ‘ï¸ m mod ğ‘y mod ğ‘ -âŒŠ ğ‘ â€¢ i .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><figDesc>which equals to b in the Decrypt of Theorem 1. Then in the step 3 of QDecrypt, we compute the absolute value abs(b) of b. Finally in the step 4 of QDecrypt, we compare abs(b) with âŒŠ ğ‘ 4 âŒ‹ and get m. According to Theorem 1, the decryption algorithm Decrypt with the identity secret key ğ‘ ğ‘˜ ğ‘–ğ‘‘ = R ğ‘–ğ‘‘ can decrypt the ciphertext ğ‘ = (c 0 , c 1 ) correctly with a probability 1negl(ğœ†). Therefore, the decryption algorithm QDecrypt with the identity secret key ğ‘ ğ‘˜ ğ‘–ğ‘‘ = R ğ‘–ğ‘‘ can decrypt the ciphertext ğ‘ = (c 1 , |ğœ“ âŸ©) correctly with a probability 1negl(ğœ†).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>â€¢</head><figDesc>Challenge ciphertext: When the adversary A submits two messages m 0 ğ›¼ m 0 |m 0 âŸ© and m 1 ğ›¼ m 1 |m 1 âŸ© of equal length and a challenge identity ğ‘–ğ‘‘ * with the restriction that ğ‘–ğ‘‘ * is not equal to any identity requested in the previous phase. The challenger picks ğ›½ $ â† {0, 1}, and encrypts m ğ›½ ğ›¼ m ğ›½ |m ğ›½ âŸ© under ğ‘–ğ‘‘ * by running the encryption algorithm QEncrypt to get ğ‘ * = (|ğœ“ âŸ©, c 1 ), where |ğœ“ âŸ© = |(x + âŒŠ ğ‘ 2 âŒ‹m) mod ğ‘âŸ© and c 1 = (A âŠ¤ s + e) mod ğ‘ and x = U âŠ¤ s + e 0 mod ğ‘. It sends the ciphertext ğ‘ * to the adversary A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>) Game 4 :</head><label>4</label><figDesc>In this game, we change the way the random oracle queries to H are answered and the challenge ciphertext is created. The challenger chooses an index ğ‘– * $ â† [ğ‘„ H ] and a matrix U âˆˆ Z ğ‘›Ã—ğ‘› ğ‘ uniformly at random.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><figDesc>lenger picks ğ›½ $ â† {0, 1}, and encrypts m ğ›½ ğ›¼ m ğ›½ |m ğ›½ âŸ© under ğ‘–ğ‘‘ * by running the encryption algorithm QEncrypt to get ğ‘ * = (|ğœ“ âŸ©, c 1 ), where |ğœ“ âŸ© = |(x + âŒŠ ğ‘ 2 âŒ‹m) mod ğ‘âŸ© and c 1 = (A âŠ¤ s + e) mod ğ‘, and x = U âŠ¤ s + e 0 mod ğ‘. It sends the ciphertext ğ‘ * to the adversary A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>$â† 1 $</head><label>1</label><figDesc>{0, 1}, and encrypts m ğ›½ ğ›¼ m ğ›½ |m ğ›½ âŸ© under ğ‘–ğ‘‘ * by using two random vector b â€² $ â† Z ğ‘› ğ‘ , b $ â† Z ğ‘š ğ‘ to get ğ‘ * = (|ğœ“ âŸ©, c 1 ), where |ğœ“ âŸ© = |(x + âŒŠ ğ‘ 2 âŒ‹m) mod ğ‘âŸ© and c 1 = b, and x = b â€² . It sends the ciphertext ğ‘ * to the adversary A. It can be seen that if (A, U, c 1 , x) are valid LWE samples (i.e., c 1 = (A âŠ¤ s + e) mod ğ‘ and x = U âŠ¤ s + e 0 mod ğ‘), the view of the adversary corresponds to Game 4 . Otherwise (i.e., c it corresponds to Game 5 . Therefore we have Pr[ğ‘‹ 5 âˆ§ abort] -Pr[ğ‘‹ 4 âˆ§ abort] â‰¤ Adv LWE B (ğœ†).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>ğ‘ 2 âŒ‹ğ‘š 2 Figure 8 :</head><label>228</label><figDesc>Figure 8: The quantum circuit implementation of QEncrypt</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: The quantum circuit implementation of computing absolute value of |ğœ‘ âŸ©</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: The quantum circuit implementation of QDecrypt</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>Quantum resource.</figDesc><table><row><cell>Quantum resource</cell><cell>QEncrypt</cell></row><row><cell>Hadamard gate</cell><cell>2ğ‘› (10 ( âŒŠlog ğ‘ + 1âŒ‹) -3)</cell></row><row><cell>phase gate</cell><cell>ğ‘› (10 ( âŒŠlog ğ‘ + 1âŒ‹) -3)</cell></row><row><cell>T gate</cell><cell>7ğ‘› (10 ( âŒŠlog ğ‘ + 1âŒ‹) -3)</cell></row><row><cell>CNOT gate</cell><cell>ğ‘› (75.5 ( âŒŠlog ğ‘ + 1âŒ‹) -12)</cell></row><row><cell>Qubit</cell><cell>ğ‘› (4 ( âŒŠlog ğ‘ + 1âŒ‹) + 4)</cell></row><row><cell>Quantum resource</cell><cell>QDecrypt</cell></row><row><cell>Hadamard gate</cell><cell>2ğ‘› (34 ( âŒŠlog ğ‘ + 1âŒ‹) + 4)</cell></row><row><cell>phase gate</cell><cell>ğ‘› (34 ( âŒŠlog ğ‘ + 1âŒ‹) + 4)</cell></row><row><cell>T gate</cell><cell>7ğ‘› (34 ( âŒŠlog ğ‘ + 1âŒ‹) + 4)</cell></row><row><cell>CNOT gate</cell><cell>ğ‘› (269 ( âŒŠlog ğ‘ + 1âŒ‹) + 63)</cell></row><row><cell>Qubit</cell><cell>ğ‘› (6 ( âŒŠlog ğ‘ + 1âŒ‹) + 4)</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head n="6">ACKNOWLEDGMENTS</head><p>This work was supported by <rs type="funder">National Natural Science Foundation of China</rs> (Grant No. <rs type="grantNumber">61672517</rs>), <rs type="funder">National Natural Science Foundation of China</rs> (<rs type="programName">Key Program</rs>, Grant No. <rs type="grantNumber">61732021</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_4EAjzWT">
					<idno type="grant-number">61672517</idno>
				</org>
				<org type="funding" xml:id="_zCdA3XU">
					<idno type="grant-number">61732021</idno>
					<orgName type="program" subtype="full">Key Program</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A</head><p>In <ref type="bibr" target="#b13">[14]</ref>, Gentry et al. proposed an identity based encryption ğ¼ ğµğ¸ = (KeyGen, Extract, Encrypt, Decrypt) from the learning with errors problem. In this scheme, let integer parameters ğ‘› = O (ğœ†), ğ‘š = O (ğ‘›), ğœ = O (ğ‘› 0.5 ), ğ‘ = O (ğ‘š 3.5 ), where ğœ† is a security parameter.</p><p>â€¢ KeyGen : (1)Use the algorithm TrapGen(ğ‘š, ğ‘›, ğ‘) to select a uniformly random ğ‘› Ã— ğ‘š-matric A âˆˆ Z ğ‘›Ã—ğ‘š â€¢ Decrypt: (1)Given the master public key mpk, the private key R, </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Efficient lattice (H)IBE in the standard model</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="553" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Generating hard instances of the short basis problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ajtai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Generating shorter bases for hard random lattices</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alwen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="75" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A meet-in-the-middle algorithm for fast synthesis of depth-optimal quantum circuits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Amy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maslov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mosca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roetteler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="818" to="830" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient selective-id secure identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2004</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3027</biblScope>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the weil pairing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="213" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Space-efficient identity based encryption without pairings</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="647" to="657" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bonsai trees, or how to delegate a lattice basis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2010</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="523" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Chinese-State-Cryptography-Administration. Chinese ssl vpn technology specification</title>
		<ptr target="http://gmbz.org.cn/main/viewfile/20180110021416665180.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An identity based encryption scheme based on quadratic residues</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Cocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptography and Coding, 8th IMA International Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2260</biblScope>
			<biblScope unit="page" from="360" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cuccaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Draper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Kutin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Moulton</surname></persName>
		</author>
		<idno>quant-ph/0410184</idno>
		<title level="m">A new quantum ripple-carry addition circuit</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Quantum theory, the church-turing principle and the universal quantum computer</title>
		<author>
			<persName><forename type="first">D</forename><surname>Deutsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the Royal Society of London. A. Mathematical and Physical Sciences</title>
		<imprint>
			<biblScope unit="volume">400</biblScope>
			<biblScope unit="page" from="97" to="117" />
			<date type="published" when="1818">1818. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Quantum asymmetric cryptography with symmetric keys</title>
		<author>
			<persName><forename type="first">F</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science in China Series G: Physics, Mechanics and Astronomy</title>
		<imprint>
			<biblScope unit="page" from="1925" to="1931" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Trapdoors for hard lattices and new cryptographic constructions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual Symposium on Theory of Computing</title>
		<meeting>the 40th Annual Symposium on Theory of Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="197" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Improved quantum circuits for elliptic curve discrete logarithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>HÃ¤ner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jaques</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roetteler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Soeken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Post-Quantum Cryptography</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="425" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A variant of boneh-gentry-hamburg&apos;s pairing-free identity based encryption scheme</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Jhanwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Barua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Security and Cryptology</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5487</biblScope>
			<biblScope unit="page" from="314" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Identity-based cryptosystems and quadratic residuosity</title>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public-Key Cryptography</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9614</biblScope>
			<biblScope unit="page" from="225" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Constant-optimized quantum circuits for modular multiplication and exponentiation</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">L</forename><surname>Markov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Saeedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Quantum Information and Computation</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="361" to="394" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Quantum computation and quantum information</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Chuang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Applications of single-qubit rotations in quantum public-key cryptography</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Nikolopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review A</title>
		<imprint>
			<biblScope unit="page">32348</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On lattices, learning with errors, random linear codes, and cryptography</title>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="84" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Quantum resource estimates for computing elliptic curve discrete logarithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Roetteler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Svore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lauter</surname></persName>
		</author>
		<idno>arXiv: Quantum Physics</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Identity-based cryptosystems and signature schemes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology, Proceedings of CRYPTO</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">196</biblScope>
			<biblScope unit="page" from="47" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Shor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1484" to="1509" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Handbook of applied cryptography</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vanstone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>CRC press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Efficient identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2005</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="114" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A single quantum cannot be cloned</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Wootters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">H</forename><surname>Zurek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">299</biblScope>
			<biblScope unit="issue">5886</biblScope>
			<biblScope unit="page" from="802" to="803" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A complete classification of quantum public-key encryption protocols</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Electro-Optical and Infrared Systems</title>
		<imprint>
			<publisher>International Society for Optics and Photonics</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9648</biblScope>
			<biblScope unit="page">964818</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Bit-oriented quantum public-key encryption based on quantum perfect encryption</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Quantum Information Processing</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="3285" to="3300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Qubit-wise teleportation and its application in public-key secret communication</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science China(Information Sciences)</title>
		<imprint>
			<biblScope unit="page" from="183" to="194" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The classification of quantum symmetrickey encryption protocols</title>
		<author>
			<persName><forename type="first">C</forename><surname>Xiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Quantum and Nonlinear Optics III</title>
		<imprint>
			<publisher>International Society for Optics and Photonics</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">9269</biblScope>
			<biblScope unit="page">926909</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Deterministic public key encryption and identitybased encryption from lattices in the auxiliary-input setting</title>
		<author>
			<persName><forename type="first">X</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Cryptography for Networks</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7485</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Adaptively secure identity-based encryption from lattices with asymptotically shorter public parameters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2016</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9666</biblScope>
			<biblScope unit="page" from="32" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Cnot-count optimized quantum circuit of shor&apos;s algorithm</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">2021</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<title level="m">Quantum public-key cryptosystems based on induced trapdoor one-way transformations. arXiv: Quantum Physics</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Quantum public-key encryption schemes based on conjugate coding. Quantum Information Processing</title>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Xiang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
